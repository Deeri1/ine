local hat = false
local net = true
if hat == true then
	game:GetService("Players").LocalPlayer.Character["MeshPartAccessory"].Name = "gamer2"
	game:GetService("Players").LocalPlayer.Character["MeshPartAccessory"].Name = "gamer1"
	game:GetService("Players").LocalPlayer.Character["ShadowBladeMasterAccessory"].Name = "gamer3"
	game:GetService("Players").LocalPlayer.Character["MeshPartAccessory"].Name = "gamer4"
	game:GetService("Players").LocalPlayer.Character["MeshPartAccessory"].Name = "gamer5"
	game:GetService("Players").LocalPlayer.Character["BladeMasterAccessory"].Name = "gamer6"
end
if net == true then
	for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
		if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
			game:GetService("RunService").Heartbeat:connect(function()
				v.Velocity = Vector3.new(30,0,0)
			end)
		end
	end

	getgenv().ReanimateVersion = "v5"

	loadstring(game:HttpGet("https://raw.githubusercontent.com/stangithuboffical/selexity/main/Reanimate", true))()
	wait(2.5)

end

wait()
local Player = game.Players.LocalPlayer
mouse = Player:GetMouse()
Mouse = mouse
do
	local CAS = {Actions={}}
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInput_Event"
	Event.Parent = Player.Character
	local fakeEvent = function()
		local t = {_fakeEvent=true}
		t.Connect = function(self,f)self.Function=f end
		t.connect = t.Connect
		return t
	end
	local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
	local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
	function CAS:BindAction(name,fun,touch,...)
		CAS.Actions[name] = {Name=name,Function=fun,Keys={...}}
	end
	function CAS:UnbindAction(name)
		CAS.Actions[name] = nil
	end
	local function te(self,ev,...)
		local t = m[ev]
		if t and t._fakeEvent and t.Function then
			t.Function(...)
		end
	end
	m.TrigEvent = te
	UIS.TrigEvent = te
end

wait(0.5)
local walksine = 10
local walkc = 1
local sine2 = -10
local c2 = 1
warn([[]])


------------- ORIGINAL WIELDER OC: Velnorum
print([[]])
warn([[]])
--- its obs smooth af do not touch 
---- Sources and functions might be taken from others
plr = Player
char = plr.Character
hum = char.Humanoid
local cam = game.Workspace.CurrentCamera
Camera = cam
local CamInterrupt = false
local TwoD = false
local TargetInfo = {nil, nil}
cam.CameraType = "Custom"
t = char.Torso
h = char.Head
ra = char["Right Arm"]
la = char["Left Arm"]
rl = char["Right Leg"]
ll = char["Left Leg"]
tors = char.Torso
lleg = char["Left Leg"]
root = char.HumanoidRootPart
hed = char.Head
rleg = char["Right Leg"]
rarm = char["Right Arm"]
larm = char["Left Arm"]
radian = math.rad
random = math.random
Vec3 = Vector3.new
Inst = Instance.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new

local Booleans = {
	CamFollow = true,
	GyroUse = true
}

function lerp(object, newCFrame, alpha)
	return object:lerp(newCFrame, alpha)
end

local Directer = Inst("BodyGyro", root)
Directer.MaxTorque = Vec3(0, 0, 0)
Directer.P = 600000
local CPart = Inst("Part")
CPart.Anchored = true
CPart.CanCollide = false
CPart.Locked = true
CPart.Transparency = 1

local rainbowmode = false
local chaosmode = false

local kan = Instance.new("Sound",char)
kan.Volume = 10
kan.TimePosition = 0
kan.PlaybackSpeed = 1
kan.Pitch = 1
kan.SoundId = "rbxassetid://614032233"
kan.Name = "WW"
kan.Looped = true
kan:Play()

local currentThemePlaying = kan.SoundId
local currentPitch = kan.Pitch
local currentVol = kan.Volume
function newTheme(ID,timepos,pitch,vol)
	for i,v in pairs(workspace:GetDescendants()) do
		if v:FindFirstChild("WW") ~= nil then
			--v.P:FindFirstChild("WW"):destroy()
			local kanz = kan
			--kanz:Stop()
			kanz.Volume = vol
			--kanz.TimePosition = timepos
			kanz.PlaybackSpeed = pitch
			kanz.Pitch = pitch
			kanz.SoundId = ID
			kanz.Name = "WW"
			kanz.Looped = true
			currentThemePlaying = kanz.SoundId
			currentVol = kanz.Volume
			currentPitch = kanz.Pitch
			--kanz:Play()
			--coroutine.resume(coroutine.create(function()
			--wait(0.05)
			--end))
		end
	end
end


function newThemeCust(ID,timepos,pitch,vol)
	for i,v in pairs(workspace:GetDescendants()) do
		if v:FindFirstChild("WW") ~= nil then
			local kanz = kan
			kanz:Stop()
			kanz.Volume = vol
			kanz.TimePosition = timepos
			kanz.PlaybackSpeed = pitch
			kanz.Pitch = pitch
			kanz.SoundId = ID
			kanz.Name = "WW"
			kanz.Looped = true
			currentThemePlaying = kanz.SoundId
			currentVol = kanz.Volume
			currentPitch = kanz.Pitch
			kanz:Play()
			coroutine.resume(coroutine.create(function()
				wait(0.05)
			end))
		end
	end
end
coroutine.resume(coroutine.create(function()
	while true do
		swait()
		for i,v in pairs(workspace:GetDescendants()) do
			if v:FindFirstChild("WW") == nil then
				local kan = Instance.new("Sound",char)
				kan.Volume = currentVol
				kan.TimePosition = 0
				kan.PlaybackSpeed = 1
				kan.Pitch = currentPitch
				kan.SoundId = currentThemePlaying
				kan.Name = "WW"
				kan.Looped = true
				kan:Play()
			end
		end
	end
end))

local mutedtog = false

function CameraEnshaking(Length,Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1*Intensity
		local rotM = 0.01*Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05*Intensity/Length
			rotM = rotM - 0.0005*Intensity/Length
			hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
			cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
		end
		Humanoid.CameraOffset = Vec3(0, 0, 0)
	end))
end
CamShake=function(Part,Distan,Power,Times) 
	local de=Part.Position
	for i,v in pairs(workspace:children()) do
		if v:IsA("Model") and v:findFirstChild("Humanoid") then
			for _,c in pairs(v:children()) do
				if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
					local Noob=v.Humanoid
					if Noob~=nil then
						coroutine.resume(coroutine.create(function()
							FV = Instance.new("BoolValue", Noob)
							FV.Name = "CameraShake"
							for ShakeNum=1,Times do
								swait()
								local ef=Power
								if ef>=1 then
									Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
								else
									ef=Power*10
									Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
								end	
							end
							Humanoid.CameraOffset = Vector3.new(0,0,0)
							FV:Destroy()
						end))
						CameraShake(Times, Power, Noob)
					end
				end
			end
		end
	end
end

local toggleTag = true
local bilguit = Instance.new("BillboardGui", hed)
bilguit.Adornee = nil
bilguit.Name = "FFF"
bilguit.Size = UDim2.new(4, 0, 1.2, 0)
bilguit.StudsOffset = Vector3.new(-8, 8/1.5, 0)



function bosschatfunc(text,color,watval)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("Dialog")~= nil then
				v.PlayerGui:FindFirstChild("Dialog"):destroy()
			end
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
			scrg.Name = "Dialog"
			local txtlb = Instance.new("TextLabel",scrg)
			txtlb.Text = ""
			txtlb.Font = "Bodoni"
			txtlb.TextColor3 = Color3.new(0,0,0)
			txtlb.TextStrokeTransparency = 0
			txtlb.BackgroundTransparency = 0.75
			txtlb.BackgroundColor3 = Color3.new(0,0,0)
			txtlb.TextStrokeColor3 = color
			txtlb.TextScaled = true
			txtlb.Size = UDim2.new(1,0,0.25,0)
			txtlb.TextXAlignment = "Left"
			txtlb.Position = UDim2.new(0,0,0.75 + 1,0)
			local txtlb2 = Instance.new("TextLabel",scrg)
			txtlb2.Text = "???:"
			txtlb2.Font = "Arcade"
			txtlb2.TextColor3 = Color3.new(0,0,0)
			txtlb2.TextStrokeTransparency = 0
			txtlb2.BackgroundTransparency = 1
			txtlb2.TextStrokeColor3 = color
			txtlb2.TextSize = 40
			txtlb2.Size = UDim2.new(1,0,0.25,0)
			txtlb2.TextXAlignment = "Left"
			txtlb2.Position = UDim2.new(0,0,1,0)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if chaosmode == true then
						txtlb.Rotation = math.random(-1,1)
						txtlb2.Rotation = math.random(-1,1)
						txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
						txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
						txtlb.TextStrokeColor3 = BrickColor.random().Color
						txtlb2.TextStrokeColor3 = BrickColor.random().Color
					end
				end
			end))
			coroutine.resume(coroutine.create(function()
				while true do
					swait()
					if scrg.Parent ~= nil then
						fvalen = fvalen - 0.0001
					elseif scrg.Parent == nil then
						break
					end
				end
			end))
			local flol = 1.75
			local flil = 1.6
			coroutine.resume(coroutine.create(function()
				for i = 0, 9 do
					swait()
					fval = fval + 0.05
					flol = flol - 0.1
					flil = flil - 0.1
					txtlb.Text = ""
					txtlb.Position = UDim2.new(0,0,flol,0)
					txtlb2.Position = UDim2.new(0,0,flil,0)
				end
				txtlb.Text = text
				wait(watval)
				local valinc = 0
				for i = 0, 99 do
					swait()
					valinc = valinc + 0.0001
					flol = flol + valinc
					flil = flil + valinc
					txtlb.Rotation = txtlb.Rotation + valinc*20
					txtlb2.Rotation = txtlb2.Rotation - valinc*50
					txtlb.Position = UDim2.new(0,0,flol,0)
					txtlb2.Position = UDim2.new(0,0,flil,0)
					txtlb.TextStrokeTransparency = txtlb.TextStrokeTransparency + 0.01
					txtlb.TextTransparency = txtlb.TextTransparency + 0.01
					txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
					txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
					txtlb.BackgroundTransparency = txtlb.BackgroundTransparency + 0.0025
				end
				scrg:Destroy()
			end))
		end))
	end
end


FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
local Create = FELOADLIBRARY.Create
CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};

	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};

	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};

	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};

	["TimeSound"] = {
		Create = function(id, par, vol, pit, timepos) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					TimePosition = timepos,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};
	["EchoSound"] = {
		Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
			coroutine.resume(coroutine.create(function()
				local Sas = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					TimePosition = timepos,
					Parent = par or workspace,
				}
				local E = Create("EchoSoundEffect"){
					Delay = echodelay,
					Name = "Echo",
					Feedback = fedb,
					DryLevel = dryl,
					Parent = Sas,
				}
				wait() 
				Sas:play() 
				game:GetService("Debris"):AddItem(Sas, delays)
			end))
		end;
	};

	["LongSound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 60)
			end))
		end;
	};

	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {

	};
}



New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
local halocolor = BrickColor.new("Pastel light blue")
local halocolor2 = BrickColor.new("Cool yellow")
local starcolor = BrickColor.new("Bright yellow")
local lunacolor = BrickColor.new("Navy blue")
local lunacolor2 = BrickColor.new("Bright blue")
local wepcolor = BrickColor.new("Really black")
local maincolor = BrickColor.new("Really black")
local m = Instance.new("Model",char)
local m2 = Instance.new("Model",char)
local m3 = Instance.new("Model",char)
local mw1 = Instance.new("Model",char)
local mw2 = Instance.new("Model",char)


gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
	local gui = it(GuiType)
	gui.Parent = parent
	gui.Text = text
	gui.BackgroundTransparency = backtrans
	gui.BackgroundColor3 = backcol
	gui.SizeConstraint = "RelativeXY"
	gui.TextXAlignment = "Center"
	gui.TextYAlignment = "Center"
	gui.Position = pos
	gui.Size = size
	gui.Font = "SourceSans"
	gui.FontSize = "Size14"
	gui.TextWrapped = false
	gui.TextStrokeTransparency = 0
	gui.TextColor = BrickColor.new("White")
	return gui
end
--------------------------- GUI STUFF
local extrawingmod1 = Instance.new("Model",char)
local extrawingmod2 = Instance.new("Model",char)

function CreateParta(parent,transparency,reflectance,material,brickcolor)
	local p = Instance.new("Part")
	p.TopSurface = 0
	p.BottomSurface = 0
	p.Parent = parent
	p.Size = Vector3.new(0.1,0.1,0.1)
	p.Transparency = transparency
	p.Reflectance = reflectance
	p.CanCollide = false
	p.Locked = true
	p.BrickColor = brickcolor
	p.Material = material
	return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
	local mesh = Instance.new("SpecialMesh",parent)
	mesh.MeshType = meshtype
	mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
	return mesh
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
	local mesh = Instance.new("SpecialMesh",parent)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = meshid
	mesh.Scale = Vector3.new(x1,y1,z1)
	return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
	local mesh = Instance.new("SpecialMesh",parent)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = meshid
	mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
	mesh.Scale = Vector3.new(x1,y1,z1)
	mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
	return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
	local weld = Instance.new("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
	weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
	return weld
end


--------------
--------------
local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb,rarm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb2,larm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local sorb3 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb3,tors,sorb3,0,-0,-2,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



local MAINRUINCOLOR = BrickColor.new("Really red")
local MAINRUINCOLOR2 = BrickColor.new("Really black")
------


function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
	RemoveOutlines(Part)
	return Part
end
function CreateMesha(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end

Character=Player.Character 
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character.Humanoid
m=Instance.new('Model',Character)
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LS=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RS=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
cloaked=false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
attackdebounce = false 
deb=false
equipped=true
hand=false
combo=0
mana=0
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
local Effects={}
local gun=false
local shoot=false
local sine = 0
local change = 1

--save shoulders 
RSH, LSH=nil, nil 
--welds 
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
function NoOutline(Part)
	Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil 
-- 
RW.Name="Right Shoulder"
RW.Part0=ch.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=ch["Right Arm"] 
RW.Parent=ch.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=ch.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=ch["Left Arm"] 
LW.Parent=ch.Torso 

local Stats=Instance.new("BoolValue")
Stats.Name="Stats"
Stats.Parent=Character
local Atk=Instance.new("NumberValue")
Atk.Name="Damage"
Atk.Parent=Stats
Atk.Value=1
local Def=Instance.new("NumberValue")
Def.Name="Defense"
Def.Parent=Stats
Def.Value=1
local Speed=Instance.new("NumberValue")
Speed.Name="Speed"
Speed.Parent=Stats
Speed.Value=1
local Mvmt=Instance.new("NumberValue")
Mvmt.Name="Movement"
Mvmt.Parent=Stats
Mvmt.Value=1

local donum=0

function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
	local fp=it("Part")
	fp.formFactor=formfactor 
	fp.Parent=parent
	fp.Reflectance=reflectance
	fp.Transparency=transparency
	fp.CanCollide=false 
	fp.Locked=true
	fp.BrickColor=brickcolor
	fp.Name=name
	fp.Size=size
	fp.Position=Torso.Position 
	NoOutline(fp)
	fp.Material="SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 

function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh=it(Mesh) 
	mesh.Parent=part
	if Mesh=="SpecialMesh" then
		mesh.MeshType=meshtype
		if meshid~="nil" then
			mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset=offset
	mesh.Scale=scale
	return mesh
end

function weld(parent,part0,part1,c0)
	local weld=it("Weld") 
	weld.Parent=parent
	weld.Part0=part0 
	weld.Part1=part1 
	weld.C0=c0
	return weld
end

local Color1=Torso.BrickColor

local bodvel=Instance.new("BodyVelocity")
local bg=Instance.new("BodyGyro")

--------- SazEreno's Artificial HB --------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")
Frame_Speed = 1 / 60
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

------------------
function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, num do
			ArtificialHB.Event:wait()
		end
	end
end
-------- RAINBOW LEAVE IT TO ME
local r = 255
local g = 0
local b = 0
coroutine.resume(coroutine.create(function()
	while wait() do
		for i = 0, 254/5 do
			swait()
			g = g + 5
		end
		for i = 0, 254/5 do
			swait()
			r = r - 5
		end
		for i = 0, 254/5 do
			swait()
			b = b + 5
		end
		for i = 0, 254/5 do
			swait()
			g = g - 5
		end
		for i = 0, 254/5 do
			swait()
			r = r + 5
		end
		for i = 0, 254/5 do
			swait()
			b = b - 5
		end
	end
end))


so = function(id,par,vol,pit) 
	coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound",par or workspace)
		sou.Volume=vol
		sou.Pitch=pit or 1
		sou.SoundId=id
		swait() 
		sou:play() 
		game:GetService("Debris"):AddItem(sou,6)
	end))
end

function clerp(a,b,t) 
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)} 
	local ax, ay, az = a.x, a.y, a.z 
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1-t
	return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 

function QuaternionFromCFrame(cf) 
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
	local trace = m00 + m11 + m22 
	if trace > 0 then 
		local s = math.sqrt(1 + trace) 
		local recip = 0.5/s 
		return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
	else 
		local i = 0 
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then 
			i = 2 
		end 
		if i == 0 then 
			local s = math.sqrt(m00-m11-m22+1) 
			local recip = 0.5/s 
			return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
		elseif i == 1 then 
			local s = math.sqrt(m11-m22-m00+1) 
			local recip = 0.5/s 
			return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
		elseif i == 2 then 
			local s = math.sqrt(m22-m00-m11+1) 
			local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
		end 
	end 
end

function QuaternionToCFrame(px, py, pz, x, y, z, w) 
	local xs, ys, zs = x + x, y + y, z + z 
	local wx, wy, wz = w*xs, w*ys, w*zs 
	local xx = x*xs 
	local xy = x*ys 
	local xz = x*zs 
	local yy = y*ys 
	local yz = y*zs 
	local zz = z*zs 
	return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end

function QuaternionSlerp(a, b, t) 
	local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
	local startInterp, finishInterp; 
	if cosTheta >= 0.0001 then 
		if (1 - cosTheta) > 0.0001 then 
			local theta = math.acos(cosTheta) 
			local invSinTheta = 1/math.sin(theta) 
			startInterp = math.sin((1-t)*theta)*invSinTheta 
			finishInterp = math.sin(t*theta)*invSinTheta  
		else 
			startInterp = 1-t 
			finishInterp = t 
		end 
	else 
		if (1+cosTheta) > 0.0001 then 
			local theta = math.acos(-cosTheta) 
			local invSinTheta = 1/math.sin(theta) 
			startInterp = math.sin((t-1)*theta)*invSinTheta 
			finishInterp = math.sin(t*theta)*invSinTheta 
		else 
			startInterp = t-1 
			finishInterp = t 
		end 
	end 
	return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

local function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CFrame.new(at.x, at.y, at.z,
		right.x, top.x, back.x,
		right.y, top.y, back.y,
		right.z, top.z, back.z)
end

function Triangle(a, b, c)
	local edg1 = (c-a):Dot((b-a).unit)
	local edg2 = (a-b):Dot((c-b).unit)
	local edg3 = (b-c):Dot((a-c).unit)
	if edg1 <= (b-a).magnitude and edg1 >= 0 then
		a, b, c = a, b, c
	elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
		a, b, c = b, c, a
	elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
		a, b, c = c, a, b
	else
		assert(false, "unreachable")
	end

	local len1 = (c-a):Dot((b-a).unit)
	local len2 = (b-a).magnitude - len1
	local width = (a + (b-a).unit*len1 - c).magnitude

	local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)

	local list = {}

	if len1 > 0.01 then
		local w1 = Instance.new('WedgePart', m)
		game:GetService("Debris"):AddItem(w1,5)
		w1.Material = "SmoothPlastic"
		w1.FormFactor = 'Custom'
		w1.BrickColor = BrickColor.new("Really red")
		w1.Transparency = 0
		w1.Reflectance = 0
		w1.Material = "SmoothPlastic"
		w1.CanCollide = false
		local l1 = Instance.new("PointLight",w1)
		l1.Color = Color3.new(170,0,0)
		NoOutline(w1)
		local sz = Vector3.new(0.2, width, len1)
		w1.Size = sz
		local sp = Instance.new("SpecialMesh",w1)
		sp.MeshType = "Wedge"
		sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
		w1:BreakJoints()
		w1.Anchored = true
		w1.Parent = workspace
		w1.Transparency = 0.7
		table.insert(Effects,{w1,"Disappear",.01})
		w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
		table.insert(list,w1)
	end

	if len2 > 0.01 then
		local w2 = Instance.new('WedgePart', m)
		game:GetService("Debris"):AddItem(w2,5)
		w2.Material = "SmoothPlastic"
		w2.FormFactor = 'Custom'
		w2.BrickColor = BrickColor.new("Really red")
		w2.Transparency = 0
		w2.Reflectance = 0
		w2.Material = "SmoothPlastic"
		w2.CanCollide = false
		local l2 = Instance.new("PointLight",w2)
		l2.Color = Color3.new(170,0,0)
		NoOutline(w2)
		local sz = Vector3.new(0.2, width, len2)
		w2.Size = sz
		local sp = Instance.new("SpecialMesh",w2)
		sp.MeshType = "Wedge"
		sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
		w2:BreakJoints()
		w2.Anchored = true
		w2.Parent = workspace
		w2.Transparency = 0.7
		table.insert(Effects,{w2,"Disappear",.01})
		w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
		table.insert(list,w2)
	end
	return unpack(list)
end


function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
	if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Head") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
			return
		end
		local c = Create("ObjectValue")({
			Name = "creator",
			Value = game:GetService("Players").WariorNoob140,
			Parent = h
		})
		game:GetService("Debris"):AddItem(c, 0.5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil and block.className == "IntValue" and block.Value > 0 then
			blocked = true
			block.Value = block.Value - 1
			print(block.Value)
		end
		if blocked == false then
			HitHealth = h.Health
			h.MaxHealth = 100
			h.Health = h.Health - Damage
			if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
				print("gained kill")
				dmg(h.Parent)
			end
			ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
		else
			h.Health = h.Health - Damage / 2
			ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
			local bodvol = Create("BodyVelocity")({
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = hit
			})
			local rl = Create("BodyAngularVelocity")({
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit
			})
			game:GetService("Debris"):AddItem(bodvol, 0.5)
			game:GetService("Debris"):AddItem(rl, 0.5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity")({
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
			})
			if knockback > 0 then
				vp.Parent = hit.Parent.Head
			end
			game:GetService("Debris"):AddItem(vp, 0.5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity")({
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = hit
			})
			game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
			local bodyVelocity = Create("BodyVelocity")({
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = hit
			})
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Leech" then
			local hum = hit.Parent.Humanoid
			if hum ~= nil then
				for i = 0, 2 do
					Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
				end
				Humanoid.Health = Humanoid.Health + 10
			end
		elseif Type == "UpKnock" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			if hum ~= nil then
				hitr = true
			end
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(5)
				HHumanoid.PlatformStand = false
				hitr = false
			end), hum)
			local bodyVelocity = Create("BodyVelocity")({
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = hit
			})
			game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
			local bodyVelocity = Create("BodyVelocity")({
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = hit
			})
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition")({
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso
			})
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Slashnare" then
			Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
			for i = 1, math.random(4, 5) do
				Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
			end
			local bp = Create("BodyPosition")({
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso
			})
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Spike" then
			CreateBigIceSword(hit.Parent.Torso.CFrame)
			local bp = Create("BodyPosition")({
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso
			})
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition")({
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso
			})
			local BodGy = Create("BodyGyro")({
				maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
				P = 20000,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame
			})
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part)
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue")({
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true
		})
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Instance.new("ObjectValue")
		c.Name = "creator"
		c.Value = Player
		c.Parent = h
		game:GetService("Debris"):AddItem(c, 0.5)
	end
end
function ShowDamage(Pos, Text, Time, Color)
	local Rate = 0.03333333333333333
	local Pos = Pos or Vector3.new(0, 0, 0)
	local Text = Text or ""
	local Time = Time or 2
	local Color = Color or Color3.new(1, 0, 1)
	local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui")({
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart
	})
	local TextLabel = Create("TextLabel")({
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		TextColor3 = Color,
		TextScaled = true,
		Font = Enum.Font.ArialBold,
		Parent = BillboardGui
	})
	game.Debris:AddItem(EffectPart, Time + 0.1)
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = Time / Rate
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = Frame / Frames
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChildOfClass("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Head")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if magni >= mag and c.Name ~= Player.Name then
					Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
				end
			end
		end
	end
end

function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChild("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Torso")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if magni >= mag and c.Name ~= Player.Name then
					MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
					Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
				end
			end
		end
	end
end

function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
	return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 

function SkullEffect(brickcolor,cframe,x1,y1,z1,delay)
	local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.CFrame=cframe
	local msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=4770583",vt(0,0,0),vt(x1,y1,z1))
	--http://www.roblox.com/asset/?id=4770560
	game:GetService("Debris"):AddItem(prt,2)
	CF=prt.CFrame
	coroutine.resume(coroutine.create(function(Part,Mesh,TehCF) 
		for i=0,1,0.2 do
			wait()
			Part.CFrame=CF*cf(0,0,-0.4)
		end
		for i=0,1,delay do
			wait()
			--Part.CFrame=CF*cf((math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5)
			Mesh.Scale=Mesh.Scale
		end
		for i=0,1,0.1 do
			wait()
			Part.Transparency=i
		end
		Part.Parent=nil
	end),prt,msh,CF)
end

function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
	local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.Material = "Neon"
	prt.CFrame=cframe
	prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
	msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		for i=0,1,delay do
			swait()
			Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
			Part.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
		end
		Part.Parent=nil
	end),prt,msh)
end

function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
	local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.Material = "Neon"
	prt.CFrame=cframe
	msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		local rtype = rottype
		for i=0,1,delay do
			swait()
			if rtype == 1 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
			elseif rtype == 2 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
			end
			Part.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
		end
		Part.Parent=nil
	end),prt,msh)
end

function MagicSphere(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
	local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.CFrame=cframe
	prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
	msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		for i=0,1,delay do
			wait()
			Part.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
		end
		Part.Parent=nil
	end),prt,msh)
end

function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
	local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.Material = "Neon"
	prt.CFrame=cframe
	msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		local rtype = rottype
		for i=0,1,delay do
			swait()
			if rtype == 1 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
			elseif rtype == 2 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
			end
			Part.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
		end
		Part.Parent=nil
	end),prt,msh)
end

function MagicShock(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
	local prt=part(3,char,1,1,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.Material = "Neon"
	prt.CFrame=cframe
	local dec = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
	local dec2 = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
	msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		local rtype = rottype
		for i=0,1,delay do
			swait()
			if rtype == 1 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
			elseif rtype == 2 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
			end
			dec.Transparency=i
			dec2.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
		end
		Part.Parent=nil
	end),prt,msh)
end

function MagicShockAlt(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
	local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.Material = "Neon"
	prt.CFrame=cframe
	msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		local rtype = rottype
		for i=0,1,delay do
			swait()
			if rtype == 1 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
			elseif rtype == 2 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
			end
			prt.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
		end
		Part.Parent=nil
	end),prt,msh)
end

function MagicShockAltCircle(brickcolor,cframe,x1,z1,x3,z3,delay,rottype)
	local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.Material = "Neon"
	prt.CFrame=cframe
	msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,1,z1))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		local rtype = rottype
		for i=0,1,delay do
			swait()
			if rtype == 1 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0.1,0)
			elseif rtype == 2 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,-0.1,0)
			end
			prt.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,0,z3)
		end
		Part.Parent=nil
	end),prt,msh)
end

function MagicShockTrailAlt(brickcolor,cframe,x1,y1,z1,x3,y3,delay,rottype)
	local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.Material = "Neon"
	prt.CFrame=cframe
	msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		local rtype = rottype
		for i=0,1,delay do
			swait()
			if rtype == 1 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
			elseif rtype == 2 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
			end
			prt.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
		end
		Part.Parent=nil
	end),prt,msh)
end

function MagicShockTrailAlt2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
	local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.Material = "Neon"
	prt.CFrame=cframe
	msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		local rtype = rottype
		for i=0,1,delay do
			swait()
			if rtype == 1 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
			elseif rtype == 2 then
				prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
			end
			prt.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
		end
		Part.Parent=nil
	end),prt,msh)
end

function MagicBlock2(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
	local prt=part(3,char,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=false
	prt.CFrame=cframe
	msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
	local wld=weld(prt,prt,Parent,cframe)
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
		for i=0,1,delay do
			wait()
			Weld.C0=euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))*cframe
			--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
			Part.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
		end
		Part.Parent=nil
	end),prt,msh,wld)
end

function MagicBlock3(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
	local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=false
	prt.CFrame=cframe
	msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
	local wld=weld(prt,prt,Parent,euler(0,0,0)*cf(0,0,0))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
		for i=0,1,delay do
			wait()
			Weld.C0=euler(i*20,0,0)
			--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
			Part.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
		end
		Part.Parent=nil
	end),prt,msh,wld)
end

function MagicCircle2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
	local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.CFrame=cframe
	local msh=mesh("CylinderMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,2)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		for i=0,1,delay do
			wait()
			Part.CFrame=Part.CFrame
			Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			local prt2=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
			prt2.Anchored=true
			prt2.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
			local msh2=mesh("SpecialMesh",prt2,"Sphere","",vt(0,0,0),vt(0.5,0.5,0.5))
			game:GetService("Debris"):AddItem(prt2,2)
			coroutine.resume(coroutine.create(function(Part,Mesh) 
				for i=0,1,0.1 do
					wait()
					Part.CFrame=Part.CFrame*cf(0,0.5,0)
				end
				Part.Parent=nil
			end),prt2,msh2)
		end
		for i=0,1,delay*2 do
			wait()
			Part.CFrame=Part.CFrame
			Mesh.Scale=vt((x1+x3)-(x1+x3)*i,(y1+y3)-(y1+y3)*i,(z1+z3)-(z1+z3)*i)
		end
		Part.Parent=nil
	end),prt,msh)
end

function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
	local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.CFrame=cframe
	local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,2)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		for i=0,1,delay do
			wait()
			Part.CFrame=Part.CFrame
			Part.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
		end
		Part.Parent=nil
	end),prt,msh)
end

function BreakEffect(brickcolor,cframe,x1,y1,z1)
	local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
	local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,2)
	coroutine.resume(coroutine.create(function(Part,CF,Numbb,randnumb) 
		CF=Part.CFrame
		Numbb=0
		randnumb=math.random()/10
		rand1=math.random()/10
		for i=0,1,rand1 do
			wait()
			CF=CF*cf(0,math.random()/2,0)
			--Part.CFrame=Part.CFrame*euler(0.5,0,0)*cf(0,1,0)
			Part.CFrame=CF*euler(Numbb,0,0)
			Part.Transparency=i
			Numbb=Numbb+randnumb
		end
		Part.Parent=nil
	end),prt,CF,Numbb,randnumb)
end

function MagicWaveThing(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
	local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.CFrame=cframe
	msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=1051557",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		for i=0,1,delay do
			wait()
			Part.CFrame=Part.CFrame*euler(0,0.7,0)
			Part.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
		end
		Part.Parent=nil
	end),prt,msh)
end

function WaveEffect(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
	local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.CFrame=cframe
	msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=20329976",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,2)
	coroutine.resume(coroutine.create(function(Part,Mesh) 
		for i=0,1,delay do
			wait()
			Part.CFrame=Part.CFrame*cf(0,y3/2,0)
			Part.Transparency=i
			Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
		end
		Part.Parent=nil
	end),prt,msh)
end

function StravEffect(brickcolor,cframe,x,y,z,x1,y1,z1,delay)
	local prt=part(3,workspace,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
	prt.Anchored=true
	prt.CFrame=cframe*cf(x,y,z)
	msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://168892363",vt(0,0,0),vt(x1,y1,z1))
	game:GetService("Debris"):AddItem(prt,5)
	coroutine.resume(coroutine.create(function(Part,Mesh,ex,why,zee) 
		local num=math.random()
		local num2=math.random(-3,2)+math.random()
		local numm=0
		for i=0,1,delay*2 do
			swait()
			Part.CFrame=cframe*euler(0,numm*num*10,0)*cf(ex,why,zee)*cf(-i*10,num2,0)
			Part.Transparency=i
			numm=numm+0.01
		end
		Part.Parent=nil
		Mesh.Parent=nil
	end),prt,msh,x,y,z)
end

function dmgstart(dmg,what)
	hitcon = what.Touched:connect(function(hit)
		local hum = hit.Parent:FindFirstChild("Humanoid")
		if hum and not hum:IsDescendantOf(Character) then
			hum:TakeDamage(dmg)
		end
	end)
end

function dmgstop()
	hitcon:disconnect()
end

function Cloak()
	Face.Parent=nil
	cloaked=true
	for _,v in pairs(Torso.Parent:children()) do
		if v.className=="Part" and v.Name~="HumanoidRootPart" then
			coroutine.resume(coroutine.create(function() 
				for i=0,1,0.2 do
					wait()
					v.Transparency=i
				end
				v.Transparency=1
			end))
		end
		if v.className=="Hat" then
			hatp=v.Handle
			coroutine.resume(coroutine.create(function(derp) 
				for i=0,1,0.2 do
					wait()
					derp.Transparency=i
				end
				derp.Transparency=1
			end),hatp)
		end
	end
	for _,v in pairs(m:children()) do
		if v.className=="Part" then
			coroutine.resume(coroutine.create(function() 
				for i=0,1,0.2 do
					wait()
					v.Transparency=i
				end
				v.Transparency=1
			end))
		end
	end
end

function UnCloak()
	so("http://roblox.com/asset/?id=2767090",Torso,1,1.1) 
	Face.Parent=Head 
	cloaked=false
	for _,v in pairs(Torso.Parent:children()) do
		if v.className=="Part" and v.Name~="HumanoidRootPart" then
			coroutine.resume(coroutine.create(function() 
				for i=0,1,0.1 do
					wait()
					v.Transparency=v.Transparency-0.1
				end
				v.Transparency=0
			end))
		end
		if v.className=="Hat" then
			hatp=v.Handle
			coroutine.resume(coroutine.create(function(derp) 
				for i=0,1,0.1 do
					wait()
					derp.Transparency=derp.Transparency-0.1
				end
				derp.Transparency=0
			end),hatp)
		end
	end
	for _,v in pairs(m:children()) do
		if v.className=="Part" and v.Name~="hitbox" and v.Name~='tip' then
			coroutine.resume(coroutine.create(function() 
				for i=0,1,0.1 do
					wait()
					v.Transparency=v.Transparency-0.1
				end
				v.Transparency=0
			end))
			v.Transparency=0
		end
	end
end

local origcolor = BrickColor.new("Pastel light blue")
---- This section of explosions.

----


function ring(type,pos,scale,value)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
		end
		rng:Destroy()
	end))
end


function wave(type,pos,scale,value)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
		end
		rng:Destroy()
	end))
end

function wind(type,pos,scale,value,speed)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
		end
		rng:Destroy()
	end))
end

function groundwind(type,pos,scale,value,speed)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
		end
		rng:Destroy()
	end))
end
local norot = Instance.new("Part",char)
norot.Size = Vector3.new(0.05,0.05,0.05)
norot.Transparency = 1
norot.Anchored = true
norot.CanCollide = false

function CameraManager()
	if TwoD and not CamInterrupt then
		if Humanoid.Health > 0 then
			Camera.CameraSubject = Humanoid
			Camera.CameraType = "Scriptable"
			Humanoid.AutoRotate = false
			if Booleans.GyroUse then
				Directer.MaxTorque = Vec3(0, huge, 0)
			else
				Directer.MaxTorque = Vec3(0, 0, 0)
			end
			if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
				if Booleans.CamFollow then
					CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
					Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
				else
					CPart.Position = RootPart.Position
				end
			else
				local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
				CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
			end
			Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
		else
			Camera.CameraSubject = Humanoid
			Camera.CameraType = "Custom"
			Controller.Disabled = false
		end
	end
end

function ring(type,pos,scale,value)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
		end
		rng:Destroy()
	end))
end


function wave(type,pos,scale,value)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
		end
		rng:Destroy()
	end))
end

function sphere(bonuspeed,type,pos,scale,value,color)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	if ModeOfGlitch ~= 9 then
		rng.BrickColor = color
	elseif ModeOfGlitch == 9 then
		rng.Color = Color3.new(0/1000,0/1000,0/1000)
	end
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	if ModeOfGlitch == 9 then
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rng.Parent ~= nil then
					rng.Color = Color3.new(0/1000,0/1000,0/1000)
				else
					break
				end
			end
		end))
	end
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	if ModeOfGlitch == 9 then
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rng.Parent ~= nil then
					rng.Color = Color3.new(0/1000,0/1000,0/1000)
				else
					break
				end
			end
		end))
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
	local type = type
	local rotenable = rotatingop
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	if typeoftrans == "In" then
		rng.Transparency = 1
	end
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "FileMesh"
	if typeofshape == "Normal" then
		rngm.MeshId = "rbxassetid://662586858"
	elseif typeofshape == "Round" then
		rngm.MeshId = "rbxassetid://662585058"
	end
	rngm.Scale = scale
	local scaler2 = 1/10
	if type == "Add" then
		scaler2 = 1*value/10
	elseif type == "Divide" then
		scaler2 = 1/value/10
	end
	local randomrot = math.random(1,2)
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed/10
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed/10
			end
			if rotenable == true then
				if randomrot == 1 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
				elseif randomrot == 2 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
				end
			end
			if typeoftrans == "Out" then
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
			elseif typeoftrans == "In" then
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
			end
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
		end
		rng:Destroy()
	end))
end

function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 1
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			--rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 1
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 0
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder + 0.01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			--rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.Color = color3
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function PIXXLEEE(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	if ModeOfGlitch ~= 9 then
		rng.BrickColor = color
	elseif ModeOfGlitch == 9 then
		rng.Color = Color3.new(0/1000,0/1000,0/1000)
	end
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	if ModeOfGlitch == 9 then
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rng.Parent ~= nil then
					rng.Color = Color3.new(0/1000,0/1000,0/1000)
				else
					break
				end
			end
		end))
	end
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
		end
		rng:Destroy()
	end))
end
function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	if ModeOfGlitch ~= 9 then
		rng.BrickColor = color
	elseif ModeOfGlitch == 9 then
		rng.Color = Color3.new(0/1000,0/1000,0/1000)
	end
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	if ModeOfGlitch == 9 then
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rng.Parent ~= nil then
					rng.Color = Color3.new(0/1000,0/1000,0/1000)
				else
					break
				end
			end
		end))
	end
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
		end
		rng:Destroy()
	end))
end


function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	if ModeOfGlitch ~= 9 then
		rng.BrickColor = color
	elseif ModeOfGlitch == 9 then
		rng.Color = Color3.new(0/1000,0/1000,0/1000)
	end
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 1
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	if ModeOfGlitch == 9 then
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rng.Parent ~= nil then
					rng.Color = Color3.new(0/1000,0/1000,0/1000)
				else
					break
				end
			end
		end))
	end
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency - 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function dmg(dude)
	if dude.Name ~= Character then
		local keptcolor = MAINRUINCOLOR
		local bgf = Instance.new("BodyGyro",dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
--[[local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"]]--
		local ds = coroutine.wrap(function()
			dude:WaitForChild("Head"):BreakJoints()
			for i, v in pairs(dude:GetChildren()) do
				if v:IsA("Part") or v:IsA("MeshPart") then
					v.Name = "DEMINISHED"
				end
			end
			wait(0.5)
			targetted = nil
			CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.75, 0.285)
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							v.Anchored = false
							local bld = Instance.new("ParticleEmitter",v)
							bld.LightEmission = 0.75
							bld.Texture = "rbxassetid://363275192" ---284205403
							bld.Color = ColorSequence.new(keptcolor.Color)
							bld.Rate = 500
							bld.Lifetime = NumberRange.new(1)
							bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0,0)})
							bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
							bld.Speed = NumberRange.new(2,5)
							bld.VelocitySpread = 50000
							bld.Rotation = NumberRange.new(-500,500)
							bld.RotSpeed = NumberRange.new(-500,500)
							local sbs = Instance.new("BodyPosition", v)
							sbs.P = 3000
							sbs.D = 1000
							sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							sbs.position = v.Position + Vector3.new(math.random(-2,2),10 + math.random(-2,2),math.random(-2,2))
							v.Color = keptcolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v:BreakJoints()
									v.Transparency = v.Transparency + 0.02
								end
								v:BreakJoints()
								sphere2(1,"Add",v.CFrame,vt(0,0,0),0.1,0.1,0.1,keptcolor)
								CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.5, 0.75)
								bld.Speed = NumberRange.new(10,25)
								bld.Drag = 5
								bld.Acceleration = vt(0,2,0)
								wait(0.5)
								bld.Enabled = false
								wait(8)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end


function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Head") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end

function FaceMouse()
	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end

function FaceMouse2()
	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end

local ModeOfGlitch = 1
-- Functions are ready.
local storehumanoidWS = 16
hum.WalkSpeed = 60



local invcolor = false




function createBGCircle(size,parent,color)
	local bgui = Instance.new("BillboardGui",parent)
	bgui.Size = UDim2.new(size, 0, size, 0)
	local imgc = Instance.new("ImageLabel",bgui)
	imgc.BackgroundTransparency = 1
	imgc.ImageTransparency = 0
	imgc.Size = UDim2.new(1,0,1,0)
	imgc.Image = "rbxassetid://997291547" --997291547,521073910
	imgc.ImageColor3 = color
	return bgui,imgc
end



function symbolizeBlink(guipar,size,img,color,bonussize,vol,pit,soundid,spar,rotationenabled,rotsp,delay)
	local bgui,imgc = createBGCircle(size,guipar,color)
	bgui.AlwaysOnTop = true
	imgc.Image = "rbxassetid://" ..img
	local rrot = math.random(1,2)
	CFuncs["Sound"].Create("rbxassetid://" ..soundid, spar, vol,pit)
	coroutine.resume(coroutine.create(function()
		for i = 0, 24*delay do
			swait()
			if rotationenabled == true then
				if rrot == 1 then
					imgc.Rotation = imgc.Rotation + rotsp
				elseif rrot == 2 then
					imgc.Rotation = imgc.Rotation - rotsp
				end
			end
			bgui.Size = bgui.Size + UDim2.new(1*bonussize/delay,0,1*bonussize/delay,0)
			imgc.ImageTransparency = imgc.ImageTransparency + 0.04/delay
		end
		bgui:Destroy()
	end))
end

local bguis = Instance.new("BillboardGui",tors)
bguis.Size = UDim2.new(8, 0, 8, 0)
bguis.AlwaysOnTop = true

local imgca = Instance.new("ImageLabel",bguis)
imgca.BackgroundTransparency = 1
imgca.ImageTransparency = 0
imgca.Size = UDim2.new(1,0,1,0)
imgca.Image = "rbxassetid://3980946361"
imgca.ImageColor3 = Color3.new(1,1,1)






function PowerOrbs()
	coroutine.resume(coroutine.create(function()
		local orb = Instance.new("Part",char)
		orb.Anchored = true
		orb.CanCollide = false
		orb.Material = "Neon"
		orb.BrickColor = BrickColor.new("Institutional white")
		orb.Size = Vector3.new(3,3,3)
		local morb = Instance.new("SpecialMesh",orb)
		morb.MeshType = "Sphere"
		orb.Position = mouse.Hit.Position
		orb.CFrame = orb.CFrame*CFrame.new(0,-1,0)
		local vel = Instance.new("BodyPosition", orb)
		vel.P = 10000
		vel.D = 1000
		vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
		vel.position = orb.CFrame.p + vt(0,6,0)
		sphere2(0.5,"Add",orb.CFrame*CFrame.new(0,1,0),vt(10,0.01,10),0,0,0,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(1,"Add",orb.CFrame*CFrame.new(0,1,0),vt(10,0.01,10),0.5,0,0.5,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(1,"Add",orb.CFrame*CFrame.new(0,1,0),vt(10,0.01,10),0.7,0,0.7,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(0.5,"Add",orb.CFrame*CFrame.new(0,1,0),vt(10,0.01,10),0,0,0,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(1,"Add",orb.CFrame*CFrame.new(0,1,0),vt(10,0.01,10),0.5,0,0.5,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(1,"Add",orb.CFrame*CFrame.new(0,1,0),vt(10,0.01,10),0.7,0,0.7,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		wait(1)
		CFuncs["Sound"].Create("rbxassetid://136007472", orb, 3.5,0.7)
		CFuncs["Sound"].Create("rbxassetid://136007472", orb, 3.5,0.7)
		CFuncs["Sound"].Create("rbxassetid://136007472", orb, 3.5,0.7)
		CFuncs["Sound"].Create("rbxassetid://136007472", orb, 3.5,0.7)
		CFuncs["Sound"].Create("rbxassetid://136007472", orb, 3.5,0.7)
		CFuncs["Sound"].Create("rbxassetid://136007472", orb, 3.5,0.7)
		for i = 0, 100 do
			swait()
			local dis = CreateParta(orb,1,1,"Neon",MAINRUINCOLOR)
			dis.CFrame = orb.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-0,0)),math.rad(math.random(-360,360)),math.rad(math.random(90,90)))
			local at1 = Instance.new("Attachment",dis)
			at1.Position = vt(-25000,0,0)
			local at2 = Instance.new("Attachment",dis)
			at2.Position = vt(25000,0,0)
			local trl = Instance.new('Trail',dis)
			trl.Attachment0 = at1
			trl.FaceCamera = false
			trl.Attachment1 = at2
			trl.Texture = "rbxassetid://1049219073"
			trl.LightEmission = 100
			trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
			trl.Color = ColorSequence.new(Color3.new(1,1,1))
			trl.Lifetime = 5
			local bv = Instance.new("BodyVelocity")
			bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
			bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
			bv.Parent = dis
			game:GetService("Debris"):AddItem(dis, 5)
		end
		sphere2(1,"Add",orb.CFrame,vt(100,100,100),0,1,0,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		sphere2(3,"Add",orb.CFrame,vt(100,100,100),0.5,1,0.5,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		MagniDamage(orb, 50, 500,6000, 0.5, "Knockdown")
		sphere2(7,"Add",orb.CFrame,vt(100,100,100),0.7,1,0.7,MAINRUINCOLOR,MAINRUINCOLOR.Color)
		CFuncs["Sound"].Create("rbxassetid://419447292", orb,655.5, 1)
		CFuncs["Sound"].Create("rbxassetid://419447292", orb,655.5, 1)
		CFuncs["Sound"].Create("rbxassetid://419447292", orb,655.5, 1)
		CFuncs["Sound"].Create("rbxassetid://419447292", orb,655.5, 1)
		CFuncs["Sound"].Create("rbxassetid://419447292", orb,655.5, 1)
		CFuncs["Sound"].Create("rbxassetid://419447292", orb,655.5, 1)
		CFuncs["Sound"].Create("rbxassetid://419447292", orb,655.5, 1)
		orb.Transparency = 1
		wait(3)
		orb:remove()
	end))
end



function AzurePrison()
	attack = true
	CFuncs["Sound"].Create("rbxassetid://1208650519", char, 10, 1)
	hum.WalkSpeed = 0
	for i = 0 , 100 do
		swait()
		norot.CFrame = norot.CFrame*CFrame.Angles(0,0.05,0)
		sphereMK(math.random(1,8),math.random(1,40)/45,"Add",norot.CFrame*CFrame.new(0,-3,-20)*CFrame.Angles(math.rad(90),0,0),2,0.01,math.random(30,70),-0,MAINRUINCOLOR,0)
		sphereMK(math.random(1,8),math.random(1,40)/45,"Add",norot.CFrame*CFrame.new(0,-3,20)*CFrame.Angles(math.rad(90),0,0),2,0.01,math.random(30,70),-0,MAINRUINCOLOR,0)
		RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(-25)),.1)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(25)),.1)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,-0.05)*angles(math.rad(-25),math.rad(0),math.rad(0)),.1)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
		RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-10),math.rad(0),math.rad(90)),.1)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-10),math.rad(0),math.rad(-90)),.1)
	end
	for i, v in pairs(FindNearestHead(root.CFrame.p, 125)) do
		if v:FindFirstChild('Head') then
			CFuncs["Sound"].Create("rbxassetid://1664711478", char, 2, 1)
			CFuncs["Sound"].Create("rbxassetid://1177785010", char, 3, 1)
			CFuncs["Sound"].Create("rbxassetid://167115397", char, 3, 1)
			CFuncs["Sound"].Create("rbxassetid://782353443", char, 3, 0.9)
			CFuncs["Sound"].Create("rbxassetid://782353443", char, 4, 0.8)
			CFuncs["Sound"].Create("rbxassetid://782353443", char, 5, 0.7)
			local vel = Instance.new("BodyPosition", v.Torso)
			vel.P = 10000
			vel.D = 1000
			vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
			vel.position =  v.Torso.CFrame.p + vt(0,6,0)
			local a = script.EFF:Clone()
			a.Parent = v.HumanoidRootPart
			a.ptr.Enabled = true
			a.ptr2.Enabled = true
			a.ptr.Parent = v.HumanoidRootPart
			a.ptr2.Parent = v.HumanoidRootPart
			coroutine.resume(coroutine.create(function()
				repeat
					wait(0.1)
					v.Humanoid.MaxHealth = 100
					v.Humanoid.Health = v.Humanoid.Health - 0.5
				until v.Parent == nil
			end))
		end
	end
	attack = false	
end


















function name(Col1,Col2,name)

end


function colmo(Col1,Col2)
	imgca.ImageColor3 = Col2
	for i = 0 , 19 do
		sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,MAINRUINCOLOR2,0)
		slash(math.random(50,100)/10,5,true,"Round","Add","Out",tors.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(5,50)/250,MAINRUINCOLOR2)
	end
	sphere2(1,"Add",tors.CFrame,vt(10,10,10),0,0,0,MAINRUINCOLOR,MAINRUINCOLOR.Color)
	sphere2(3,"Add",tors.CFrame,vt(10,10,10),0.5,0.5,0.5,MAINRUINCOLOR,MAINRUINCOLOR.Color)
	CFuncs["EchoSound"].Create("rbxassetid://847061203", char, 1, 1,0,10,0.25,0.25,1)
	CFuncs["EchoSound"].Create("rbxassetid://847061203", char, 1, 1,0,10,0.25,0.25,1)
	CFuncs["EchoSound"].Create("rbxassetid://847061203", char, 1, 1,0,10,0.25,0.25,1)
	CFuncs["EchoSound"].Create("rbxassetid://847061203", char, 1, 1,0,10,0.25,0.25,1)
	CFuncs["EchoSound"].Create("rbxassetid://847061203", char, 1, 1,0,10,0.25,0.25,1)
	for i, z in pairs(win1:GetChildren()) do

		for i, v in pairs(z:GetChildren()) do
			if v:IsA("Trail") then
				v.Color = ColorSequence.new(Col1)
			end
		end
	end
	for i, z in pairs(win2:GetChildren()) do
		for i, v in pairs(z:GetChildren()) do
			if v:IsA("Trail") then
				v.Color = ColorSequence.new(Col1)
			end
		end
	end
	for i, v in pairs(win2:GetChildren()) do
		v.Color = Col1
	end
	for i, z in pairs(win1:GetChildren()) do
		for i, v in pairs(z:GetChildren()) do
			if v:IsA("ParticleEmitter") then
				v.Color = ColorSequence.new(Col2)
			end
		end
	end
	for i, z in pairs(win2:GetChildren()) do
		for i, v in pairs(z:GetChildren()) do
			if v:IsA("ParticleEmitter") then
				v.Color = ColorSequence.new(Col1)
			end
		end
	end
end
----------------------------------- Abilities
function SOL()
	attack=true
	newThemeCust("rbxassetid://0",0,1.02,4)
	for i = 0,20,0.1 do
		swait()
		sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(0),0)*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.025,20000,0.025,BrickColor.new("Neon orange"))
	end
	CFuncs["Sound"].Create("rbxassetid://294188875", tors, 3, 0.8) --294188875
	CFuncs["Sound"].Create("rbxassetid://294188875", tors, 3, 1) --294188875
	for i = 0,10,0.1 do
		swait()
		sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(0),0)*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.425,20000,0.425,BrickColor.new("Neon orange"))
	end
	local Flies = 0
	local Flies2 = 0
	local Flies3 = 0
	local Flies4 = 0
	newThemeCust("rbxassetid://318062185",0,1,1.25)
	ModeOfGlitch = 0
	local eex = Instance.new("ParticleEmitter",Torso)
	eex.Texture = "rbxassetid://2273224484"
	eex.LightEmission = 1009
	eex.Color = ColorSequence.new(BrickColor.new("Neon orange").Color)
	eex.Rate = 5
	eex.Lifetime = NumberRange.new(3,5)
	eex.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.2,2,0),NumberSequenceKeypoint.new(1,2,0)})
	eex.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
	eex.Speed = NumberRange.new(0,0)
	eex.Drag = 5
	eex.Rotation = NumberRange.new(-500,500)
	eex.VelocitySpread = 45
	eex.LockedToPart = true
	eex.RotSpeed = NumberRange.new(-100,100)
	local eex2 = Instance.new("ParticleEmitter",Torso)
	eex2.Texture = "rbxassetid://2273224484"
	eex2.LightEmission = 1009
	eex2.Color = ColorSequence.new(BrickColor.new("Neon orange").Color)
	eex2.Rate = 100
	eex2.Lifetime = NumberRange.new(3,5)
	eex2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,20,0),NumberSequenceKeypoint.new(1,1,0)})
	eex2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
	eex2.Speed = NumberRange.new(500,1000)
	eex2.Drag = 5
	eex2.Rotation = NumberRange.new(-500,500)
	eex2.VelocitySpread = 360
	eex2.RotSpeed = NumberRange.new(-100,100)
	local SFX = Instance.new("Sound",char)
	SFX.Volume = 10
	SFX.PlaybackSpeed = 0
	SFX.SoundId = "rbxassetid://1042696115"
	SFX.Looped = true
	SFX:Play()
	root.Anchored = true
	for i = 0,200,0.1 do
		swait()
		Flies = Flies - 0.05
		Flies2 = Flies2 - 0.001
		Flies4 = Flies4 - 0.0001
		Flies3 = Flies3 - 1
		SFX.PlaybackSpeed = 0-Flies2
		eex.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.2,2-Flies3,0),NumberSequenceKeypoint.new(1,2-Flies3,0)})
		sphere2(8,"Add",root.CFrame*CFrame.Angles(0,math.rad(0),0)*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.425,20000,0.425,BrickColor.new("Neon orange"))
		sphere2(8,"Add",tors.CFrame*CFrame.Angles(math.rad(0+Flies3),math.rad(0+Flies3+Flies3),math.rad(0+Flies3+Flies3+Flies3))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.015-Flies4,0.015-Flies2-Flies2-Flies2-Flies2,0.015-Flies4,BrickColor.new("Neon orange"))
		sphere2(8,"Add",tors.CFrame*CFrame.Angles(math.rad(0+Flies3),math.rad(0+Flies3+Flies3),math.rad(0+Flies3+Flies3+Flies3))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.015-Flies4,0.015-Flies2-Flies2-Flies2-Flies2,0.015-Flies4,BrickColor.new("Neon orange"))
		sphere2(8,"Add",tors.CFrame*CFrame.Angles(math.rad(0+Flies3),math.rad(0+Flies3+Flies3),math.rad(0+Flies3+Flies3))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.015-Flies4,0.015-Flies2-Flies2-Flies2-Flies2,0.015-Flies4,BrickColor.new("Neon orange"))
		sphere2(8,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.015-Flies4,0-Flies2-Flies2-Flies2-Flies2,0.015-Flies4,BrickColor.new("Neon orange"))
		sphere2(8,"Add",tors.CFrame*CFrame.Angles(math.rad(0+Flies3+Flies3),math.rad(0-Flies3),math.rad(0-Flies3-Flies3-Flies3))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.05-Flies2,0.05-Flies2,0.05-Flies2,BrickColor.new("Neon orange"))
		slash(math.random(50,50)/10,50,true,"Round","Add","Out",tors.CFrame*CFrame.new(0,-0 + 2 * math.cos(sine / 32),0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.1-Flies2,0.001,0.1-Flies2),math.random(2.4,2.4)/100,BrickColor.new("Neon orange"))
		RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 6 * math.cos(sine / 39))),.1)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 45))),.1)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.3,-0.15-Flies)*angles(math.rad(-30),math.rad(0),math.rad(0)),.5)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0 - 2.5 * math.cos(sine / 0.2))),.5)
		RW.C0=clerp(RW.C0,cf(1.45,0.4,0)*angles(math.rad(-20),math.rad(0 - 2 * math.cos(sine / 0.2)),math.rad(80 + 2 * math.cos(sine / 0.2))),.5)
		LW.C0=clerp(LW.C0,cf(-1.45,0.4,0)*angles(math.rad(-20),math.rad(0 + 2 * math.cos(sine / 0.2)),math.rad(-80 - 2 * math.cos(sine / 0.2))),.5)
	end
	eex:remove()
	eex2:remove()
	SFX:remove()
	root.Anchored = false
	MAINRUINCOLOR = BrickColor.new("Neon orange")
	for i = 0,40 do
		sphere2(0.5,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.5-Flies4,0-Flies2-Flies2-Flies2-Flies2,0.5-Flies4,BrickColor.new("Neon orange"))
		local dis = CreateParta(char,1,1,"Neon",MAINRUINCOLOR)
		dis.CFrame = tors.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
		local at1 = Instance.new("Attachment",dis)
		at1.Position = vt(-25000,0,0)
		local at2 = Instance.new("Attachment",dis)
		at2.Position = vt(25000,0,0)
		local trl = Instance.new('Trail',dis)
		trl.Attachment0 = at1
		trl.FaceCamera = true
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 100
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(Color3.new(1,0,0))
		trl.Lifetime = 5
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
		bv.Parent = dis
		game:GetService("Debris"):AddItem(dis, 5)
	end
	CFuncs["Sound"].Create("rbxassetid://1664711478", char, 10,1)
	CFuncs["LongSound"].Create("rbxassetid://763717897", char, 10, 0.5)
	CFuncs["LongSound"].Create("rbxassetid://763717897", char, 7.5, 0.25)
	CFuncs["Sound"].Create("rbxassetid://763718160", char, 10, 0.9)
	CFuncs["Sound"].Create("rbxassetid://782353443", char, 10, 0.5)
	CFuncs["Sound"].Create("rbxassetid://335657174", char, 5, 0.75)
	CFuncs["LongSound"].Create("rbxassetid://335657174", char, 10, 0.25)
	CFuncs["Sound"].Create("rbxassetid://167115397", char, 10, 1)
	CFuncs["LongSound"].Create("rbxassetid://167115397", char, 10, 0.75)
	CFuncs["LongSound"].Create("rbxassetid://167115397", char, 10, 0.5)
	ModeOfGlitch = 13
	MAINRUINCOLOR = BrickColor.new("Neon orange")
	MAINRUINCOLOR2 = BrickColor.new("Cool yellow")
	--	newThemeCust("rbxassetid://318062185",0,1,1.25)
	invcolor = true
	name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"SOL")
	hum.WalkSpeed = 50
	attack = false
end

function CERULEAN()
	attack = true
	CFuncs["Sound"].Create("rbxassetid://1295446488", root, 10, 1)
	local vel = Instance.new("BodyPosition", root)
	vel.P = 10000
	vel.D = 1000
	vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
	vel.position = root.CFrame.p + vt(0,250,0)
	--shakes(1,2)
	for i = 0, 5 do
		swait()
		--waveEff(math.random(10,100)/10,"Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(math.random(-360,360)),0),vt(15,0.25,15),math.random(25,250)/250,0.25,BrickColor.new("White"))
		slash(math.random(10,100)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.01,0.01,0.01),math.random(50,500)/250,BrickColor.new("White"))
	end
	local Flies = 0
	local Flies2 = 0
	local Flies3 = 0
	local Flies4 = 0
	local Flies5 = 0
	wait(1)
	local SFX = Instance.new("Sound",char)
	SFX.Volume = 10
	SFX.PlaybackSpeed = 0
	SFX.SoundId = "rbxassetid://1042696115"
	SFX.Looped = true
	SFX:Play()
	newThemeCust("rbxassetid://739066292",0,1,1.25)
	local eex2 = Instance.new("ParticleEmitter",Torso)
	eex2.Texture = "rbxassetid://2273224484"
	eex2.LightEmission = 1009
	eex2.Color = ColorSequence.new(BrickColor.new("Dark indigo").Color)
	eex2.Rate = 5000
	eex2.Lifetime = NumberRange.new(3,5)
	eex2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,20,0),NumberSequenceKeypoint.new(1,1,0)})
	eex2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
	eex2.Speed = NumberRange.new(500,1000)
	eex2.Drag = 5
	eex2.Rotation = NumberRange.new(-500,500)
	eex2.VelocitySpread = 360
	eex2.RotSpeed = NumberRange.new(-100,100)
	local eex42 = Instance.new("ParticleEmitter",Torso)
	eex42.Texture = "rbxassetid://3980943811"
	eex42.LightEmission = 1009
	eex42.Color = ColorSequence.new(BrickColor.new("Magenta").Color)
	eex42.Rate = 100
	eex42.Lifetime = NumberRange.new(3,5)
	eex42.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,500,0),NumberSequenceKeypoint.new(1,1000,0)})
	eex42.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(1,1,0)})
	eex42.Speed = NumberRange.new(0,0)
	eex42.Drag = 0
	eex42.Rotation = NumberRange.new(-500,500)
	eex42.VelocitySpread = 360
	eex42.RotSpeed = NumberRange.new(-100,100)
	for i = 0, 100, 0.1 do
		swait()
		Flies = Flies - 0.12
		Flies2 = Flies2 - 0.007
		Flies5 = Flies5 - 0.001
		Flies4 = Flies4 - 0.0007
		Flies3 = Flies3 - 1
		SFX.PlaybackSpeed = 0-Flies5
		slash(math.random(50,50)/10,50,true,"Round","Add","Out",tors.CFrame*CFrame.new(0,-0 + 2 * math.cos(sine / 32),0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1-Flies2,0.001,0.1-Flies2),math.random(2.4,2.4)/100,BrickColor.new("Magenta"))
		sphere2(8,"Add",tors.CFrame*CFrame.Angles(math.rad(0+Flies3),math.rad(0+Flies3+Flies3),math.rad(0+Flies3+Flies3+Flies3))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.015-Flies4,0.015-Flies4,0.015-Flies2-Flies2-Flies2-Flies2,BrickColor.new("Magenta"))
		sphere2(8,"Add",tors.CFrame*CFrame.Angles(math.rad(0+Flies3),math.rad(0+Flies3+Flies3),math.rad(0+Flies3+Flies3+Flies3))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.015-Flies4,0.015-Flies2-Flies2-Flies2-Flies2,0.015-Flies4,BrickColor.new("Magenta"))
		sphere2(8,"Add",tors.CFrame*CFrame.Angles(math.rad(0+Flies3),math.rad(0+Flies3+Flies3),math.rad(0+Flies3+Flies3+Flies3))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.015-Flies2-Flies2-Flies2-Flies2,0.015-Flies4,0.015-Flies4,BrickColor.new("Magenta"))
		sphere2(8,"Add",tors.CFrame*CFrame.Angles(math.rad(0+Flies3+Flies3),math.rad(0-Flies3),math.rad(0-Flies3-Flies3-Flies3))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.05-Flies2,0.05-Flies2,0.05-Flies2,BrickColor.new("Magenta"))
	end
	SFX:Remove()
	vel:Remove()
	eex2:Remove()
	eex42:Remove()
	for i = 0,40 do
		sphere2(0.5,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),0.5-Flies4,0-Flies2-Flies2-Flies2-Flies2,0.5-Flies4,BrickColor.new("Magenta"))
		local dis = CreateParta(char,1,1,"Neon",BrickColor.new("Magenta"))
		dis.CFrame = tors.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
		local at1 = Instance.new("Attachment",dis)
		at1.Position = vt(-25000,0,0)
		local at2 = Instance.new("Attachment",dis)
		at2.Position = vt(25000,0,0)
		local trl = Instance.new('Trail',dis)
		trl.Attachment0 = at1
		trl.FaceCamera = true
		trl.Attachment1 = at2
		trl.Texture = "rbxassetid://1049219073"
		trl.LightEmission = 100
		trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
		trl.Color = ColorSequence.new(BrickColor.new("Magenta").Color)
		trl.Lifetime = 5
		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = dis.CFrame.lookVector*math.random(500,2500)
		bv.Parent = dis
		game:GetService("Debris"):AddItem(dis, 5)
	end
	CFuncs["Sound"].Create("rbxassetid://1368605755", char, 7.5, 1)
	CFuncs["Sound"].Create("rbxassetid://763718160", char, 10, 0.5)
	CFuncs["Sound"].Create("rbxassetid://763718160", char, 10, 0.25)
	CFuncs["Sound"].Create("rbxassetid://782353443", char, 10, 1)
	CFuncs["Sound"].Create("rbxassetid://782353443", char, 10, 0.75)
	CFuncs["LongSound"].Create("rbxassetid://782353443", char, 10, 0.5)
	CFuncs["LongSound"].Create("rbxassetid://782353443", char, 10, 0.25)
	CFuncs["Sound"].Create("rbxassetid://1664711478", char, 10, 1)
	for i = 0, 2 do
		CFuncs["Sound"].Create("rbxassetid://824687369", char, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://824687369", char, 10, 0.75)
	end
	hum.WalkSpeed = 50
	ModeOfGlitch = 10
	MAINRUINCOLOR = BrickColor.new("Magenta")
	MAINRUINCOLOR2 = BrickColor.new("Dark indigo")
	--newThemeCust("rbxassetid://739066292",0,1,1.25)
	invcolor = true
	name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"CERULEAN")

	attack = false
end
-------------------------------------

Humanoid.Animator.Parent = nil

-------------------------------------
name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"MAYHEM")
local attacktype = 1 --MOVE TURNS
mouse.Button1Down:connect(function() --MOUSE
end)
mouse.KeyDown:connect(function(k) --KEY BUTTON
	if k=="q" and attack == false and ModeOfGlitch ~= 1 then
		ModeOfGlitch = 1
		hum.WalkSpeed = 16
		MAINRUINCOLOR = BrickColor.new("Really red")
		MAINRUINCOLOR2 = BrickColor.new("Really black")
		newTheme("rbxassetid://614032233",0,1,10)
		invcolor = false
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"MAYHEM")

	end
	if k=="e" and attack == false and ModeOfGlitch ~= 2 then
		ModeOfGlitch = 2
		hum.WalkSpeed = 16
		MAINRUINCOLOR = BrickColor.new("Toothpaste")
		MAINRUINCOLOR2 = BrickColor.new("Institutional white")
		newTheme("rbxassetid://1539245059",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"PURITY")

	end
	if k=="r" and attack == false and ModeOfGlitch ~= 3 then
		ModeOfGlitch = 3
		hum.WalkSpeed = 16
		MAINRUINCOLOR = BrickColor.new("Really black")
		MAINRUINCOLOR2 = BrickColor.new("Royal purple")
		newTheme("rbxassetid://1283869370",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"CORRUPTION")

	end
	if k=="t" and attack == false and ModeOfGlitch ~= 4 then
		ModeOfGlitch = 4
		hum.WalkSpeed = 16
		MAINRUINCOLOR = BrickColor.new("Black")
		MAINRUINCOLOR2 = BrickColor.new("Institutional white")
		newTheme("rbxassetid://1369263130",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR2.Color,MAINRUINCOLOR.Color,"CHAOS")
		
	end
	if k=="y" and attack == false and ModeOfGlitch ~= 5 then
		ModeOfGlitch = 5
		hum.WalkSpeed = 16
		MAINRUINCOLOR = BrickColor.new("Institutional white")
		MAINRUINCOLOR2 = BrickColor.new("Bright yellow")
		newTheme("rbxassetid://318890513",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR2.Color,MAINRUINCOLOR.Color,"DIVINITY")
		 
	end
	if k=="u" and attack == false and ModeOfGlitch ~= 6 then
		ModeOfGlitch = 6
		hum.WalkSpeed = 50
		MAINRUINCOLOR = BrickColor.new("Really black")
		MAINRUINCOLOR2 = BrickColor.new("White")
		newTheme("rbxassetid://1347011178",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"EQUALITY")
		 
	end
	if k=="f" and attack == false and ModeOfGlitch ~= 7 then
		ModeOfGlitch = 7
		hum.WalkSpeed = 100
		MAINRUINCOLOR = BrickColor.new("Institutional white")
		MAINRUINCOLOR2 = BrickColor.new("Alder")
		newTheme("rbxassetid://1495032271",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"DESTINY")
		 
	end
	if k=="j" and attack == false and ModeOfGlitch ~= 8 then
		ModeOfGlitch = 8
		hum.WalkSpeed = 50
		MAINRUINCOLOR = BrickColor.new("Maroon")
		MAINRUINCOLOR2 = BrickColor.new("Bright red")
		newTheme("rbxassetid://603566564",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"ANARCHIC")
		 
	end
	if k=="n" and attack == false and ModeOfGlitch == 1 then
		attack = true
		ModeOfGlitch =2552
		newThemeCust("rbxassetid://2890896453",0,1,10)
		hum.WalkSpeed = 0
		local Flies = 0
		local Flies2 = 0
		local Flies3 = 0
		local Flies4 = 0
		local Flies5 = 0
		for i = 0, 23, 0.01 do
			swait()
			sphere2(12,"Add",tors.CFrame*CFrame.new(0,0,0),vt(0.000001,0.000001,0.000001),000001,000001,000001,MAINRUINCOLOR)
			sphereMK(1,-2,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.3,0.3,500,-0.025,MAINRUINCOLOR,100)
			RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,60 + 1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
		end
		wait(7.5)
		CFuncs["Sound"].Create("rbxassetid://763717897", char, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://1192402877", char, 10, 0.75)
		CFuncs["Sound"].Create("rbxassetid://1664711478", char, 10, 0.95)
		sphere2(1,"Add",RootPart.CFrame*CFrame.new(0,0,0),vt(15,0,15),5,0,5,BrickColor.new("Really black"))
		sphere2(2,"Add",RootPart.CFrame*CFrame.new(0,0,0),vt(15,0,15),5,0,5,MAINRUINCOLOR2)
		sphere2(1,"Add",RootPart.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.new("New Yeller"))
		sphere2(2,"Add",RootPart.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.new("Really black"))
		sphere2(4,"Add",RootPart.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,MAINRUINCOLOR2)
		for i = 0, 49 do
			local rsiz = math.random(150,450)
			sphere2(math.random(1,4),"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(15,1,15),-0.05,math.random(25,500)/25,-0.05,BrickColor.new("Really black"))
			sphere2(math.random(1,2),"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))*CFrame.new(math.random(-350,350),math.random(-350,350),math.random(-350,350)),vt(1,1,1),-0.01,math.random(50,250)/10,-0.01,BrickColor.new("Really black"))
			sphereMK(math.random(1,2),math.random(2,4),"Add",tors.CFrame*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,BrickColor.new("New Yeller"),0)
		end
		attack = false
		hum.WalkSpeed = 16
		MAINRUINCOLOR = BrickColor.new("New Yeller")
		MAINRUINCOLOR2 = BrickColor.new("Really black")
		newThemeCust("rbxassetid://2590490779",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"OOF")
		 
	end
	if k=="m" and attack == false and ModeOfGlitch == 1 then
		attack = true
		ModeOfGlitch = 9
		newThemeCust("rbxassetid://2774573089",0,1,10)
		hum.WalkSpeed = 0
		for i = 0, 10, 0.01 do
			swait()
			norot.CFrame = norot.CFrame*CFrame.Angles(0,0.05,0)
			sphereMK(math.random(1,8),math.random(1,40)/45,"Add",norot.CFrame*CFrame.new(0,-3,-20)*CFrame.Angles(math.rad(90),0,0),2,0.01,math.random(30,70),-0,MAINRUINCOLOR,0)
			sphereMK(math.random(1,8),math.random(1,40)/45,"Add",norot.CFrame*CFrame.new(0,-3,20)*CFrame.Angles(math.rad(90),0,0),2,0.01,math.random(30,70),-0,MAINRUINCOLOR,0)
			slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,50)/250,BrickColor.new("White"))
			sphereMK(1,-2,"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,15,-0.025,MAINRUINCOLOR,100)
			RH.C0=clerp(RH.C0,cf(1,-0.05,-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-30)),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.25)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(30)),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,1.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(20 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
			RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
			LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
		end
		wait(1.5)
		CFuncs["Sound"].Create("rbxassetid://763717897", char, 10, 1)
		CFuncs["Sound"].Create("rbxassetid://1192402877", char, 10, 0.75)
		CFuncs["Sound"].Create("rbxassetid://1664711478", char, 10, 0.95)
		sphere2(1,"Add",RootPart.CFrame*CFrame.new(0,0,0),vt(15,0,15),5,0,5,BrickColor.new("Really black"))
		sphere2(2,"Add",RootPart.CFrame*CFrame.new(0,0,0),vt(15,0,15),5,0,5,MAINRUINCOLOR2)
		sphere2(1,"Add",RootPart.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.new("Maroon"))
		sphere2(2,"Add",RootPart.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,BrickColor.new("Really black"))
		sphere2(4,"Add",RootPart.CFrame*CFrame.new(0,0,0),vt(5,50000,5),1.5,1,1.5,MAINRUINCOLOR2)
		for i = 0, 49 do
			local rsiz = math.random(150,450)
			sphere2(math.random(1,4),"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(15,1,15),-0.05,math.random(25,500)/25,-0.05,BrickColor.new("Really black"))
			sphere2(math.random(1,2),"Add",tors.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))*CFrame.new(math.random(-350,350),math.random(-350,350),math.random(-350,350)),vt(1,1,1),-0.01,math.random(50,250)/10,-0.01,BrickColor.new("Really black"))
			sphereMK(math.random(1,2),math.random(2,4),"Add",tors.CFrame*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,BrickColor.new("Maroon"),0)
		end
		attack = false
		hum.WalkSpeed = 16
		MAINRUINCOLOR = BrickColor.new("Maroon")
		MAINRUINCOLOR2 = BrickColor.new("Really black")
		newTheme("rbxassetid://2774573089",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"I HAVE TO DIE")
		 
	end
	if k=="m" and attack == false and ModeOfGlitch == 2 then
		CERULEAN()
	end
	if k=="m" and attack == false and ModeOfGlitch == 3 then
		attack = true
		ModeOfGlitch = 146536
		hum.WalkSpeed = 0
		newThemeCust("rbxassetid://190845741",9,1,1.25)
		wait(2)
		for i = 0, 15, 0.1 do
			swait()
			RH.C0=clerp(RH.C0,cf(1, -1 - 0.025 * math.cos(sine/12), -0.01)*angles(math.rad(0),math.rad(83),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
			LH.C0=clerp(LH.C0,cf(-1, -1 - 0.05 * math.cos(sine/12), -0.01)*angles(math.rad(0),math.rad(-83),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0, 0, 0 + 0.05 * math.cos(sine / 12))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0, 0, 0 + ((1) - 1))*angles(math.rad(15 - 2.5 * math.sin(sine / 12)),math.rad(0),math.rad(0)),0.1)
			RW.C0=clerp(RW.C0,cf(1,0.35 + 0.125 * math.cos(sine / 12),-0.45)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
			LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.125 * math.cos(sine / 12),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
		end
		sphere(2,"Add",root.CFrame,vt(0,0,0),12.5,MAINRUINCOLOR)
		sphere(3,"Add",root.CFrame,vt(0,0,0),10,MAINRUINCOLOR)
		sphere(1,"Add",root.CFrame,vt(0,0,0),7.5,MAINRUINCOLOR)
		sphere(2,"Add",root.CFrame,vt(0,0,0),5,MAINRUINCOLOR)
		sphere(3,"Add",root.CFrame,vt(0,0,0),2.5,MAINRUINCOLOR)
		CFuncs["Sound"].Create("rbxassetid://847061203", char, 2,1)
		storehumanoidWS = 12
		hum.WalkSpeed = 12
		MAINRUINCOLOR = BrickColor.new("Dark indigo")
		MAINRUINCOLOR2 = BrickColor.new("Bright violet")
		newTheme("rbxassetid://190845741",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"VANTA-X")
		 
		attack = false
	end
	if k=="m" and attack == false and ModeOfGlitch == 4 then
		ModeOfGlitch = 12
		hum.WalkSpeed = 50
		MAINRUINCOLOR = BrickColor.new("Medium blue")
		MAINRUINCOLOR2 = BrickColor.new("Pastel Blue")
		newTheme("rbxassetid://2912028865",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"CELESTIAL")
		 
	end
	if k=="m" and attack == false and ModeOfGlitch == 5 then
		SOL()
	end
	if k=="m" and attack == false and ModeOfGlitch == 6 then
		ModeOfGlitch = 14
		MAINRUINCOLOR = BrickColor.new("Cool yellow")
		hum.WalkSpeed = 50
		MAINRUINCOLOR2 = BrickColor.new("Toothpaste")
		newThemeCust("rbxassetid://2904137450",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"LUCIDITY")
		 
	end
	if k=="m" and attack == false and ModeOfGlitch == 7 then
		ModeOfGlitch = 15
		hum.WalkSpeed = 500
		MAINRUINCOLOR = BrickColor.new("Hot pink")
		MAINRUINCOLOR2 = BrickColor.new("Toothpaste")
		newTheme("rbxassetid://2170417538",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"LIGHTSPEED")
		 
	end
	if k=="m" and attack == false and ModeOfGlitch == 8 then
		ModeOfGlitch = 16
		MAINRUINCOLOR = BrickColor.new("Maroon")
		hum.WalkSpeed = 50
		MAINRUINCOLOR2 = BrickColor.new("Really black")
		newTheme("rbxassetid://1043583667",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"ANNIHILATION")
		 
	end
	if k=="n" and attack == false and ModeOfGlitch == 1 then
		ModeOfGlitch = 17
		MAINRUINCOLOR = BrickColor.new("CGA brown")
		hum.WalkSpeed = 50
		MAINRUINCOLOR2 = BrickColor.new("White")
		newTheme("rbxassetid://3261146521",0,1,10)
		invcolor = true
		name(MAINRUINCOLOR.Color,MAINRUINCOLOR2.Color,"FIRMAMENT")
		 
	end





	------------------ATTACCCCC
	if k=="z" and attack == false and ModeOfGlitch == 1 then
		PowerOrbs()
	end
	if k=="z" and attack == false and ModeOfGlitch == 2 then
		AzurePrison()
	end

end)

Humanoid.Name = "BRU"
Humanoid.MaxHealth = 300
Humanoid.Health = 300
Instance.new("ForceField",char).Visible = false
wait()
alecol={
	BrickColor.new("Cool yellow"),
	BrickColor.new("Medium blue"),
	BrickColor.new("Alder"),
	BrickColor.new("Salmon"),
	BrickColor.new("Bright green"),
}
local aaee = alecol[math.random(1,#alecol)]

idleanim=.4
while true do
	norot.Position = root.Position
	if ModeOfGlitch == 13 then
		sphere2(8,"Add",root.CFrame*CFrame.new(0,300 - 50 * math.cos(sine / 30),0)*CFrame.Angles(math.rad(0+0),math.rad(0-0),math.rad(0-0-0-0))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),5.05-0,5.05-0,5.05-0,BrickColor.new("Neon orange"))
		sphereMK(5,math.random(1,6)/10,"Add",root.CFrame*CFrame.new(math.random(-500,500),-0,math.random(-500,500))*CFrame.Angles(math.rad(90 + math.random(-40,40)),math.rad(math.random(-40,40)),math.rad(math.random(-40,40))),20.75+ 20 * math.cos(sine / 30),20.75+ 20 * math.cos(sine / 30),200+ 20 * math.cos(sine / 30),-0.0075,MAINRUINCOLOR,0)
		slash(math.random(50,50)/10,50,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-2 + 0 * math.cos(sine / 32),0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(5- 2.5 * math.cos(sine / 30),0.001,5- 2.5 * math.cos(sine / 30)),math.random(2.4,2.4)/100,BrickColor.new("Neon orange"))
		slash(math.random(50,50)/10,50,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-2 + 0 * math.cos(sine / 32),0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(3- 2.5 * math.cos(sine / 30),0.001,3- 1.5 * math.cos(sine / 30)),math.random(2.4,2.4)/100,BrickColor.new("Neon orange"))
	end
	if ModeOfGlitch == 9 then
		slash(math.random(80,80)/10,5,true,"Round","Add","Out",norot.CFrame*CFrame.new(0,-2.95,-0)*CFrame.Angles(math.rad(math.random(-0,0)),math.rad(math.random(-360,360)),math.rad(math.random(-0,0))),vt(0.05,0.001,0.05),0,MAINRUINCOLOR)
		sphere2(5,"Add",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/50),6),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR2)
		sphere2(5,"Add",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/50),-6),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR)
		slash(math.random(80,80)/10,5,true,"Round","Add","Out",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/50),-6)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.001,0.01),0,MAINRUINCOLOR)
		slash(math.random(80,80)/10,5,true,"Round","Add","Out",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/50),6)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.001,0.01),0,MAINRUINCOLOR2)
		norot.CFrame = norot.CFrame*CFrame.Angles(0,0.05,0)
	end
	if ModeOfGlitch == 4 then
		norot.CFrame = norot.CFrame*CFrame.Angles(0,0.05,0)
		slash(math.random(80,80)/10,5,true,"Round","Add","Out",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/12),-6)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.001,0.01),0,MAINRUINCOLOR)
		slash(math.random(80,80)/10,5,true,"Round","Add","Out",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/12),6)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.001,0.01),0,MAINRUINCOLOR2)
		sphere2(5,"Add",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/12),6),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR)
		sphere2(5,"Add",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/12),-6),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR2)
	end
	if ModeOfGlitch == 6 then
		slash(math.random(80,80)/10,5,true,"Round","Add","Out",norot.CFrame*CFrame.new(0,0+2*math.cos(sine/30),-0)*CFrame.Angles(math.rad(math.random(-0,0)),math.rad(math.random(-360,360)),math.rad(math.random(-0,0))),vt(0.05,0.001,0.05),0,MAINRUINCOLOR)
		sphere2(5,"Add",norot.CFrame*CFrame.new(0,0+2*math.cos(sine/30),6),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR)
		sphere2(5,"Add",norot.CFrame*CFrame.new(0,0+2*math.cos(sine/30),-6),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR2)
		norot.CFrame = norot.CFrame*CFrame.Angles(0,0.05,0)
	end
	if ModeOfGlitch == 5 then
		sphereMK(7.5,math.random(1,20)/45,"Add",root.CFrame*CFrame.new(math.random(-10,10),-3,math.random(-10,10))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),2,2,4,-0.025,MAINRUINCOLOR2,0)
		sphereMK(7.5,math.random(1,20)/45,"Add",root.CFrame*CFrame.new(math.random(-10,10),-3,math.random(-10,10))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),2,2,4,-0.025,MAINRUINCOLOR,0)
	end
	if ModeOfGlitch == 7 then
		slash(math.random(80,80)/10,5,true,"Round","Add","Out",norot.CFrame*CFrame.new(0,-2.95,-0)*CFrame.Angles(math.rad(math.random(-0,0)),math.rad(math.random(-360,360)),math.rad(math.random(-0,0))),vt(0.05,0.001,0.05),0,MAINRUINCOLOR)
		sphere2(5,"Add",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/50),6),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR2)
		sphere2(5,"Add",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/50),-6),vt(1,1,1),-0.01,-0.01,-0.01,MAINRUINCOLOR)
		slash(math.random(80,80)/10,5,true,"Round","Add","Out",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/50),-6)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.001,0.01),0,MAINRUINCOLOR)
		slash(math.random(80,80)/10,5,true,"Round","Add","Out",norot.CFrame*CFrame.new(0,0+3*math.cos(sine/50),6)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.001,0.01),0,MAINRUINCOLOR2)
		norot.CFrame = norot.CFrame*CFrame.Angles(0,0.05,0)
	end
	if ModeOfGlitch == 15 then
		slash(math.random(91,96)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,69)/250,BrickColor.new("White"))

		sphereMK(math.random(4,12),math.random(1,40)/45,"Add",norot.CFrame*CFrame.new(0,-3,10)*CFrame.Angles(math.rad(90+70),0,0),1,1,math.random(3,7),-0,MAINRUINCOLOR,0)
		sphereMK(math.random(4,12),math.random(1,20)/45,"Add",norot.CFrame*CFrame.new(0,-3,-10)*CFrame.Angles(math.rad(90-70),0,0),1,1,math.random(2,5),-0,MAINRUINCOLOR,0)
		norot.CFrame = norot.CFrame*CFrame.Angles(0,60,0)
	end
	if ModeOfGlitch == 16 then

		sphereMK(math.random(1,8),math.random(1,40)/45,"Add",norot.CFrame*CFrame.new(0,-3,10)*CFrame.Angles(math.rad(90),0,0),2,2,math.random(3,7),-0,MAINRUINCOLOR,0)
		slash(math.random(91,96)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,69)/250,BrickColor.new("White"))
		sphereMK(math.random(1,8),math.random(1,40)/45,"Add",norot.CFrame*CFrame.new(0,-3,-10)*CFrame.Angles(math.rad(90),0,0),2,2,math.random(3,7),-0,MAINRUINCOLOR2,0)
		norot.CFrame = norot.CFrame*CFrame.Angles(0,0.1,0)
	end
	if ModeOfGlitch == 8 then
		sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,math.random(5,20),-0.0075,MAINRUINCOLOR2,0)
		slash(math.random(91,96)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,69)/250,BrickColor.new("White"))
	end
	if ModeOfGlitch == 10 then
		norot.CFrame = norot.CFrame*CFrame.Angles(0,90+0.05,0)
		sphere2(8,"Add",root.CFrame*CFrame.new(0,300 - 0 * math.cos(sine / 30),0)*CFrame.Angles(math.rad(0+0),math.rad(0-0),math.rad(0-0-0-0))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,1,0),5.05-0,0-0,5.05-0,MAINRUINCOLOR)
		sphereMK(7.5,math.random(250,250)/45,"Add",norot.CFrame*CFrame.new(0,300,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),100,0.01,200,-0,MAINRUINCOLOR,0)
		--sphereMK(7.5,math.random(250,250)/45,"Add",norot.CFrame*CFrame.new(0,300,0)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),100,0.01,200,-0,MAINRUINCOLOR,0)
		sphereMK(7.5,math.random(250,250)/45,"Add",norot.CFrame*CFrame.new(0,300,0)*CFrame.Angles(math.rad(0),math.rad(180),math.rad(0)),100,0.01,200,-0,MAINRUINCOLOR,0)
		--sphereMK(7.5,math.random(250,250)/45,"Add",norot.CFrame*CFrame.new(0,300,0)*CFrame.Angles(math.rad(0),math.rad(270),math.rad(0)),100,0.01,200,-0,MAINRUINCOLOR,0)
		sphereMK(7.5,math.random(15,300)/45,"Add",root.CFrame*CFrame.new(math.random(-300,300),300,math.random(-300,300))*CFrame.Angles(math.rad(270 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),6,6,math.random(10,70),-0.0075,MAINRUINCOLOR,0)
		sphereMK(7.5,math.random(15,300)/45,"Add",root.CFrame*CFrame.new(math.random(-300,300),300,math.random(-300,300))*CFrame.Angles(math.rad(270 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),6,6,6,-0.0075,MAINRUINCOLOR,0)
	end
	if ModeOfGlitch == 12 then
		norot.CFrame = norot.CFrame*CFrame.Angles(0,90+0.05,0)
		sphere2(8,"Add",root.CFrame*CFrame.new(0,300 - 0 * math.cos(sine / 30),0)*CFrame.Angles(math.rad(0+0),math.rad(0-0),math.rad(0-0-0-0))*CFrame.new(0,-0,0)*CFrame.Angles(math.rad(0),0,0),vt(0,0,0),5.05-0,5.05-0,5.05-0,MAINRUINCOLOR)
		slash(math.random(50,50)/10,50,true,"Round","Add","Out",root.CFrame*CFrame.new(0,300 + 0 * math.cos(sine / 32),0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(3,0.001,3),math.random(2.4,2.4)/100,MAINRUINCOLOR)
		sphereMK(7.5,math.random(15,300)/45,"Add",root.CFrame*CFrame.new(math.random(-300,300),300,math.random(-300,300))*CFrame.Angles(math.rad(270 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),6,6,math.random(10,70),-0.0075,MAINRUINCOLOR,0)
		sphereMK(7.5,math.random(15,300)/45,"Add",root.CFrame*CFrame.new(math.random(-300,300),300,math.random(-300,300))*CFrame.Angles(math.rad(270 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),6,6,6,-0.0075,MAINRUINCOLOR,0)
	end
	if ModeOfGlitch == 14 then
		norot.CFrame = norot.CFrame*CFrame.Angles(0,0.05,0)
		sphere2(18,"Add",norot.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(0),math.rad(90+sine),math.rad(0)),vt(10,0.01,200),-0,0,-1,MAINRUINCOLOR)
		sphere2(18,"Add",norot.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(0),math.rad(0+sine),math.rad(0)),vt(10,0.01,200),-0,0,-1,MAINRUINCOLOR)
		sphereMK(7.5,math.random(250,250)/45,"Add",norot.CFrame*CFrame.new(0,-3,200)*CFrame.Angles(math.rad(0),math.rad(180),math.rad(0)),100,0.01,200,-0,MAINRUINCOLOR2,0)
		sphereMK(7.5,math.random(250,250)/45,"Add",norot.CFrame*CFrame.new(0,-3,-200)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),100,0.01,200,-0,MAINRUINCOLOR2,0)
	end
	if ModeOfGlitch == 17 then
		sphereMK(math.random(1,8),math.random(1,40)/45,"Add",norot.CFrame*CFrame.new(0,-3,10+math.random(-10,10))*CFrame.Angles(math.rad(90+math.random(-10,10)),math.rad(0+math.random(-10,10)),math.rad(0+math.random(-10,10))),2,2,math.random(3,7),-0,MAINRUINCOLOR,0)
		slash(math.random(91,96)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(5,69)/250,BrickColor.new("White"))
		sphereMK(math.random(1,8),math.random(1,40)/45,"Add",norot.CFrame*CFrame.new(0,-3,-10+math.random(-10,10))*CFrame.Angles(math.rad(90 +math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),2,2,math.random(3,7),-0,MAINRUINCOLOR2,0)
		norot.CFrame = norot.CFrame*CFrame.Angles(0,0.1,0)
	end
	if ModeOfGlitch ~= 1 and ModeOfGlitch ~= 2 and ModeOfGlitch ~= 3 and ModeOfGlitch ~= 4 and ModeOfGlitch ~= 5 and ModeOfGlitch ~= 6 and ModeOfGlitch ~= 7 and ModeOfGlitch ~= 9 and ModeOfGlitch ~= 10 and ModeOfGlitch ~= 11 and ModeOfGlitch ~= 15 and ModeOfGlitch ~= 16 and ModeOfGlitch ~= 17 then
		sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,math.random(5,20),-0.0075,MAINRUINCOLOR2,0)
	elseif  ModeOfGlitch == 1 then
		sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,math.random(5,20),-0.0075,MAINRUINCOLOR2,0)
		sphereMK(7.5,math.random(1,25)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),math.random(-0,25),math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.7,0.7,0.7,-0,MAINRUINCOLOR2,0)
	elseif ModeOfGlitch == 2 then
		sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),30,math.random(-25,25))*CFrame.Angles(math.rad(270 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,math.random(5,20),-0.0075,MAINRUINCOLOR,0)
	elseif ModeOfGlitch == 3 then
		sphere2(5,"Add",root.CFrame*CFrame.new(math.random(-25,25),math.random(-25,25),math.random(-25,25)),vt(0.1,0,0.1),0,0.1,0,MAINRUINCOLOR)


	end

	if mutedtog == false then
		kan.Volume = currentVol
	elseif mutedtog == true then
		kan.Volume = 0
	end
	--kan.PlaybackSpeed = currentPitch
	--kan.Pitch = currentPitch
	--kan.SoundId = currentThemePlaying
	--kan.Looped = true
	--kan.Parent = char
	imgca.Rotation = imgca.Rotation - 5
	--kan:Resume()
	CameraManager()
	swait()
	sine = sine + change
	walksine = walksine + walkc
	sine2 = sine2 + c2
	local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
	local velderp=RootPart.Velocity.y
	hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
	if equipped==true or equipped==false then
		if attack==false then
			idle=idle+1
		else
			idle=0
		end
		if idle>=500 then
			if attack==false then
				--Sheath()
			end
		end
		--RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		--LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		--RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		--Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		--RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		--LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		if RootPart.Velocity.y > 1 and hitfloor==nil then 
			Anim="Jump"
			if attack==false then
				RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
				RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
				LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
			end
		elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
			Anim="Fall"
			if attack==false then
				RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(10),math.rad(0),math.rad(0)),.1)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5),math.rad(0),math.rad(0)),.1)
				RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(55)),.1)
				LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-55)),.1)
			end
		elseif torvel<1 and hitfloor~=nil then
			Anim="Idle"
			if attack==false then
				if ModeOfGlitch == 1 then
					block(10,"Add",rarm.CFrame*CFrame.new(0,-6,0),vt(4,4,4),0.05,0.05,0.05,MAINRUINCOLOR,MAINRUINCOLOR.Color)
					slash(math.random(25,50)/10,5,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-6,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.01,0.1),-0.1,BrickColor.new("Really black"))
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(70),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-85),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 30))*angles(math.rad(0),math.rad(0),math.rad(20)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0),math.rad(0),math.rad(-20)),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-165 - 1 * math.cos(sine / 30)),math.rad(19- 20 * math.cos(sine / 50)),math.rad(50+ 10 * math.cos(sine / 30))),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(0- 10 * math.cos(sine / 30)),math.rad(0),math.rad(-9- 10 * math.cos(sine / 30))),.1)
				end
				if ModeOfGlitch == 2 then
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-6),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-0.5),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 + 3 * math.cos(sine / 42))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 58)),math.rad(0 + 1 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
				end
				if ModeOfGlitch == 3 then
					local snap = math.random(1,32)
					if snap == 1 then
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1)
					end
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-33 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(-33 + 3 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
				end
				if ModeOfGlitch == 4 then
					local snap = math.random(1,5)
					if snap == 1 then
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),0.6)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 + 5 * math.cos(sine / 74) + math.random(-1,1)),math.rad(1 - 3 * math.cos(sine / 53) + math.random(-1,1)),math.rad(1 + 3 * math.cos(sine / 45) + math.random(-1,1))),.6)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 - 3 * math.cos(sine / 73) + math.random(-1,1)),math.rad(2 - 1 * math.cos(sine / 55) + math.random(-1,1)),math.rad(-3 - 3 * math.cos(sine / 45) + math.random(-1,1))),.6)
					end
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(25 - 2 * math.cos(sine / 32))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-25 + 2 * math.cos(sine / 32))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25 + 0.02 * math.cos(sine / 32),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(25 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(25 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(1 + 3 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(25 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-3 - 3 * math.cos(sine / 45))),.1)
				end
				if ModeOfGlitch == 5 then
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28) - 0.04 * math.cos(sine / 50),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1 + 4 * math.cos(sine / 50)),math.rad(0),math.rad(0 - 2 * math.cos(sine / 34))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28) + 0.04 * math.cos(sine / 50),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5 - 4 * math.cos(sine / 50)),math.rad(18),math.rad(0 + 2 * math.cos(sine / 34))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.04 * math.cos(sine / 50),0 + 0.03 * math.cos(sine / 34),0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0 + 4 * math.cos(sine / 50)),math.rad(-18)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 1 * math.cos(sine / 28)),math.rad(-5 - 2.5 * math.cos(sine / 57)),math.rad(18)),.1)
					RW.C0=clerp(RW.C0,cf(0.85,0.5 + 0.05 * math.cos(sine / 28),-0.65)*angles(math.rad(36 - 3 * math.cos(sine / 34)),math.rad(0 - 2 * math.cos(sine / 45)),math.rad(-80 + 2 * math.cos(sine / 28))),.1)
					LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.05 * math.cos(sine / 28),-0.65)*angles(math.rad(46 + 3 * math.cos(sine / 49)),math.rad(10 + 2 * math.cos(sine / 52)),math.rad(80 - 3 * math.cos(sine / 39))),.1)
				end
				if ModeOfGlitch == 6 then
					RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 7 * math.cos(sine / 56))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 3 * math.cos(sine / 52))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(2 + 5 * math.cos(sine / 74)),math.rad(1 - 3 * math.cos(sine / 53)),math.rad(14 + 5 * math.cos(sine / 32))),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(-14 - 6 * math.cos(sine / 33))),.1)
				end
				if ModeOfGlitch == 7 then
					RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-20)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(20 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
				end
				if ModeOfGlitch == 8 then
					RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),1 + 0.15 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-20)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(20 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
				end
				if ModeOfGlitch == 9 then
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(70),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-85),math.rad(0))*angles(math.rad(-3),math.rad(0),math.rad(0)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 30))*angles(math.rad(0),math.rad(0),math.rad(20)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(55),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(sine / 28))),.1)
					LW.C0=clerp(LW.C0,cf(-0.75,0.5,-0.25)*angles(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(sine / 28))),.1)
				end
				if ModeOfGlitch == 10 then
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20+ 10 * math.cos(sine / 30))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20+ 10 * math.cos(sine / 30))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,2-1 * math.cos(sine / 30))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0+5 * math.cos(sine / 30)),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-10+5 * math.cos(sine / 30)),math.rad(0),math.rad(0)),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-10+5 * math.cos(sine / 30)),math.rad(0),math.rad(0)),.1)
				end
				if ModeOfGlitch == 146536 then
					RH.C0=clerp(RH.C0,cf(1, -1 - 0.025 * math.cos(sine/12), -0.01)*angles(math.rad(0),math.rad(83),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
					LH.C0=clerp(LH.C0,cf(-1, -1 - 0.05 * math.cos(sine/12), -0.01)*angles(math.rad(0),math.rad(-83),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0, 0, 0 + 0.05 * math.cos(sine / 12))*angles(math.rad(0),math.rad(0),math.rad(0)),0.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0, 0, 0 + ((1) - 1))*angles(math.rad(15 - 2.5 * math.sin(sine / 12)),math.rad(0),math.rad(0)),0.1)
					RW.C0=clerp(RW.C0,cf(1,0.35 + 0.125 * math.cos(sine / 12),-0.45)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.125 * math.cos(sine / 12),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
				end
				if ModeOfGlitch == 12 then
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20+ 10 * math.cos(sine / 30))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20+ 10 * math.cos(sine / 30))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,2-1 * math.cos(sine / 30))*angles(math.rad(30),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30+5 * math.cos(sine / 30)),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-70+5 * math.cos(sine / 30)),math.rad(0),math.rad(0)),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-70+5 * math.cos(sine / 30)),math.rad(0),math.rad(0)),.1)
				end
				if ModeOfGlitch == 13 then
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20+ 10 * math.cos(sine / 30))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20+ 10 * math.cos(sine / 30))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,2-1 * math.cos(sine / 30))*angles(math.rad(0),math.rad(0),math.rad(-60)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20+5 * math.cos(sine / 30)),math.rad(0),math.rad(60)),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0)*angles(math.rad(-20+5 * math.cos(sine / 30)),math.rad(0),math.rad(0)),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0)*angles(math.rad(-160+5 * math.cos(sine / 30)),math.rad(0),math.rad(0)),.1)
				end
				if ModeOfGlitch == 14 then
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-0+ 10 * math.cos(sine / 30))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20+ 10 * math.cos(sine / 30))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,2-1 * math.cos(sine / 30))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0+5 * math.cos(sine / 30)),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(0.5,0.5,-0.5)*angles(math.rad(0),math.rad(-5),math.rad(-110)),.1)
					LW.C0=clerp(LW.C0,cf(-0.5,0.5,-0.5)*angles(math.rad(0),math.rad(-5),math.rad(80)),.1)
				end
				if ModeOfGlitch == 15 then
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-20),math.rad(-10),math.rad(-10)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-10),math.rad(-10),math.rad(-20)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0-2.5 * math.cos(sine / 30)),math.rad(0),math.rad(-0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0+10 * math.cos(sine / 15)),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(1,0.5,-0.5)*angles(math.rad(0),math.rad(-5),math.rad(-110)),.1)
					LW.C0=clerp(LW.C0,cf(-1,0.5,-0.5)*angles(math.rad(0),math.rad(-5),math.rad(80)),.1)
					sphereMK(math.random(1,8),math.random(1,40)/45,"Add",norot.CFrame*CFrame.new(0,-3,5)*CFrame.Angles(math.rad(90+45),0,0),1,1,math.random(2,5),-0,MAINRUINCOLOR2,0)
					sphereMK(math.random(1,8),math.random(1,20)/45,"Add",norot.CFrame*CFrame.new(0,-3,-5)*CFrame.Angles(math.rad(90-45),0,0),1,1,math.random(2,5),-0,MAINRUINCOLOR2,0)
				end
				if ModeOfGlitch == 16 then
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-0+ 10 * math.cos(sine / 30))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20+ 10 * math.cos(sine / 30))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,2-1 * math.cos(sine / 30))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0+5 * math.cos(sine / 30)),math.rad(0),math.rad(0)),.1)
					RW.C0=clerp(RW.C0,cf(0.5,0.5,-0.5)*angles(math.rad(0),math.rad(-0),math.rad(-110)),.1)
					LW.C0=clerp(LW.C0,cf(-1,0.5,-0)*angles(math.rad(200),math.rad(-0),math.rad(0)),.1)
				end
				if ModeOfGlitch == 2552 then
					local snap = math.random(1,10)
					if snap == 1 then
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1)
					end
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28) - 0.03 * math.cos(sine / 45),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-7.5 + 3 * math.cos(sine / 45)),math.rad(0),math.rad(0 - 2 * math.cos(sine / 34))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28) + 0.03 * math.cos(sine / 45),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5 - 3 * math.cos(sine / 45)),math.rad(5),math.rad(0 + 2 * math.cos(sine / 34))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 0.03 * math.cos(sine / 45),0 + 0.02 * math.cos(sine / 34),0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 2 * math.cos(sine / 34)),math.rad(0 + 3 * math.cos(sine / 45)),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20 - 2.5 * math.cos(sine / 28)),math.rad(0 + 5 * math.cos(sine / 99)),math.rad(0 + 10 * math.cos(sine / 78))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.01 * math.cos(sine / 28),0)*angles(math.rad(15 + 5 * math.cos(sine / 33)),math.rad(15 + 6 * math.cos(sine / 38)),math.rad(-10 - 3 * math.cos(sine / 42))),.1)
					LW.C0=clerp(LW.C0,cf(-0.85,0.5 + 0.05 * math.cos(sine / 28),-0.65)*angles(math.rad(40 - 3 * math.cos(sine / 34)),math.rad(0),math.rad(90 + 5 * math.cos(sine / 28))),.1)
				end
				if ModeOfGlitch == 17 then
					RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-0+ 10 * math.cos(sine / 30))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.5,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-20+ 10 * math.cos(sine / 30))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,2-1 * math.cos(sine / 30))*angles(math.rad(0),math.rad(0),math.rad(40)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0+5 * math.cos(sine / 30)),math.rad(0),math.rad(-40)),.1)
					RW.C0=clerp(RW.C0,cf(1,0.5,0)*angles(math.rad(0),math.rad(40),math.rad(80)),.1)
					LW.C0=clerp(LW.C0,cf(-1,0.5,-0)*angles(math.rad(200),math.rad(-0),math.rad(0)),.1)
				end
			end
		elseif torvel>2 and torvel<22 and hitfloor~=nil then
			Anim="Walk"
			if attack==false then
				RH.C0=clerp(RH.C0,cf(1,-0.75 + 0.6 * math.cos(walksine / 8),0- 0.6 * math.cos(walksine / 8))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(-10 + 35 * math.cos(sine / 8))),.1)
				LH.C0=clerp(LH.C0,cf(-1,-0.75 - 0.6 * math.cos(walksine / 8), 0+ 0.6 * math.cos(walksine / 8))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(10 + 35 * math.cos(sine / 8))),.1)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 - 0.1 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 8))),.1)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 10 * math.cos(sine / 8))),.1)
				RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(walksine / 8))*angles(math.rad(0 - 50 * math.cos(walksine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(walksine / 4))),.1)
				LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(walksine / 8))*angles(math.rad(0 + 50 * math.cos(walksine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(walksine / 4))),.1)
			end
		elseif torvel>=22 and hitfloor~=nil then
			Anim="Run"
			if attack==false then
				if ModeOfGlitch ~= 6 and ModeOfGlitch ~= 8 and ModeOfGlitch ~= 9 and ModeOfGlitch ~= 10 and ModeOfGlitch ~= 11 and ModeOfGlitch ~= 12 and ModeOfGlitch ~= 13 and ModeOfGlitch ~= 14 and ModeOfGlitch ~= 16  and ModeOfGlitch ~= 17 then
					RH.C0=clerp(RH.C0,cf(1,-0.75 + 0.6 * math.cos(walksine / 6),0- 0.6 * math.cos(walksine / 6))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 6)),math.rad(-10 + 55 * math.cos(sine / 6))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.75 - 0.6 * math.cos(walksine / 6), 0+ 0.6 * math.cos(walksine / 6))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 6)),math.rad(10 + 55 * math.cos(sine / 6))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 - 0.05 * math.cos(sine / 3))*angles(math.rad(30 + 0 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 10 * math.cos(sine / 6))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-20 - 3 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 10 * math.cos(sine / 6))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(walksine / 6))*angles(math.rad(0 - 0 * math.cos(walksine / 6)),math.rad(30 - 160 * math.cos(walksine / 6)),math.rad(80 - 0 * math.cos(walksine / 3))),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(walksine / 6))*angles(math.rad(0 + 0 * math.cos(walksine / 6)),math.rad(-30 - 160 * math.cos(walksine / 6)),math.rad(-80 + 0 * math.cos(walksine / 3))),.1)
				elseif ModeOfGlitch == 6 or ModeOfGlitch == 8 or ModeOfGlitch == 9 or ModeOfGlitch == 10 or ModeOfGlitch == 11 or ModeOfGlitch == 12 or ModeOfGlitch == 13 or ModeOfGlitch == 14 or ModeOfGlitch == 16 or ModeOfGlitch == 17 then
					RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
				end
				if ModeOfGlitch == 7 or ModeOfGlitch == 15 then
					sphereMK(2,-0.5,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),8)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.5,0.5,20,-0.0075,MAINRUINCOLOR,0)	
				end
			end
		end
	end
end
