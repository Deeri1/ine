print("loading")
local net = true

if net == true then
	game:GetService("Players").LocalPlayer.Character["swordhalo"].Name = "gamer1"

	local player = game:GetService("Players").LocalPlayer.Character
local aligns = {}
local hataligns = {}
function fgvbhnjmi(number)
    sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", number)
end
game:GetService("RunService").Heartbeat:Connect(function()
ve = Vector3.new(30,0,0)
  player["Head"].Velocity = ve
  player["Torso"].Velocity = ve
  player["Left Arm"].Velocity = ve
  player["Right Arm"].Velocity = ve
  player["Left Leg"].Velocity = ve
  player["Right Leg"].Velocity = ve
  player.HumanoidRootPart.Velocity = ve
for i,v in pairs(player:GetDescendants()) do
    if v:IsA("Accessory") then
        v.Handle.Velocity = Vector3.new(26,0,0)
    end
end
end)
wait(0.1)
		settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
		settings().Physics.AllowSleep = false
game.Players.LocalPlayer.ReplicationFocus = player
local Player = game.Players.LocalPlayer
local Character = Player.Character
local RespawnTime = 10
--Character["Local Ragdoll"]:Destroy()
Character.Archivable = true
local CloneChar = Character:Clone()
CloneChar.Name = "ReanimChar"
CloneChar.Parent = Character
Workspace.CurrentCamera.CameraSubject = CloneChar
for _,v in pairs(Character:GetDescendants()) do
    if v:IsA("BasePart") then
        Instance.new("Attachment", v)
    end
end
for _,v in pairs(Character:GetDescendants()) do
    if v:IsA("Accessory") then
        Instance.new("Attachment", v.Handle)
        Instance.new("AlignPosition",v)
        Instance.new("AlignOrientation",v)
    end
end
for i,v in pairs(Character:GetDescendants()) do
    if v:IsA("BasePart") and v.Parent == Character then
        Instance.new("AlignPosition", v)
        Instance.new("AlignOrientation", v)
        Instance.new("BodyVelocity", v)
        --Instance.new("BodyPosition", v)
        Instance.new("BodyForce", v)
        Instance.new("BodyAngularVelocity", v)
    end
    if v:IsA("BallSocketConstraint") or v:IsA("HingeConstraint") then
        v:Destroy()
    end
end
game:GetService("RunService").Stepped:connect(function()
fgvbhnjmi(math.huge)
for i,v in pairs(Character:GetDescendants()) do
    if v:IsA("BasePart") then
        v.CanCollide = false
    end
   --[[ if v:IsA("Accessory") then
        v.Handle.Velocity = Vector3.new(0,2,0)
    end
    if v:IsA("BasePart") and v.Parent == Character and v.Name ~= "Left Arm" and v.Name ~= "Right Arm" then
        v.Transparency = CloneChar.Head.LocalTransparencyModifier
    end
    if v:IsA("Accessory") then
        v.Handle.Transparency = CloneChar.Head.LocalTransparencyModifier
    end
    if v:IsA("Part") and v.Parent == CloneChar then
        v.Transparency = 1
    end
    if v:IsA("Accessory") and v.Parent == CloneChar then
        v.Handle.Transparency =1
    end
end
for i,v in pairs(CloneChar:GetDescendants()) do
    if v:IsA("Part") then
        v.Transparency = 1
    end
end]]
end
--Character.Head.face.Texture = CloneChar.Head.face.Texture
for i,v in pairs(Character:GetDescendants()) do
    if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
        v.Velocity = Vector3.new(0,1,0)
    end
end
--[[for i,v in pairs(CloneChar:GetDescendants()) do
    if v:IsA("Part") then
        v.Transparency = 1
    end
end]]
end)
for i,v in pairs(Character:GetDescendants()) do
    if v.Name == "AccessoryWeld" and v.Parent.Parent.Parent == Character then
        v:Destroy()
    end
        if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
        v.Responsiveness = 200
    end
    if v:IsA("AlignPosition") then
        v.MaxVelocity = math.huge
        v.MaxForce = 50000350345545
    end
    if v:IsA("Motor6D") and v.Parent == CloneChar.Torso then
        v.RobloxLocked = true
    end
    --[[if v:IsA("BodyPosition") and v.Parent.Parent == Character and v.Parent.Name ~= "HumanoidRootPart" then
        --v.MaxForce = Vector3.new(1,1,1) * math.huge
        v.P = v.P * 2
        v.Position = CloneChar[v.Parent.Name].Position
    end]]
    if v:IsA("BodyVelocity") then
        v.MaxForce = Vector3.new(1,1,1) * math.huge
        v.P = math.huge
        v.Velocity = ve
    end
        if v:IsA("BodyAngularVelocity") and v.Parent.Name ~= "HumanoidRootPart" then
        v.MaxTorque = Vector3.new(1,1,1) * math.huge
        v.P = math.huge
        v.AngularVelocity = Vector3.new(0,0,0)
    end
    if v:IsA("BodyForce") then
        v.Force = Vector3.new(15.2,15.2,15.2)
    end
    if v:IsA("Part") and v.Parent == CloneChar then
        v.Transparency = 1
    end
end
for i,v in pairs(Character.Torso:GetDescendants()) do
    if v:IsA("Motor6D") and v.Name ~= "Neck" then
        v:Destroy()
    end
end
for i,v in pairs(Character:GetDescendants()) do
    if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" and not v.Parent:IsA("Accessory") and v.Parent == Character then
        table.insert(aligns, v)
        print(v.Name)
    end
end
game:GetService("RunService").Stepped:connect(function()
for i,v in ipairs(aligns) do
--v.AlignPosition.Attachment0 = v.Attachment
    v.CFrame = CloneChar[v.Name].CFrame
end
end)
game:GetService("RunService").Heartbeat:connect(function()
for i,v in ipairs(aligns) do
--v.AlignPosition.Attachment0 = v.Attachment
    v.CFrame = CloneChar[v.Name].CFrame
end
end)
game:GetService("RunService").RenderStepped:connect(function()
for i,v in ipairs(aligns) do
--v.AlignPosition.Attachment0 = v.Attachment
    v.CFrame = CloneChar[v.Name].CFrame
end
end)
spawn(function()
while true do
    game:GetService("RunService").Stepped:wait()
v.CFrame = CloneChar[v.Name].CFrame
game:GetService("RunService").Heartbeat:wait()
v.CFrame = CloneChar[v.Name].CFrame
game:GetService("RunService").RenderStepped:wait()
v.CFrame = CloneChar[v.Name].CFrame
end
end)
Character.Head.AlignPosition.Attachment0 = Character.Head.Attachment
Character.Head.AlignPosition.Attachment1 = CloneChar.Head.Attachment
Character.Torso.AlignPosition.Attachment0 = Character.Torso.Attachment
Character.Torso.AlignPosition.Attachment1 = CloneChar.Torso.Attachment
Character["HumanoidRootPart"].AlignPosition.Attachment0 = Character["HumanoidRootPart"].Attachment
Character["HumanoidRootPart"].AlignPosition.Attachment1 = CloneChar["Torso"].Attachment
Character["HumanoidRootPart"].AlignOrientation.Attachment0 = Character["HumanoidRootPart"].Attachment
Character["HumanoidRootPart"].AlignOrientation.Attachment1 = CloneChar["Torso"].Attachment

Character.Humanoid.BreakJointsOnDeath = false
game:FindFirstChildOfClass("Players").LocalPlayer.Character = Character.ReanimChar
wait(6)
for i,v in pairs(Character:GetDescendants()) do
    if v:IsA("Accessory") and v.Parent == Character then
        table.insert(hataligns, v)
        print(v.Name)
    end
end
for i,v in ipairs(hataligns) do
    v.AlignPosition.Attachment0 = v.Handle.Attachment
    v.AlignPosition.Attachment1 = CloneChar[v.Name].Handle.Attachment
    print(CloneChar[v.Name])
    v.AlignOrientation.Attachment0 = v.Handle.Attachment
    v.AlignOrientation.Attachment1 = CloneChar[v.Name].Handle.Attachment
    print(CloneChar[v.Name])
end
for i,v in ipairs(aligns) do
    v.AlignPosition.Attachment0 = v.Attachment
    v.AlignPosition.Attachment1 = CloneChar[v.Name].Attachment
    print(CloneChar[v.Name])
    v.AlignOrientation.Attachment0 = v.Attachment
    v.AlignOrientation.Attachment1 = CloneChar[v.Name].Attachment
    print(CloneChar[v.Name])
end
Character.Head.AlignOrientation.Attachment0 = Character.Head.Attachment
Character.Head.AlignOrientation.Attachment1 = CloneChar.Head.Attachment
Character.Torso.AlignOrientation.Attachment0 = Character.Torso.Attachment
Character.Torso.AlignOrientation.Attachment1 = CloneChar.Torso.Attachment
CloneChar.Parent.Torso.Neck:Destroy()
print("Done")
for i,v in pairs(CloneChar.Parent.Torso:GetDescendants()) do
    if v:IsA("Motor6D") and v.Name ~= "Neck" then
        v:Destroy()
    end
end
Character.HumanoidRootPart.RootJoint.Part0 = nil
Character.HumanoidRootPart.RootJoint.Part1 = nil 
Character.Head.AlignPosition.Attachment0 = Character.Head.Attachment
Character.Head.AlignPosition.Attachment1 = CloneChar.Head.Attachment
Character.Torso.AlignPosition.Attachment0 = Character.Torso.Attachment
Character.Torso.AlignPosition.Attachment1 = CloneChar.Torso.Attachment
Character["HumanoidRootPart"].AlignPosition.Attachment0 = Character["HumanoidRootPart"].Attachment
Character["HumanoidRootPart"].AlignPosition.Attachment1 = CloneChar["Torso"].Attachment
Character["HumanoidRootPart"].AlignOrientation.Attachment0 = Character["HumanoidRootPart"].Attachment
Character["HumanoidRootPart"].AlignOrientation.Attachment1 = CloneChar["Torso"].Attachment
wait(1)
CloneChar.Parent.HumanoidRootPart.Position = Vector3.new(0,-5200,0)
spawn(function()
while true do
    game.RunService.RenderStepped:wait()
    for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" and v.Parent == Character then
            v.Anchored = true
        end
    end
    game.RunService.Stepped:wait()
     for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" and v.Parent == Character then
            v.Anchored = false
        end
    end
    game.RunService.Heartbeat:wait()
    for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" and v.Parent == Character then
            v.Anchored = false
        end
    end
end
end)

local hrp = game:GetService("Players").LocalPlayer.Character.Parent.HumanoidRootPart
local e = Instance.new("SelectionBox", hrp)
e.Adornee = hrp
hrp.Name = "HumanoidRootPart"
hrp.Transparency = 0.5
hrp.Anchored = false
if hrp:FindFirstChildOfClass("AlignPosition") then
	hrp:FindFirstChildOfClass("AlignPosition"):Destroy()
end
if hrp:FindFirstChildOfClass("BodyAngularVelocity") then
	hrp:FindFirstChildOfClass("BodyAngularVelocity"):Destroy()
end
if hrp:FindFirstChildOfClass("AlignOrientation") then
	hrp:FindFirstChildOfClass("AlignOrientation"):Destroy()
end
local bp = Instance.new("BodyPosition", hrp)
bp.Position = hrp.Position
bp.D = 9999999
bp.P = 999999999999999
bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
local flinger = Instance.new("BodyAngularVelocity",hrp)
flinger.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
flinger.P = 1000000000000000000000000000
flinger.AngularVelocity = Vector3.new(99999999999999999999,999999999999999999,999999999999999)

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		bp.Position = hrp.Parent.Torso.Position
        hrp.Velocity = ve
        e.Transparency = (hrp.Parent.Head.LocalTransparencyModifier)
	end
end)
end


plr = game.Players.LocalPlayer
local owner = plr
local PLAYER = plr
local Player = PLAYER
local MOUSE = CMouse
local Mouse = CMouse
local mouse = CMouse
---- Sources and functions might be taken from others

-- Nebula stuff --
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {tRGB= function(c3) return c3.r*255,c3.g*255,c3.b*255 end,N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players

local Alpha = .3

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end
-- Script --
mouse = plr:GetMouse()
char = plr.Character
hum = char.Humanoid
local cam = game.Workspace.CurrentCamera
Camera = cam
local CamInterrupt = false
local TwoD = false
local TargetInfo = {nil, nil}
cam.CameraType = "Custom"
t = char.Torso
h = char.Head
ra = char["Right Arm"]
la = char["Left Arm"]
rl = char["Right Leg"]
ll = char["Left Leg"]
tors = char.Torso
lleg = char["Left Leg"]
root = char.HumanoidRootPart
hed = char.Head
rleg = char["Right Leg"]
rarm = char["Right Arm"]
larm = char["Left Arm"]
radian = math.rad
random = math.random
Vec3 = Vector3.new
Inst = Instance.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new
local FACEid = 20418518


local Booleans = {
	CamFollow = true,
	GyroUse = true
}

function lerp(object, newCFrame, alpha)
	return object:lerp(newCFrame, alpha)
end

local Directer = Inst("BodyGyro", root)
Directer.MaxTorque = Vec3(0, 0, 0)
Directer.P = 600000
local CPart = Inst("Part")
CPart.Anchored = true
CPart.CanCollide = false
CPart.Locked = true
CPart.Transparency = 1
local secondary = false

kan = Instance.new("Sound",plr)
kan.Volume = 1.25
kan.TimePosition = 0
kan.PlaybackSpeed = 1.01
kan.Pitch = 1.01
kan.SoundId = "rbxassetid://923445685"
kan.Name = "kan"
kan.Looped = true
kan:Play()
local mutedtog = false



function shakes(power,length)

end


function CameraEnshaking(Length,Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1*Intensity
		local rotM = 0.01*Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05*Intensity/Length
			rotM = rotM - 0.0005*Intensity/Length
			hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
			cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
		end
		Humanoid.CameraOffset = Vec3(0, 0, 0)
	end))
end
CamShake=function(Part,Distan,Power,Times) 
	local de=Part.Position
	for i,v in pairs(workspace:children()) do
		if v:IsA("Model") and v:findFirstChild("Humanoid") then
			for _,c in pairs(v:children()) do
				if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
					local Noob=v.Humanoid
					if Noob~=nil then
						coroutine.resume(coroutine.create(function()
							FV = Instance.new("BoolValue", Noob)
							FV.Name = "CameraShake"
							for ShakeNum=1,Times do
								swait()
								local ef=Power
								if ef>=1 then
									Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
								else
									ef=Power*10
									Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
								end	
							end
							Humanoid.CameraOffset = Vector3.new(0,0,0)
							FV:Destroy()
						end))
						CameraShake(Times, Power, Noob)
					end
				end
			end
		end
	end
end

local Instance = setmetatable({ClearChildrenOfClass = function(where,class,recursive) local children = (recursive and where:GetDescendants() or where:GetChildren()) for _,v in next, children do if(v:IsA(class))then v:destroy();end;end;end},{__index = Instance})

--// Require stuff \\--
function CamShake(who,times,intense,origin) 
	coroutine.wrap(function()
		if(FXFolder:FindFirstChild'CamShake')then
			local cam = FXFolder.CamShake:Clone()
			cam:WaitForChild'intensity'.Value = intense
			cam:WaitForChild'times'.Value = times

			if(origin)then NewInstance((typeof(origin) == 'Instance' and "ObjectValue" or typeof(origin) == 'Vector3' and 'Vector3Value'),cam,{Name='origin',Value=origin}) end
			cam.Parent = who
			wait()
			cam.Disabled = false
		end
	end)()
end

function CamShakeAll(times,intense,origin)
	for _,v in next, Plrs:players() do
		CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,times,intense,origin)
	end
end

function chatfunc(text,color,typet,font,timeex)
	local chat = coroutine.wrap(function()
		if Character:FindFirstChild("TalkingBillBoard")~= nil then
			Character:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui",Character)
		naeeym2.Size = UDim2.new(0,100,0,40)
		naeeym2.StudsOffset = Vector3.new(0,3,0)
		naeeym2.Adornee = Character.Head
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel",naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = font
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = color
		tecks2.TextStrokeColor3 = Color3.new(0,0,0)
		tecks2.Size = UDim2.new(1,0,0.5,0)
		local tecks3 = Instance.new("TextLabel",naeeym2)
		tecks3.BackgroundTransparency = 1
		tecks3.BorderSizePixel = 0
		tecks3.Text = ""
		tecks3.Font = font
		tecks3.TextSize = 30
		tecks3.TextStrokeTransparency = 0
		if typet == "Inverted" then
			tecks3.TextColor3 = Color3.new(0,0,0)
			tecks3.TextStrokeColor3 = color
		elseif typet == "Normal" then
			tecks3.TextColor3 = color
			tecks3.TextStrokeColor3 = Color3.new(0,0,0)
		end
		tecks3.Size = UDim2.new(1,0,0.5,0)
		for i = 0, 74*timeex do
			swait()
			tecks2.Text = text
			tecks3.Text = text
		end
		local randomrot = math.random(1,2)
		if randomrot == 1 then
			for i = 1, 50 do
				swait()
				tecks2.Text = text
				tecks3.Text = text
				tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
				tecks2.TextTransparency = tecks2.TextTransparency + .04
				tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
				tecks3.TextTransparency = tecks2.TextTransparency + .04
			end
		elseif randomrot == 2 then
			for i = 1, 50 do
				swait()
				tecks2.Text = text
				tecks3.Text = text
				tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
				tecks2.TextTransparency = tecks2.TextTransparency + .04
				tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
				tecks3.TextTransparency = tecks2.TextTransparency + .04
			end
		end
		naeeym2:Destroy()
	end)
	chat()
end



FELOADLIBRARY = {}
loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
local Create = FELOADLIBRARY.Create
CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};

	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};

	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};

	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};

	["TimeSound"] = {
		Create = function(id, par, vol, pit, timepos,timedel) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					TimePosition = timepos,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, timedel)
			end))
		end;
	};
	["EchoSound"] = {
		Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
			coroutine.resume(coroutine.create(function()
				local Sas = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					TimePosition = timepos,
					Parent = par or workspace,
				}
				local E = Create("EchoSoundEffect"){
					Delay = echodelay,
					Name = "Echo",
					Feedback = fedb,
					DryLevel = dryl,
					Parent = Sas,
				}
				wait() 
				Sas:play() 
				game:GetService("Debris"):AddItem(Sas, delays)
			end))
		end;
	};

	["LongSound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 60)
			end))
		end;
	};

	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {

	};
}



New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
local maincolor = BrickColor.new("Really black")
local m = Instance.new("Model",char)
local colorizermod = Instance.new("Model",char)


gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
	local gui = it(GuiType)
	gui.Parent = parent
	gui.Text = text
	gui.BackgroundTransparency = backtrans
	gui.BackgroundColor3 = backcol
	gui.SizeConstraint = "RelativeXY"
	gui.TextXAlignment = "Center"
	gui.TextYAlignment = "Center"
	gui.Position = pos
	gui.Size = size
	gui.Font = "SourceSans"
	gui.FontSize = "Size14"
	gui.TextWrapped = false
	gui.TextStrokeTransparency = 0
	gui.TextColor = BrickColor.new("White")
	return gui
end
--------------------------- GUI STUFF
local basgui = it("GuiMain")
basgui.Parent = plr.PlayerGui
basgui.Name = "VISgui"
local fullscreenz = it("Frame")
fullscreenz.Parent = basgui
fullscreenz.BackgroundColor3 = Color3.new(255, 255, 255)
fullscreenz.BackgroundTransparency = 1
fullscreenz.BorderColor3 = Color3.new(17, 17, 17)
fullscreenz.Size = UDim2.new(1, 0, 1, 0)
fullscreenz.Position = UDim2.new(0, 0, 0, 0)
local imgl2 = Instance.new("ImageLabel",fullscreenz)
imgl2.BackgroundTransparency = 1
imgl2.BorderSizePixel = 0
imgl2.ImageTransparency = 0.5
imgl2.ImageColor3 = BrickColor.new("Pastel light blue").Color
imgl2.Position = UDim2.new(0.75,-100,0.55,-100)
imgl2.Size = UDim2.new(0,800,0,800)
imgl2.Image = "rbxassetid://2076458450"
local techc = imgl2:Clone()
techc.Parent = fullscreenz
techc.ImageTransparency = 0
techc.Size = UDim2.new(0,900,0,900)
techc.Position = UDim2.new(0.75,-150,0.55,-150)
techc.ImageColor3 = BrickColor.new("Pastel light blue").Color
techc.Image = "rbxassetid://2092248396"
local circl = imgl2:Clone()
circl.Parent = fullscreenz
circl.ImageTransparency = 0
circl.Size = UDim2.new(0,550,0,550)
circl.Position = UDim2.new(0.75,25,0.55,25)
circl.ImageColor3 = BrickColor.new("Alder").Color
circl.Image = "rbxassetid://2109052855"
local circl2 = imgl2:Clone()
circl2.Parent = fullscreenz
circl2.ImageTransparency = 0
circl2.Size = UDim2.new(0,700,0,700)
circl2.Position = UDim2.new(0.75,-50,0.55,-50)
circl2.ImageColor3 = BrickColor.new("Pastel light blue").Color
circl2.Image = "rbxassetid://2109045978"
local imgl2b = imgl2:Clone()
imgl2b.Parent = fullscreenz
imgl2b.ImageTransparency = 0
imgl2b.Size = UDim2.new(0,600,0,600)
imgl2b.Position = UDim2.new(0.75,0,0.55,0)
imgl2b.ImageColor3 = BrickColor.new("Alder").Color
local ned = Instance.new("TextLabel",fullscreenz)
ned.ZIndex = 2
ned.Font = "SciFi"
ned.BackgroundTransparency = 1
ned.BorderSizePixel = 0.65
ned.Size = UDim2.new(0.3,0,0.2,0)
ned.Position = UDim2.new(0.7,0,0.8,0)
ned.TextColor3 = BrickColor.new("Pastel light blue").Color
ned.TextStrokeColor3 = BrickColor.new("Alder").Color
ned.TextScaled = true
ned.TextStrokeTransparency = 0
ned.Text = "SYNTHEZIZER"
ned.TextSize = 24
ned.Rotation = 1
ned.TextXAlignment = "Right"
ned.TextYAlignment = "Bottom"

function CreateParta(parent,transparency,reflectance,material,brickcolor)
	local p = Instance.new("Part")
	p.TopSurface = 0
	p.BottomSurface = 0
	p.Parent = parent
	p.Size = Vector3.new(0.1,0.1,0.1)
	p.Transparency = transparency
	p.Reflectance = reflectance
	p.CanCollide = false
	p.Locked = true
	p.BrickColor = brickcolor
	p.Material = material
	return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
	local mesh = Instance.new("SpecialMesh",parent)
	mesh.MeshType = meshtype
	mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
	return mesh
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
	local mesh = Instance.new("SpecialMesh",parent)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = meshid
	mesh.Scale = Vector3.new(x1,y1,z1)
	return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
	local mesh = Instance.new("SpecialMesh",parent)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = meshid
	mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
	mesh.Scale = Vector3.new(x1,y1,z1)
	mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
	return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
	local weld = Instance.new("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
	weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
	return weld
end


----------------------------
-------------- ground effect
local cen = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(cen,root,cen,0,3,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local effar = Instance.new("ParticleEmitter",cen)
effar.Texture = "rbxassetid://2344870656"
effar.LightEmission = 1
effar.Color = ColorSequence.new(Color3.new(1,1,1))
effar.Rate = 150
effar.Enabled = false
effar.EmissionDirection = "Front"
effar.Lifetime = NumberRange.new(1)
effar.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.1,5,0),NumberSequenceKeypoint.new(0.8,15,0),NumberSequenceKeypoint.new(1,40,0)})
effar.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
effar.Speed = NumberRange.new(80,90)
effar.Acceleration = Vector3.new(0,10,0)
effar.Drag = 5
effar.Rotation = NumberRange.new(-500,500)
effar.SpreadAngle = Vector2.new(0,900)
effar.RotSpeed = NumberRange.new(-500,500)


local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb,rarm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb2,larm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local handlex = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handlex,"Brick",0,0,0)
local handlexweld = CreateWeld(handlex,tors,handlex,0,-2,-2.05,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local rotzo = CreateParta(m,1,1,"Neon",maincolor)
rotzo.Transparency = 1
CreateMesh(rotzo,"Brick",0,0,0)
local rotingweld = CreateWeld(rotzo,handlex,rotzo,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local hat = game:GetService("Players").LocalPlayer.Character["gamer1"]

local function align(part0, part1)

	part0.AccessoryWeld:Destroy()
	local attachment0 = Instance.new("Attachment", part0)
	attachment0.Position = Vector3.new(0, -0, 0) --Custom Positioning Values Here
	attachment0.Orientation = Vector3.new(0, 0, -40) --Custom Rotationing Values here
	local attachment1 = Instance.new("Attachment", part1)
	local weldpos = Instance.new("AlignPosition", part0)
	weldpos.Attachment0 = attachment0
	weldpos.Attachment1 = attachment1
	weldpos.RigidityEnabled = true
	weldpos.ReactionForceEnabled = false
	weldpos.ApplyAtCenterOfMass = false
	weldpos.MaxForce = 20000
	weldpos.MaxVelocity = math.huge
	weldpos.Responsiveness = 200000000000000
	local weldrot = Instance.new("AlignOrientation", part0)
	weldrot.Attachment0 = attachment0
	weldrot.Attachment1 = attachment1
	weldrot.ReactionTorqueEnabled = false
	weldrot.PrimaryAxisOnly = false
	weldrot.MaxTorque = 200000000
	weldrot.MaxAngularVelocity = math.huge
	weldrot.Responsiveness = 200000000000000
end
align(hat.Handle, rotzo)


local rotzo2 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(rotzo2,"Brick",0,0,0)
local rotingweld2 = CreateWeld(rotzo2,handlex,rotzo2,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local roterval = 0
for i = 0, 7 do
	roterval = roterval + 45
end
local refec = Instance.new("ParticleEmitter",handlex)
refec.Texture = "rbxassetid://284205403"
refec.LightEmission = 0.95
refec.Color = ColorSequence.new(BrickColor.new("Alder").Color)
refec.Rate = 50
refec.Lifetime = NumberRange.new(0.5)
refec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.5,0.75,0),NumberSequenceKeypoint.new(1,0.1,0)})
refec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
refec.Speed = NumberRange.new(0,2)
refec.Drag = 5
refec.LockedToPart = true
refec.Rotation = NumberRange.new(-500,500)
refec.VelocitySpread = 9000
refec.RotSpeed = NumberRange.new(-500,500)
local refec2 = refec:Clone()
refec2.LightEmission = 0.75
refec2.Texture = "rbxassetid://2109052855"--2108979939 254287058 2109052855
refec2.Parent = handlex
refec2.Rate = 15
refec2.Lifetime = NumberRange.new(0.75)
refec2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2.15,0),NumberSequenceKeypoint.new(0.7,2.25,0),NumberSequenceKeypoint.new(0.8,2.15,0),NumberSequenceKeypoint.new(1,1.75,0)})
refec2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.65,0),NumberSequenceKeypoint.new(1,1,0)})
refec2.Speed = NumberRange.new(0)
local refec3 = refec:Clone()
refec3.LightEmission = 0.75
refec3.Texture = "rbxassetid://2092248396"
refec3.Parent = handlex
refec3.Rate = 25
refec3.Lifetime = NumberRange.new(1)
refec3.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,4,0),NumberSequenceKeypoint.new(1,15,0)})
refec3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.65,0),NumberSequenceKeypoint.new(1,1,0)})
refec3.Speed = NumberRange.new(0)
refec3.RotSpeed = NumberRange.new(-50,50)
local valuaring = 10
for i = 0, 35 do
	valuaring = valuaring + 10
	
end
------


function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
	RemoveOutlines(Part)
	return Part
end
function CreateMesha(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end

Player = plr
Character=Player.Character 
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character.Humanoid
m=Instance.new('Model',Character)
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LW=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RW=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
cloaked=false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
attackdebounce = false 
deb=false
equipped=true
hand=false
combo=0
mana=0
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
local Effects={}
local gun=false
local shoot=false
local sine = 0
local change = 1

--save shoulders 
RSH, LSH=nil, nil 
--welds 
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
function NoOutline(Part)
	Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil
-- 
RW.Name="Right Shoulder"
RW.Part0=char.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=char["Right Arm"] 
RW.Parent=char.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=char.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=char["Left Arm"] 
LW.Parent=char.Torso
local donum=0


function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
	local fp=it("Part")
	fp.formFactor=formfactor 
	fp.Parent=parent
	fp.Reflectance=reflectance
	fp.Transparency=transparency
	fp.CanCollide=false 
	fp.Locked=true
	fp.BrickColor=brickcolor
	fp.Name=name
	fp.Size=size
	fp.Position=Torso.Position 
	NoOutline(fp)
	fp.Material="SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 

function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh=it(Mesh) 
	mesh.Parent=part
	if Mesh=="SpecialMesh" then
		mesh.MeshType=meshtype
		if meshid~="nil" then
			mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset=offset
	mesh.Scale=scale
	return mesh
end

function weld(parent,part0,part1,c0)
	local weld=it("Weld") 
	weld.Parent=parent
	weld.Part0=part0 
	weld.Part1=part1 
	weld.C0=c0
	return weld
end

local Color1=Torso.BrickColor

local bodvel=Instance.new("BodyVelocity")
local bg=Instance.new("BodyGyro")


--------- SazEreno's Artificial HB --------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")
Frame_Speed = 1 / 60
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

------------------
function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, num do
			ArtificialHB.Event:wait()
		end
	end
end

-------- RAINBOW LEAVE IT TO ME
local r = 255
local r2 = 0
local g = 0
local b = 0
coroutine.resume(coroutine.create(function()
	while wait() do
		for i = 0, 254/5 do
			swait()
			g = g + 5
		end
		for i = 0, 254/5 do
			swait()
			r2 = r2 + 5
		end
		for i = 0, 254/5 do
			swait()
			r = r - 5
		end
		for i = 0, 254/5 do
			swait()
			b = b + 5
		end
		for i = 0, 254/5 do
			swait()
			g = g - 5
		end
		for i = 0, 254/5 do
			swait()
			r2 = r2 - 5
		end
		for i = 0, 254/5 do
			swait()
			r = r + 5
		end
		for i = 0, 254/5 do
			swait()
			b = b - 5
		end
	end
end))


so = function(id,par,vol,pit) 
	coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound",par or workspace)
		sou.Volume=vol
		sou.Pitch=pit or 1
		sou.SoundId=id
		swait() 
		sou:play() 
		game:GetService("Debris"):AddItem(sou,6)
	end))
end

function clerp(a,b,t) 
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)} 
	local ax, ay, az = a.x, a.y, a.z 
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1-t
	return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 

function QuaternionFromCFrame(cf) 
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
	local trace = m00 + m11 + m22 
	if trace > 0 then 
		local s = math.sqrt(1 + trace) 
		local recip = 0.5/s 
		return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
	else 
		local i = 0 
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then 
			i = 2 
		end 
		if i == 0 then 
			local s = math.sqrt(m00-m11-m22+1) 
			local recip = 0.5/s 
			return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
		elseif i == 1 then 
			local s = math.sqrt(m11-m22-m00+1) 
			local recip = 0.5/s 
			return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
		elseif i == 2 then 
			local s = math.sqrt(m22-m00-m11+1) 
			local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
		end 
	end 
end

function QuaternionToCFrame(px, py, pz, x, y, z, w) 
	local xs, ys, zs = x + x, y + y, z + z 
	local wx, wy, wz = w*xs, w*ys, w*zs 
	local xx = x*xs 
	local xy = x*ys 
	local xz = x*zs 
	local yy = y*ys 
	local yz = y*zs 
	local zz = z*zs 
	return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end

function QuaternionSlerp(a, b, t) 
	local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
	local startInterp, finishInterp; 
	if cosTheta >= 0.0001 then 
		if (1 - cosTheta) > 0.0001 then 
			local theta = math.acos(cosTheta) 
			local invSinTheta = 1/math.sin(theta) 
			startInterp = math.sin((1-t)*theta)*invSinTheta 
			finishInterp = math.sin(t*theta)*invSinTheta  
		else 
			startInterp = 1-t 
			finishInterp = t 
		end 
	else 
		if (1+cosTheta) > 0.0001 then 
			local theta = math.acos(-cosTheta) 
			local invSinTheta = 1/math.sin(theta) 
			startInterp = math.sin((t-1)*theta)*invSinTheta 
			finishInterp = math.sin(t*theta)*invSinTheta 
		else 
			startInterp = t-1 
			finishInterp = t 
		end 
	end 
	return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

local function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CFrame.new(at.x, at.y, at.z,
		right.x, top.x, back.x,
		right.y, top.y, back.y,
		right.z, top.z, back.z)
end

function Triangle(a, b, c)
	local edg1 = (c-a):Dot((b-a).unit)
	local edg2 = (a-b):Dot((c-b).unit)
	local edg3 = (b-c):Dot((a-c).unit)
	if edg1 <= (b-a).magnitude and edg1 >= 0 then
		a, b, c = a, b, c
	elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
		a, b, c = b, c, a
	elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
		a, b, c = c, a, b
	else
		assert(false, "unreachable")
	end

	local len1 = (c-a):Dot((b-a).unit)
	local len2 = (b-a).magnitude - len1
	local width = (a + (b-a).unit*len1 - c).magnitude

	local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)

	local list = {}

	if len1 > 0.01 then
		local w1 = Instance.new('WedgePart', m)
		game:GetService("Debris"):AddItem(w1,5)
		w1.Material = "SmoothPlastic"
		w1.FormFactor = 'Custom'
		w1.BrickColor = BrickColor.new("Really red")
		w1.Transparency = 0
		w1.Reflectance = 0
		w1.Material = "SmoothPlastic"
		w1.CanCollide = false
		local l1 = Instance.new("PointLight",w1)
		l1.Color = Color3.new(170,0,0)
		NoOutline(w1)
		local sz = Vector3.new(0.2, width, len1)
		w1.Size = sz
		local sp = Instance.new("SpecialMesh",w1)
		sp.MeshType = "Wedge"
		sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
		w1:BreakJoints()
		w1.Anchored = true
		w1.Parent = workspace
		w1.Transparency = 0.7
		table.insert(Effects,{w1,"Disappear",.01})
		w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
		table.insert(list,w1)
	end

	if len2 > 0.01 then
		local w2 = Instance.new('WedgePart', m)
		game:GetService("Debris"):AddItem(w2,5)
		w2.Material = "SmoothPlastic"
		w2.FormFactor = 'Custom'
		w2.BrickColor = BrickColor.new("Really red")
		w2.Transparency = 0
		w2.Reflectance = 0
		w2.Material = "SmoothPlastic"
		w2.CanCollide = false
		local l2 = Instance.new("PointLight",w2)
		l2.Color = Color3.new(170,0,0)
		NoOutline(w2)
		local sz = Vector3.new(0.2, width, len2)
		w2.Size = sz
		local sp = Instance.new("SpecialMesh",w2)
		sp.MeshType = "Wedge"
		sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
		w2:BreakJoints()
		w2.Anchored = true
		w2.Parent = workspace
		w2.Transparency = 0.7
		table.insert(Effects,{w2,"Disappear",.01})
		w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
		table.insert(list,w2)
	end
	return unpack(list)
end


function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
	if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Head") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
			return
		end
		local c = Create("ObjectValue")({
			Name = "creator",
			Value = Player,
			Parent = h
		})
		game:GetService("Debris"):AddItem(c, 0.5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil and block.className == "IntValue" and block.Value > 0 then
			blocked = true
			block.Value = block.Value - 1
			print(block.Value)
		end
		if blocked == false then
			local HitHealth = h.Health
			h.MaxHealth = 100
			h.Health = h.Health - Damage
			if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
				print("gained kill")
				dmg(h.Parent)
			end
			ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
		else
			h.Health = h.Health - Damage / 2
			ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
			local bodvol = Create("BodyVelocity")({
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = hit
			})
			local rl = Create("BodyAngularVelocity")({
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit
			})
			game:GetService("Debris"):AddItem(bodvol, 0.5)
			game:GetService("Debris"):AddItem(rl, 0.5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity")({
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
			})
			if knockback > 0 then
				vp.Parent = hit.Parent.Head
			end
			game:GetService("Debris"):AddItem(vp, 0.5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity")({
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = hit
			})
			game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
			local bodyVelocity = Create("BodyVelocity")({
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = hit
			})
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Leech" then
			local hum = hit.Parent.Humanoid
			if hum ~= nil then
				for i = 0, 2 do
					Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
				end
				Humanoid.Health = Humanoid.Health + 10
			end
		elseif Type == "UpKnock" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			if hum ~= nil then
				hitr = true
			end
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(5)
				HHumanoid.PlatformStand = false
				hitr = false
			end), hum)
			local bodyVelocity = Create("BodyVelocity")({
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = hit
			})
			game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
			local bodyVelocity = Create("BodyVelocity")({
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8000, 8000, 8000),
				Parent = hit
			})
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition")({
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso
			})
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Slashnare" then
			Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
			for i = 1, math.random(4, 5) do
				Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
			end
			local bp = Create("BodyPosition")({
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso
			})
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Spike" then
			local bp = Create("BodyPosition")({
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso
			})
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition")({
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso
			})
			local BodGy = Create("BodyGyro")({
				maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
				P = 20000,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame
			})
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part)
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue")({
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true
		})
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Instance.new("ObjectValue")
		c.Name = "creator"
		c.Value = Player
		c.Parent = h
		game:GetService("Debris"):AddItem(c, 0.5)
	end
end
function ShowDamage(Pos, Text, Time, Color)
	local Rate = 0.03333333333333333
	local Pos = Pos or Vector3.new(0, 0, 0)
	local Text = Text or ""
	local Time = Time or 2
	local Color = Color or Color3.new(1, 0, 1)
	local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui")({
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart
	})
	local TextLabel = Create("TextLabel")({
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		TextColor3 = Color,
		TextScaled = true,
		Font = Enum.Font.ArialBold,
		Parent = BillboardGui
	})
	game.Debris:AddItem(EffectPart, Time + 0.1)
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = Time / Rate
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = Frame / Frames
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChildOfClass("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Head")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if magni >= mag and c.Name ~= Player.Name then
					
				end
			end
		end
	end
end

function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
	for _, c in pairs(workspace:children()) do
		local hum = c:findFirstChild("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("Torso")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if magni >= mag and c.Name ~= Player.Name then
					MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
		
				end
			end
		end
	end
end

function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
	return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 


function ring(type,pos,scale,value)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
		end
		rng:Destroy()
	end))
end


function wave(type,pos,scale,value)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
		end
		rng:Destroy()
	end))
end

function wind(type,pos,scale,value,speed)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
		end
		rng:Destroy()
	end))
end

function groundwind(type,pos,scale,value,speed)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
		end
		rng:Destroy()
	end))
end

function CameraManager()
	if TwoD and not CamInterrupt then
		if Humanoid.Health > 0 then
			Camera.CameraSubject = Humanoid
			Camera.CameraType = "Scriptable"
			Humanoid.AutoRotate = false
			if Booleans.GyroUse then
				Directer.MaxTorque = Vec3(0, math.huge, 0)
			else
				Directer.MaxTorque = Vec3(0, 0, 0)
			end
			if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
				if Booleans.CamFollow then
					CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
					Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
				else
					CPart.Position = RootPart.Position
				end
			else
				local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
				CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
			end
			Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
		else
			Camera.CameraSubject = Humanoid
			Camera.CameraType = "Custom"
			Controller.Disabled = false
		end
	end
end

function ring(type,pos,scale,value)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
		end
		rng:Destroy()
	end))
end


function wave(type,pos,scale,value)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = origcolor
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value
			end
			rng.Transparency = rng.Transparency + 0.01
			rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
		end
		rng:Destroy()
	end))
end

function sphere(bonuspeed,type,pos,scale,value,color)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	if ModeOfGlitch ~= 9 then
		rng.BrickColor = color
	elseif ModeOfGlitch == 9 then
		rng.Color = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
	end
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	if ModeOfGlitch == 9 then
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rng.Parent ~= nil then
					rng.Color = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
				else
					break
				end
			end
		end))
	end
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	if ModeOfGlitch ~= 9 then
		rng.BrickColor = color
	elseif ModeOfGlitch == 9 then
		rng.Color = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
	end
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	if ModeOfGlitch == 9 then
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rng.Parent ~= nil then
					rng.Color = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
				else
					break
				end
			end
		end))
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
	local type = type
	local rotenable = rotatingop
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	if typeoftrans == "In" then
		rng.Transparency = 1
	end
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "FileMesh"
	if typeofshape == "Normal" then
		rngm.MeshId = "rbxassetid://662586858"
	elseif typeofshape == "Round" then
		rngm.MeshId = "rbxassetid://662585058"
	end
	rngm.Scale = scale
	local scaler2 = 1/10
	if type == "Add" then
		scaler2 = 1*value/10
	elseif type == "Divide" then
		scaler2 = 1/value/10
	end
	local randomrot = math.random(1,2)
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed/10
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed/10
			end
			if rotenable == true then
				if randomrot == 1 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
				elseif randomrot == 2 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
				end
			end
			if typeoftrans == "Out" then
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
			elseif typeoftrans == "In" then
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
			end
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
		end
		rng:Destroy()
	end))
end

function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 1
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			--rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 1
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	local scaler2 = 0
	local speeder = FastSpeed/10
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder + 0.01*FastSpeed*bonuspeed/10
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			--rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
		end
		rng:Destroy()
	end))
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.Color = color3
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	if ModeOfGlitch ~= 9 then
		rng.BrickColor = color
	elseif ModeOfGlitch == 9 then
		rng.Color = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
	end
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	if ModeOfGlitch == 9 then
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rng.Parent ~= nil then
					rng.Color = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
				else
					break
				end
			end
		end))
	end
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
		end
		rng:Destroy()
	end))
end


function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	if ModeOfGlitch ~= 9 then
		rng.BrickColor = color
	elseif ModeOfGlitch == 9 then
		rng.Color = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
	end
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 1
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = vt(x1,y1,z1)
	if rainbowmode == true then
		rng.Color = Color3.new(r/255,g/255,b/255)
	end
	if ModeOfGlitch == 9 then
		coroutine.resume(coroutine.create(function()
			while true do
				swait()
				if rng.Parent ~= nil then
					rng.Color = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
				else
					break
				end
			end
		end))
	end
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1*value
	elseif type == "Divide" then
		scaler2 = 1/value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			swait()
			if rainbowmode == true then
				rng.Color = Color3.new(r/255,g/255,b/255)
			end
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.random()
			end
			speeder = speeder - 0.01*FastSpeed*bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
			rng.Transparency = rng.Transparency - 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function dmg(dude)
	if dude.Name ~= Character then
		
		dude:Destroy()

	end
end	


function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Head") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end

function FaceMouse()
	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end

function FaceMouse2()
	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end

-- Functions are ready.

local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local storehumanoidWS = 16

function createBGCircle(size,parent,color)
	local bgui = Instance.new("BillboardGui",parent)
	bgui.Size = UDim2.new(size, 0, size, 0)
	local imgc = Instance.new("ImageLabel",bgui)
	imgc.BackgroundTransparency = 1
	imgc.ImageTransparency = 0
	imgc.Size = UDim2.new(1,0,1,0)
	imgc.Image = "rbxassetid://997291547" --997291547,521073910
	imgc.ImageColor3 = color
	return bgui,imgc
end

function symbolizeBlink(guipar,size,img,color,bonussize,vol,pit,soundid,spar,rotationenabled,rotsp,delay)
	local bgui,imgc = createBGCircle(size,guipar,color)
	bgui.AlwaysOnTop = true
	imgc.Image = "rbxassetid://" ..img
	local rrot = math.random(1,2)
	CFuncs["Sound"].Create("rbxassetid://" ..soundid, spar, vol,pit)
	coroutine.resume(coroutine.create(function()
		for i = 0, 24*delay do
			swait()
			if rotationenabled == true then
				if rrot == 1 then
					imgc.Rotation = imgc.Rotation + rotsp
				elseif rrot == 2 then
					imgc.Rotation = imgc.Rotation - rotsp
				end
			end
			bgui.Size = bgui.Size + UDim2.new(1*bonussize/delay,0,1*bonussize/delay,0)
			imgc.ImageTransparency = imgc.ImageTransparency + 0.04/delay
		end
		bgui:Destroy()
	end))
end

local actualrotationvalue = 0

function Laserbeamy()
	attack = true
	hum.WalkSpeed = 0
	CFuncs["Sound"].Create("rbxassetid://289315275", handlex, 7.5, 1)
	CFuncs["Sound"].Create("rbxassetid://1521621176", handlex, 5,1)
	CFuncs["Sound"].Create("rbxassetid://418302853", handlex, 6.5, 1)
	CFuncs["TimeSound"].Create("rbxassetid://184173042", handlex, 5, 1,0,2.75)
	CFuncs["Sound"].Create("rbxassetid://898407368", handlex, 1.75, 1.2)
	CFuncs["Sound"].Create("rbxassetid://1930016365", handlex, 1.75, 1.1)
	CFuncs["Sound"].Create("rbxassetid://1752639888", handlex, 1.5, 1)
	local efec = Instance.new("ParticleEmitter",handlex)
	efec.Texture = "rbxassetid://2109052855"
	efec.LightEmission = 1
	efec.Color = ColorSequence.new(BrickColor.new("Alder").Color)
	efec.Rate = 10
	efec.Lifetime = NumberRange.new(0.75)
	efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,5,0),NumberSequenceKeypoint.new(0.8,7.5,0),NumberSequenceKeypoint.new(1,0,0)})
	efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.25,0),NumberSequenceKeypoint.new(0.6,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
	efec.Drag = 5
	efec.LockedToPart = true
	efec.Rotation = NumberRange.new(-500,500)
	efec.VelocitySpread = 9000
	efec.Speed = NumberRange.new(0)
	efec.RotSpeed = NumberRange.new(-500,500)
	local efec2 = efec:Clone()
	efec2.LightEmission = 1
	efec2.Texture = "rbxassetid://2092248396"
	efec2.Parent = handlex
	efec2.Rate = 10
	efec2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,17.5,0),NumberSequenceKeypoint.new(0.5,15,0),NumberSequenceKeypoint.new(0.8,50,0),NumberSequenceKeypoint.new(1,100,0)})
	efec2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
	efec2.RotSpeed = NumberRange.new(-100,100)
	for i = 0,10,0.1 do
		swait()
		CamShakeAll(25,25,Character)
		actualrotationvalue = actualrotationvalue + 14
		handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-2,5)*angles(math.rad(-5),math.rad(60),math.rad(0)),.3)
		sphere2(5,"Add",handlex.CFrame,vt(4,4,0.1),0.005,0.005,0.005,BrickColor.new("Alder"))
		RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,-0.05)* angles(math.rad(5),math.rad(0),math.rad(60)),0.5)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(-5),math.rad(-60)),.5)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(95), math.rad(0), math.rad(60)), 0.5)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-30)), 0.5)
		RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(-30),math.rad(15)),.5)
		LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-4.5),math.rad(0),math.rad(10)),.5)
	end
	efec.Enabled = false
	efec2.Enabled = false
	game:GetService("Debris"):AddItem(efec, 5)
	game:GetService("Debris"):AddItem(efec2, 5)
	CFuncs["Sound"].Create("rbxassetid://919941001", handlex, 8, 1.1)
	sphere2(5,"Add",handlex.CFrame,vt(4,4,0.1),0.5,0.5,0.005,BrickColor.new("Alder"))
	sphere2(4,"Add",handlex.CFrame,vt(4,4,0.1),0.5,0.5,0.005,BrickColor.new("Alder"))
	sphere2(3,"Add",handlex.CFrame,vt(4,4,0.1),0.5,0.5,0.005,BrickColor.new("Alder"))
	for i = 0, 14 do
		slash(math.random(10,40)/10,5,true,"Round","Add","Out",handlex.CFrame*CFrame.Angles(math.rad(90 + math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(30,70)/250,BrickColor.new("White"))
	end

	for i = 0, 24 do
		shakes(0.4,0.25)
		for i = 0,1,0.6 do
			swait()
			hum.CameraOffset = vt(math.random(-10,10)/60,math.random(-10,10)/60,math.random(-10,10)/60)
			actualrotationvalue = actualrotationvalue + 14
			handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handlexweld.C1=clerp(handlexweld.C1,cf(0,-2,5)*angles(math.rad(-5),math.rad(60),math.rad(0)),.3)
			sphere2(5,"Add",handlex.CFrame,vt(4,4,0.1),0.005,0.005,0.005,BrickColor.new("Alder"))
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,-0.05)* angles(math.rad(5),math.rad(0),math.rad(60)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(-5),math.rad(-60)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(95), math.rad(0), math.rad(60)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-30)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(-30),math.rad(15)),.5)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-4.5),math.rad(0),math.rad(10)),.5)
		end

		local orb = Instance.new("Part", char)
		CFuncs["Sound"].Create("rbxassetid://1146690130", handlex, 2,1.25)
		orb.BrickColor = BrickColor.new("Alder")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 1
		orb.TopSurface = 0
		orb.BottomSurface = 0
		orb.Anchored = true
		orb.CFrame = handlex.CFrame*CFrame.new(math.random(-2,2),math.random(-2,2),math.random(0,1))
		local a = Instance.new("Part",char)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = BrickColor.new("Alder")
		a.Material = "Neon"
		a.Transparency = 0.25
		a.Shape = "Cylinder"
		local ht = Instance.new("Part",char)
		ht.Name = "DirectionHit"	
		ht.Anchored = true
		ht.BrickColor = BrickColor.new("Alder")
		ht.CanCollide = false
		ht.Transparency = 1
		ht.Size = vt(0.1,0.1,0.1)
		CFuncs["Sound"].Create("rbxassetid://206049428", ht, 3, 1)
		CFuncs["Sound"].Create("rbxassetid://824687369", ht, 6, 1)
		CFuncs["Sound"].Create("rbxassetid://698224146", ht, 4, 1)
		CFuncs["Sound"].Create("rbxassetid://183763487", ht, 4, 1.1)
		a.CanCollide = false
		local ray = Ray.new(
			orb.CFrame.p,                           -- origin
			(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
		) 
		local ignore = char
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance,1,1)
		a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		ht.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
		sphere2(3,"Add",ht.CFrame,vt(1.25,1.25,1.25),0.35,0.35,0.35,BrickColor.new("Alder"))
		sphere2(4,"Add",ht.CFrame,vt(1.25,1.25,1.25),0.35,0.35,0.35,BrickColor.new("Alder"))
		MagniDamage(ht, 15, 70,95, 0, "Normal")
		for i = 0, 4 do
			slash(math.random(10,60)/10,5,true,"Round","Add","Out",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(40,80)/250,BrickColor.new("White"))
			sphere2(4,"Add",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,1,3),-0.015,1.5,-0.015,BrickColor.new("Alder"))
			local rsiz = math.random(30,60)
			sphereMK(math.random(2,4),0.75,"Add",ht.CFrame*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,BrickColor.new("Alder"),0)
		end
		a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
		local msh = Instance.new("SpecialMesh",a)
		msh.MeshType = "Cylinder"
		msh.Scale = vt(1,2,2)
		coroutine.resume(coroutine.create(function()
			for i = 0, 49 do
				swait()
				msh.Scale = msh.Scale - vt(0,0.04,0.04)
				a.Transparency = a.Transparency + 0.02
			end
			a:Destroy()
			ht:Destroy()
			orb:Destroy()
		end))
	end
	hum.WalkSpeed = storehumanoidWS
	attack = false
end

function Laserbeamy2()
	attack = true
	hum.WalkSpeed = 0
	CFuncs["Sound"].Create("rbxassetid://289315275", handlex, 7.5, 0.85)
	CFuncs["Sound"].Create("rbxassetid://1521621176", handlex, 5,1)
	CFuncs["Sound"].Create("rbxassetid://418302853", handlex, 6.5, 0.85)
	CFuncs["TimeSound"].Create("rbxassetid://184173042", handlex, 5, 1,0,2.75)
	CFuncs["Sound"].Create("rbxassetid://898407368", handlex, 1.75, 1.2)
	CFuncs["Sound"].Create("rbxassetid://1930016365", handlex, 1.75, 1.1)
	CFuncs["Sound"].Create("rbxassetid://1752639888", handlex, 1.5, 1)
	local efec = Instance.new("ParticleEmitter",handlex)
	efec.Texture = "rbxassetid://2109052855"
	efec.LightEmission = 1
	efec.Color = ColorSequence.new(BrickColor.new("Really red").Color)
	efec.Rate = 10
	efec.Lifetime = NumberRange.new(0.75)
	efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,5,0),NumberSequenceKeypoint.new(0.8,7.5,0),NumberSequenceKeypoint.new(1,0,0)})
	efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.25,0),NumberSequenceKeypoint.new(0.6,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
	efec.Drag = 5
	efec.LockedToPart = true
	efec.Rotation = NumberRange.new(-500,500)
	efec.VelocitySpread = 9000
	efec.Speed = NumberRange.new(0)
	efec.RotSpeed = NumberRange.new(-500,500)
	local efec2 = efec:Clone()
	efec2.LightEmission = 1
	efec2.Texture = "rbxassetid://2092248396"
	efec2.Parent = handlex
	efec2.Rate = 10
	efec2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,17.5,0),NumberSequenceKeypoint.new(0.5,15,0),NumberSequenceKeypoint.new(0.8,50,0),NumberSequenceKeypoint.new(1,100,0)})
	efec2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
	efec2.RotSpeed = NumberRange.new(-100,100)
	for i = 0,10,0.1 do
		swait()
		CamShakeAll(25,25,Character)
		actualrotationvalue = actualrotationvalue + 14
		handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-2,5)*angles(math.rad(-5),math.rad(60),math.rad(0)),.3)
		sphere2(5,"Add",handlex.CFrame,vt(4,4,0.1),0.005,0.005,0.005,BrickColor.new("Really red"))
		RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,2.5 + 0.5 * math.cos(sine / 32))* angles(math.rad(5),math.rad(0),math.rad(60)),0.5)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(-5),math.rad(-60)),.5)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(95), math.rad(0), math.rad(60)), 0.5)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-30)), 0.5)
		RH.C0=clerp(RH.C0,cf(1,-0.5 - 0.1 * math.cos(sine / 32),-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
		LH.C0=clerp(LH.C0,cf(-1,-0.8 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(22 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
	end
	local efec3 = Instance.new("ParticleEmitter",handlex)
	efec3.Texture = "rbxassetid://2109052855"
	efec3.LightEmission = 1
	efec3.Color = ColorSequence.new(BrickColor.new("Maroon").Color)
	efec3.Rate = 15
	efec3.Lifetime = NumberRange.new(1)
	efec3.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,25,0),NumberSequenceKeypoint.new(0.2,12.5,0),NumberSequenceKeypoint.new(0.6,62.5,0),NumberSequenceKeypoint.new(0.8,43.75,0),NumberSequenceKeypoint.new(1,5,0)})
	efec3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.25,0),NumberSequenceKeypoint.new(0.6,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
	efec3.Drag = 5
	efec3.LockedToPart = true
	efec3.Rotation = NumberRange.new(-500,500)
	efec3.VelocitySpread = 9000
	efec3.RotSpeed = NumberRange.new(-500,500)
	local efec4 = efec:Clone()
	efec4.LightEmission = 1
	efec4.Texture = "rbxassetid://2092248396"
	efec4.Parent = root
	efec4.Rate = 30
	efec4.Lifetime = NumberRange.new(1)
	efec4.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,10.9375,0),NumberSequenceKeypoint.new(0.5,9.375,0),NumberSequenceKeypoint.new(0.8,31.25,0),NumberSequenceKeypoint.new(1,62.5,0)})
	efec4.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
	efec4.Speed = NumberRange.new(0)
	efec4.RotSpeed = NumberRange.new(-100,100)

	sphere2(0.85,"Add",handlex.CFrame,vt(125,125,0),-5,-5,0,BrickColor.new("Really red"))
	sphere2(0.85,"Add",handlex.CFrame,vt(187.5,187.5,0),-7.5,-7.5,0,BrickColor.new("Maroon"))
	for i = 0,10,0.1 do
		swait()
		CamShakeAll(25,25,Character)
		actualrotationvalue = actualrotationvalue + 14
		handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-2,5)*angles(math.rad(-5),math.rad(60),math.rad(0)),.3)
		sphere2(5,"Add",handlex.CFrame,vt(4,4,0.1),0.005,0.005,0.005,BrickColor.new("Really red"))
		RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,2.5 + 0.5 * math.cos(sine / 32))* angles(math.rad(5),math.rad(0),math.rad(60)),0.5)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(-5),math.rad(-60)),.5)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(95), math.rad(0), math.rad(60)), 0.5)
		LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-30)), 0.5)
		RH.C0=clerp(RH.C0,cf(1,-0.5 - 0.1 * math.cos(sine / 32),-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
		LH.C0=clerp(LH.C0,cf(-1,-0.8 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(22 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
	end

	efec.Enabled = false
	efec2.Enabled = false
	efec3.Enabled = false
	efec4.Enabled = false
	game:GetService("Debris"):AddItem(efec, 5)
	game:GetService("Debris"):AddItem(efec2, 5)
	CFuncs["Sound"].Create("rbxassetid://919941001", handlex, 8, 1.1)
	sphere2(5,"Add",handlex.CFrame,vt(4,4,0.1),0.5,0.5,0.005,BrickColor.new("Really red"))
	sphere2(4,"Add",handlex.CFrame,vt(4,4,0.1),0.5,0.5,0.005,BrickColor.new("Really red"))
	sphere2(3,"Add",handlex.CFrame,vt(4,4,0.1),0.5,0.5,0.005,BrickColor.new("Really red"))
	for i = 0, 28 do
		slash(math.random(10,40)/10,5,true,"Round","Add","Out",handlex.CFrame*CFrame.Angles(math.rad(90 + math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(30,70)/250,BrickColor.new("Black"))
	end
	for i = 0, 96*2 do
		shakes(0.4,0.25)
		for i = 0,1,0.6 do
			swait()
			actualrotationvalue = actualrotationvalue + 100
			handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
			handlexweld.C1=clerp(handlexweld.C1,cf(0,-2,5)*angles(math.rad(-5),math.rad(60),math.rad(0)),.3)
			sphere2(5,"Add",handlex.CFrame,vt(4,4,0.1),0.005,0.005,0.005,BrickColor.new("Really red"))
			RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,2.5 + 0.5 * math.cos(sine / 32))* angles(math.rad(5),math.rad(0),math.rad(60)),0.5)
			Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(5),math.rad(-5),math.rad(-60)),.5)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(95), math.rad(0), math.rad(60)), 0.5)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10), math.rad(0), math.rad(-30)), 0.5)
			RH.C0=clerp(RH.C0,cf(1,-0.5 - 0.1 * math.cos(sine / 32),-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-0.8 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(22 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
		end
		local orb = Instance.new("Part", char)
		CFuncs["Sound"].Create("rbxassetid://1146690130", handlex, 2,1.25)
		orb.BrickColor = BrickColor.new("Really red")
		orb.CanCollide = false
		orb.FormFactor = 3
		orb.Name = "Ring"
		orb.Material = "Neon"
		orb.Size = Vector3.new(1, 1, 1)
		orb.Transparency = 1
		orb.TopSurface = 0
		orb.BottomSurface = 0
		orb.Anchored = true
		orb.CFrame = handlex.CFrame*CFrame.new(math.random(-2,2),math.random(-2,2),math.random(0,1))
		local a = Instance.new("Part",char)
		a.Name = "Direction"	
		a.Anchored = true
		a.BrickColor = BrickColor.new("Really red")
		a.Material = "Neon"
		a.Transparency = 0.25
		a.Shape = "Cylinder"
		local ht = Instance.new("Part",char)
		ht.Name = "DirectionHit"	
		ht.Anchored = true
		ht.BrickColor = BrickColor.new("Really red")
		ht.CanCollide = false
		ht.Transparency = 1
		ht.Size = vt(0.1,0.1,0.1)
		CFuncs["Sound"].Create("rbxassetid://206049428", ht, 3, 1)
		CFuncs["Sound"].Create("rbxassetid://824687369", ht, 6, 1)
		CFuncs["Sound"].Create("rbxassetid://698224146", ht, 4, 1)
		CFuncs["Sound"].Create("rbxassetid://183763487", ht, 4, 1.1)
		a.CanCollide = false
		local ray = Ray.new(
			orb.CFrame.p,                           -- origin
			(mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
		) 
		local ignore = char
		local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
		a.BottomSurface = 10
		a.TopSurface = 10
		local distance = (orb.CFrame.p - position).magnitude
		a.Size = Vector3.new(distance,1,1)
		a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance/2)
		ht.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, -distance)
		sphere2(3,"Add",ht.CFrame,vt(1.25*2,1.25*2,1.25*2),0.35,0.35,0.35,BrickColor.new("Really red"))
		sphere2(4,"Add",ht.CFrame,vt(1.25*2,1.25*2,1.25*2),0.35,0.35,0.35,BrickColor.new("Really red"))
		MagniDamage(ht, 12.5*2, 70,95, 0, "Normal")
		for i = 0, 4 do
			slash(math.random(10,60)/10,5,true,"Round","Add","Out",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01*2,0.01*2,0.01*2),math.random(40,80)/250,BrickColor.new("Black"))
			sphere2(4,"Add",ht.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,1,3),-0.015*2,1.5*2,-0.015,BrickColor.new("Really red"))
			local rsiz = math.random(30,60)
			sphereMK(math.random(2,4),0.75,"Add",ht.CFrame*CFrame.Angles(math.rad(90 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),rsiz/10,rsiz/10,rsiz/10,0,BrickColor.new("Really red"),0)
		end
		a.CFrame = a.CFrame*CFrame.Angles(0,math.rad(90),0)
		local msh = Instance.new("SpecialMesh",a)
		msh.MeshType = "Cylinder"
		msh.Scale = vt(1,2,2)
		coroutine.resume(coroutine.create(function()
			for i = 0, 49 do
				swait()
				msh.Scale = msh.Scale - vt(0,0.04,0.04)
				a.Transparency = a.Transparency + 0.02
			end
			a:Destroy()
			ht:Destroy()
			orb:Destroy()
		end))
	end
	hum.WalkSpeed = storehumanoidWS
	attack = false
end

local MAINRUINCOLOR = BrickColor.new("Really red")

function EndGROUND()
	attack = true
	hum.WalkSpeed = 0
	CFuncs["Sound"].Create("rbxassetid://838392947", root, 10, 1)
	CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
	local efec = Instance.new("ParticleEmitter",handlex)
	efec.Texture = "rbxassetid://2109052855"
	efec.LightEmission = 1
	efec.Color = ColorSequence.new(BrickColor.new("Really red").Color)
	efec.Rate = 10
	efec.Lifetime = NumberRange.new(0.75)
	efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,5,0),NumberSequenceKeypoint.new(0.8,7.5,0),NumberSequenceKeypoint.new(1,0,0)})
	efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.25,0),NumberSequenceKeypoint.new(0.6,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
	efec.Drag = 5
	efec.LockedToPart = true
	efec.Rotation = NumberRange.new(-500,500)
	efec.VelocitySpread = 9000
	efec.Speed = NumberRange.new(0)
	efec.RotSpeed = NumberRange.new(-500,500)
	local efec2 = efec:Clone()
	efec2.LightEmission = 1
	efec2.Texture = "rbxassetid://2092248396"
	efec2.Parent = handlex
	efec2.Rate = 10
	efec2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,17.5,0),NumberSequenceKeypoint.new(0.5,15,0),NumberSequenceKeypoint.new(0.8,50,0),NumberSequenceKeypoint.new(1,100,0)})
	efec2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
	efec2.RotSpeed = NumberRange.new(-100,100)
	for i = 0,3.5,0.1 do
		swait()
		CamShakeAll(25,10,char)
		slash(math.random(25,50)/10,5,true,"Round","Add","Out",handlex.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.01,0.1),-0.1,BrickColor.new("Really black"))
		actualrotationvalue = actualrotationvalue + 25
		handlexweld.C0=clerp(handlexweld.C0,cf(5,0,0)*angles(math.rad(45),math.rad(90),math.rad(30)),.05)
		handlexweld.C1=clerp(RW.C1,cf(0,0,0)*angles(math.rad(0),math.rad(90),math.rad(0)),.1)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),2.5 + 0.5 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-30 + 3 * math.cos(sine / 43)),math.rad(-16 - 5 * math.cos(sine / 52)),math.rad(45 + 9 * math.cos(sine / 45))),.1)
		LW.C0=clerp(LW.C0,cf(-1.35,1 + 0.025 * math.cos(sine / 45),-0.2)*angles(math.rad(148 - 2 * math.cos(sine / 51)),math.rad(0 - 4 * math.cos(sine / 64)),math.rad(22 - 2 * math.cos(sine / 45))),.1)
		RH.C0=clerp(RH.C0,cf(1,-0.5 - 0.1 * math.cos(sine / 32),-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
		LH.C0=clerp(LH.C0,cf(-1,-0.8 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(22 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
	end
	CFuncs["EchoSound"].Create("rbxassetid://1718412034", char, 1.5, 1,0,10,0.15,0.5,1)
	CFuncs["EchoSound"].Create("rbxassetid://1718412034", root, 10, 1,0,10,0.15,0.5,1)
	for i = 0,4,0.1 do
		swait()
		actualrotationvalue = actualrotationvalue + 25
		handlexweld.C0=clerp(handlexweld.C0,cf(5,4.3,-2)*angles(math.rad(0),math.rad(90),math.rad(0)),.1)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-3,5)*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		CamShakeAll(25,10,char)
		slash(math.random(25,50)/10,5,true,"Round","Add","Out",rarm.CFrame*CFrame.new(0,-6,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.01,0.1),-0.1,BrickColor.new("Really black"))
		RH.C0=clerp(RH.C0,cf(1,-0.5 - 0.1 * math.cos(sine / 32),-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
		LH.C0=clerp(LH.C0,cf(-1,-0.8 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(22 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,3.2 + 0.5 * math.cos(sine / 32))*angles(math.rad(-20),math.rad(0),math.rad(0)),.1)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(0)),.1)
		RW.C0=clerp(RW.C0,cf(1.45,0.7,0.1)*angles(math.rad(160),math.rad(-5),math.rad(-10)),.1)
		LW.C0=clerp(LW.C0,cf(-1.4,0.7,0.1)*angles(math.rad(160),math.rad(10),math.rad(10)),.1)
	end
	efec2.Enabled = false
	efec.Enabled = false
	CFuncs["Sound"].Create("rbxassetid://1368637781", root, 3,1)
	CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 1.1)
	CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 1)
	CFuncs["EchoSound"].Create("rbxassetid://824687369", root, 10, 1,0,10,0.25,0.5,1)
	CFuncs["EchoSound"].Create("rbxassetid://824687369", char, 2, 1,0,10,0.25,0.5,1)
	shakes(0.8,0.6)
	sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),1,0.01,1,MAINRUINCOLOR,MAINRUINCOLOR.Color)
	sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(10,1,10),2,0.01,2,MAINRUINCOLOR,MAINRUINCOLOR.Color)
	for i = 0, 24 do
		slash(math.random(15,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),vt(0.01,0.01,0.01),math.random(200,500)/250,BrickColor.new("Really black"))
	end
	local rrot = 0
	local xam = 1
	coroutine.resume(coroutine.create(function()
		for i = 0, 14 do
			swait()
			rrot = rrot + 40*xam
			xam = xam + 0.25
			local bonus = xam
			local xa = CreateParta(char,0.5,1,"Neon",BrickColor.random())
			xa.Anchored = true
			xa.Color = Color3.new(0,0,0)
			xa.CFrame = root.CFrame*CFrame.new(0,-3,-rrot/1.75)
			CreateMesh(xa,"Sphere",30*bonus,1,30*bonus)
			local xc = 0
			coroutine.resume(coroutine.create(function()
				for i = 0, 99 do
					swait()
					xc = xc + 0.01
					xa.Color = Color3.new(xc,0,0)
				end
				xa.Transparency = 1
				CFuncs["Sound"].Create("rbxassetid://331666100", xa, 5,0.75)
				MagniDamage(xa, 30*bonus, 78*bonus,99*bonus, 0, "Normal")
				for i = 0, 9 do
					slash(math.random(15,50)/10,5,true,"Round","Add","Out",xa.CFrame*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),vt(0.01*bonus,0.01,0.01*bonus),math.random(50,125)/250*bonus,BrickColor.new("Really black"))
				end
				for i = 0, 21 do
					PixelBlock(1,math.random(4,8*bonus),"Add",xa.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3*bonus,3*bonus,3*bonus,0.06*bonus,BrickColor.new("Maroon"),0)
				end
				block(3,"Add",xa.CFrame*CFrame.new(0,-10,0),vt(30*bonus,30*bonus,30*bonus),0.3,0.3,0.3,BrickColor.new("Maroon"),BrickColor.new("Maroon").Color)
				game:GetService("Debris"):AddItem(xa, 5)
				coroutine.resume(coroutine.create(function()
					shakes(1,0.4)
				end))
			end))
		end
	end))
	for i = 0,2,0.1 do
		swait()
		actualrotationvalue = actualrotationvalue + 0
		handlexweld.C0=clerp(handlexweld.C0,cf(5,1.5,-10)*angles(math.rad(0),math.rad(90),math.rad(0)),.3)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-3,5)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-25),math.rad(30)),.8)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.8)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,1.05)*angles(math.rad(30),math.rad(0),math.rad(0)),.8)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(0)),.8)
		RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(35),math.rad(-10),math.rad(30)),.8)
		LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(35),math.rad(10),math.rad(-30)),.8)
	end
	attack = false
	hum.WalkSpeed = storehumanoidWS
end


function uselessnuke()
	attack = true
	local vel = Instance.new("BodyPosition", root)
	vel.P = 25000
	vel.D = 1000
	vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
	vel.position = root.CFrame.p + vt(0,250,0)
	CFuncs["Sound"].Create("rbxassetid://1295446488", char, 1.5, 0.8)
	for i = 0, 49 do
		coroutine.resume(coroutine.create(function()
			slash(math.random(10,100)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.01,0.05),math.random(25,500)/250,BrickColor.new("White"))
		end))
	end
	for i = 0, 4, 0.1 do
		swait()
		RH.C0=clerp(RH.C0,cf(1,-0.35,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(-25)),.8)
		LH.C0=clerp(LH.C0,cf(-1,-0.45,-0.5)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1),math.rad(0),math.rad(25)),.8)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.8)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(35),math.rad(0),math.rad(0)),.8)
		RW.C0=clerp(RW.C0,cf(1.15,0.5,-0.5)*angles(math.rad(90),math.rad(0),math.rad(-57)),.8)
		LW.C0=clerp(LW.C0,cf(-1.15,0.5,-0.5)*angles(math.rad(83),math.rad(0),math.rad(58)),.8)
	end
	wait(2)
	local efec = Instance.new("ParticleEmitter",root)
	efec.Texture = "rbxassetid://2109052855"
	efec.LightEmission = 1
	efec.Color = ColorSequence.new(BrickColor.new("Pastel light blue").Color)
	efec.Rate = 15
	efec.Lifetime = NumberRange.new(1)
	efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,100,0),NumberSequenceKeypoint.new(0.2,50,0),NumberSequenceKeypoint.new(0.6,125,0),NumberSequenceKeypoint.new(0.8,175,0),NumberSequenceKeypoint.new(1,20,0)})
	efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.25,0),NumberSequenceKeypoint.new(0.6,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
	efec.Drag = 5
	efec.LockedToPart = true
	efec.Rotation = NumberRange.new(-500,500)
	efec.VelocitySpread = 9000
	efec.RotSpeed = NumberRange.new(-500,500)
	local efec2 = efec:Clone()
	efec2.LightEmission = 1
	efec2.Texture = "rbxassetid://2092248396"
	efec2.Parent = root
	efec2.Rate = 30
	efec2.Lifetime = NumberRange.new(1)
	efec2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,175,0),NumberSequenceKeypoint.new(0.5,150,0),NumberSequenceKeypoint.new(0.8,500,0),NumberSequenceKeypoint.new(1,1000,0)})
	efec2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
	efec2.Speed = NumberRange.new(0)
	efec2.RotSpeed = NumberRange.new(-100,100)
	sphere2(1,"Add",root.CFrame,vt(500,500,500),-10,-10,-10,BrickColor.new("Alder"))
	sphere2(1,"Add",root.CFrame,vt(750,750,750),-15,-15,-15,BrickColor.new("Pastel light blue"))
	CFuncs["LongSound"].Create("rbxassetid://1930483671", char, 10, 1)
	wait(2)
	shakes(3,7.2)
	CFuncs["Sound"].Create("rbxassetid://1368605755", char, 5, 1)
	CFuncs["Sound"].Create("rbxassetid://763718160", char, 2.5, 0.5)
	CFuncs["Sound"].Create("rbxassetid://763718160", char, 2.5, 0.25)
	CFuncs["Sound"].Create("rbxassetid://782353443", char, 5, 1)
	CFuncs["Sound"].Create("rbxassetid://782353443", char, 5, 0.75)
	CFuncs["LongSound"].Create("rbxassetid://782353443", char, 5, 0.5)
	CFuncs["LongSound"].Create("rbxassetid://782353443", char, 5, 0.25)
	CFuncs["Sound"].Create("rbxassetid://1664711478", char, 5, 1)
	CFuncs["Sound"].Create("rbxassetid://239000203", char, 5, 1)
	coroutine.resume(coroutine.create(function()
		for i = 0, 74, 0.1 do
			swait()
			MagniDamage(root, 1500000, 999999,99999999, 0, "Normal")
			coroutine.resume(coroutine.create(function()
				for i = 0, 2 do
					slash(math.random(10,40)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(250,2500)/250,BrickColor.new("White"))
				end
				slash(math.random(30,90)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.1,0.01,0.1),math.random(2,5)/250,BrickColor.new("Alder"))
				sphere2(10,"Add",root.CFrame,vt(30,100000,30),2.5,100,2.5,BrickColor.new("Alder"))
				sphere2(10,"Add",root.CFrame,vt(50,100000,50),3,100,3,BrickColor.new("Pastel light blue"))
				sphere2(10,"Add",root.CFrame,vt(10,10,10),5,5,5,BrickColor.new("Alder"))
				sphere2(10,"Add",root.CFrame,vt(10,10,10),10,10,10,BrickColor.new("Pastel light blue"))
			end))
		end
		vel:Destroy()
		attack = false
		efec.Enabled = false
		efec2.Enabled = false
		game:GetService("Debris"):AddItem(efec, 5)
		game:GetService("Debris"):AddItem(efec2, 5)
	end))
end

function DisortBomb()
	attack = true
	hum.WalkSpeed = 0
	chatfunc("TILL THIS END",BrickColor.new("Maroon").Color,"Inverted","Arcade",5)
	CFuncs["Sound"].Create("rbxassetid://838392947", root, 10, 1)
	CFuncs["Sound"].Create("rbxassetid://1368598393", root, 10, 1)
	local efec = Instance.new("ParticleEmitter",handlex)
	efec.Texture = "rbxassetid://2109052855"
	efec.LightEmission = 1
	efec.Color = ColorSequence.new(BrickColor.new("Really red").Color)
	efec.Rate = 10
	efec.Lifetime = NumberRange.new(0.75)
	efec.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,15,0),NumberSequenceKeypoint.new(0.8,30,0),NumberSequenceKeypoint.new(1,0,0)})
	efec.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.1,0.25,0),NumberSequenceKeypoint.new(0.6,0.25,0),NumberSequenceKeypoint.new(1,1,0)})
	efec.Drag = 5
	efec.LockedToPart = true
	efec.Rotation = NumberRange.new(-500,500)
	efec.VelocitySpread = 9000
	efec.Speed = NumberRange.new(0)
	efec.RotSpeed = NumberRange.new(-500,500)
	local efec2 = efec:Clone()
	efec2.LightEmission = 1
	efec2.Texture = "rbxassetid://2092248396"
	efec2.Parent = handlex
	efec2.Rate = 10
	efec2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,50,0),NumberSequenceKeypoint.new(0.5,60,0),NumberSequenceKeypoint.new(0.8,200,0),NumberSequenceKeypoint.new(1,400,0)})
	efec2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
	efec2.RotSpeed = NumberRange.new(-100,100)
	for i = 0,14,0.1 do
		swait()
		CamShakeAll(25,30,char)
		slash(math.random(25,50)/10,5,true,"Round","Add","Out",handlex.CFrame*CFrame.new(0,0,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.8,0.08,0.8),-0.8,BrickColor.new("Really black"))
		actualrotationvalue = actualrotationvalue + 25
		handlexweld.C0=clerp(handlexweld.C0,cf(7,4.3,-2)*angles(math.rad(0),math.rad(90),math.rad(0)),.1)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-3,5)*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),1.2 + 0.5 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-30 + 3 * math.cos(sine / 43)),math.rad(-16 - 5 * math.cos(sine / 52)),math.rad(145 + 9 * math.cos(sine / 45))),.1)
		LW.C0=clerp(LW.C0,cf(-1.2,1 + 0.025 * math.cos(sine / 45),-0.6)*angles(math.rad(25 - 2 * math.cos(sine / 51)),math.rad(0 - 4 * math.cos(sine / 64)),math.rad(87 - 2 * math.cos(sine / 45))),.1)
		RH.C0=clerp(RH.C0,cf(1,-0.5 - 0.1 * math.cos(sine / 32),-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
		LH.C0=clerp(LH.C0,cf(-1,-0.8 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(22 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
	end
	CFuncs["Sound"].Create("rbxassetid://159882584", char, 4, 1)
	CFuncs["Sound"].Create("rbxassetid://159882584", root, 10, 1)
	CFuncs["EchoSound"].Create("rbxassetid://159882584", char, 4, 1,0,10,0.15,0.5,1)
	CFuncs["EchoSound"].Create("rbxassetid://159882584", root, 10, 1,0,10,0.15,0.5,1)

	for i = 0,8,0.1 do
		swait()
		actualrotationvalue = actualrotationvalue + 25
		handlexweld.C0=clerp(handlexweld.C0,cf(5,4.3,-2)*angles(math.rad(0),math.rad(90),math.rad(0)),.1)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-3,5)*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		CamShakeAll(25,30,char)
		RH.C0=clerp(RH.C0,cf(1,-0.5 - 0.1 * math.cos(sine / 32),-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
		LH.C0=clerp(LH.C0,cf(-1,-0.8 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(22 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.25,1.5 + 0.5 * math.cos(sine / 32))*angles(math.rad(-20),math.rad(0),math.rad(0)),.1)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(0)),.1)
		RW.C0=clerp(RW.C0,cf(1.45,0.7,0.1)*angles(math.rad(160),math.rad(-5),math.rad(-10)),.1)
		LW.C0=clerp(LW.C0,cf(-1.4,0.7,0.1)*angles(math.rad(160),math.rad(10),math.rad(10)),.1)
	end
	CFuncs["Sound"].Create("rbxassetid://159882497", char, 8, 1)
	CFuncs["Sound"].Create("rbxassetid://159882497", root, 999, 1)
	CFuncs["EchoSound"].Create("rbxassetid://159882497", char, 2, 1,0,10,0.15,0.5,1)
	CFuncs["EchoSound"].Create("rbxassetid://159882497", root, 999, 1,0,10,0.15,0.5,1)

	efec2.Enabled = false
	efec.Enabled = false
	coroutine.resume(coroutine.create(function()
		wait(0.25)
		sphere2(1,"Add",root.CFrame,vt(500,500,500),-10,-10,-10,BrickColor.new("Really black"))
		sphere2(1,"Add",root.CFrame,vt(750,750,750),-15,-15,-15,BrickColor.new("Maroon"))
		CFuncs["Sound"].Create("rbxassetid://134854740", char, 3, 1)
		CFuncs["Sound"].Create("rbxassetid://157878578", char, 3, 0.5)
		CFuncs["Sound"].Create("rbxassetid://165970126", char, 2, 0.25)
		CFuncs["Sound"].Create("rbxassetid://167115397", char, 2, 1)
		CFuncs["Sound"].Create("rbxassetid://184173042", char, 4, 1.125)

		CFuncs["Sound"].Create("rbxassetid://1368605755", char, 4, 1)
		CFuncs["Sound"].Create("rbxassetid://763718160", char, 1.5, 0.5)
		CFuncs["Sound"].Create("rbxassetid://763718160", char, 1.5, 0.25)
		CFuncs["Sound"].Create("rbxassetid://782353443", char, 4, 1)
		CFuncs["Sound"].Create("rbxassetid://782353443", char, 4, 0.75)
		CFuncs["LongSound"].Create("rbxassetid://782353443", char, 4, 0.5)
		CFuncs["LongSound"].Create("rbxassetid://782353443", char, 4, 0.25)
		CFuncs["Sound"].Create("rbxassetid://1664711478", char, 4, 1)
		CFuncs["Sound"].Create("rbxassetid://239000203", char, 4, 1)
		coroutine.resume(coroutine.create(function()
			for i = 0, 42, 0.1 do
				swait()
				shakes(2,0.5)
				MagniDamage(root, 300, 10,25, 0, "Normal")
				coroutine.resume(coroutine.create(function()

					slash(math.random(10,40)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(250,2500)/250,BrickColor.new(math.random(0,1),0,0))

					sphere2(5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(10,10,10),5,5,5,BrickColor.new(math.random(0,1),0,0))
					sphere2(5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(10,10,10),1,35,1,BrickColor.new(math.random(0,1),0,0))
					sphere2(5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(10,10,10),0,50,0,BrickColor.new(math.random(0,1),0,0))
				end))
			end
			hum.WalkSpeed = storehumanoidWS
			attack = false
		end))
	end))
	for i = 0,2,0.1 do
		swait()
		actualrotationvalue = actualrotationvalue + 0
		handlexweld.C0=clerp(handlexweld.C0,cf(5,1.5,-10)*angles(math.rad(0),math.rad(90),math.rad(0)),.3)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-3,5)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		RH.C0=clerp(RH.C0,cf(1,-0.5,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-25),math.rad(30)),.8)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(1),math.rad(20)),.8)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.25,.35)*angles(math.rad(30),math.rad(0),math.rad(0)),.8)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(20),math.rad(0),math.rad(0)),.8)
		RW.C0=clerp(RW.C0,cf(1.45,0.5,0.1)*angles(math.rad(35),math.rad(-10),math.rad(30)),.8)
		LW.C0=clerp(LW.C0,cf(-1.4,0.5,0.1)*angles(math.rad(35),math.rad(10),math.rad(-30)),.8)
	end
end
----------------------------------- Abilities
local effectsss = Instance.new("Part", Player.Character["Head"])
effectsss.Size = Vector3.new(6,0.1,6)
effectsss.CanCollide = false
effectsss.Transparency = 1
local efec = Instance.new("ParticleEmitter",effectsss)
efec.Texture = "rbxassetid://243132757"
efec.LightEmission = 1
efec.Color = ColorSequence.new(BrickColor.new("Pastel light blue").Color)
efec.Rate = 40
efec.Lifetime = NumberRange.new(1)
efec.Drag = 0
efec.Size = NumberSequence.new(0.4)
efec.Transparency = NumberSequence.new(0.3)
efec.Speed = NumberRange.new(20)
efec.LockedToPart = false
efec.Rotation = NumberRange.new(0,0)
efec.VelocitySpread = 0
efec.RotSpeed = NumberRange.new(0,0)
efec.Enabled = false
efec.ZOffset = Vector3.new(10, 0, 0)
local weldsensor = Instance.new("Weld", effectsss)
weldsensor.Part0 = Player.Character["Head"]
weldsensor.Part1 = effectsss
weldsensor.C0 = weldsensor.C0 * CFrame.new(0,4,0) * CFrame.Angles(math.rad(-140),math.rad(0),math.rad(0))

local raining = false

function DepressedStomp()
	attack = true
	raining = true
	for i = 0, 2, 0.1 do
		swait()
		actualrotationvalue = actualrotationvalue + kan.PlaybackLoudness/100
		handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-1,-6.5)*angles(math.rad(115 + 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
		weldsensor.C0=clerp(weldsensor.C0,cf(0,4,2)*angles(math.rad(-140),math.rad(0),math.rad(0)),.1)
		RH.C0=clerp(RH.C0,cf(1,-0.25,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(20)),.2)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-20),math.rad(0),math.rad(0)),.2)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(27 - 8 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 15 * math.cos(sine / 58) - 7.5 * math.cos(sine / 43.5))),.1)
		RW.C0=clerp(RW.C0,cf(1.45,0.4 + 0.005 * math.cos(sine / 45),0)*angles(math.rad(0 + 6 * math.cos(sine / 74)),math.rad(8 - 5 * math.cos(sine / 53)),math.rad(0)),.1)
		LW.C0=clerp(LW.C0,cf(-1.45,0.4 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(0 - 7 * math.cos(sine / 73)),math.rad(2 - 4 * math.cos(sine / 55)),math.rad(0)),.1)
	end
	local effectsss = Instance.new("Part", Player.Character["Head"])
	effectsss.Size = Vector3.new(6,0.1,6)
	effectsss.CanCollide = false
	effectsss.Transparency = 1
	CFuncs["Sound"].Create("rbxassetid://374244545", root, 7.5, 1)
	coroutine.resume(coroutine.create(function()
		repeat
			swait(10)
			MagniDamage(root.CFrame,30,3,6,0,"Normal")
		until raining == false
	end))
	coroutine.resume(coroutine.create(function()
		while true do
			swait()
			effectsss.CFrame = root.CFrame*cf(math.random(-30,30),17,math.random(-30,30))*angles(math.rad(180),math.rad(0),math.rad(0))
		end
	end))
	local efec = Instance.new("ParticleEmitter",effectsss)
	efec.Texture = "rbxassetid://243132757"
	efec.LightEmission = 1
	efec.Color = ColorSequence.new(BrickColor.new("Pastel light blue").Color)
	efec.Rate = 120
	efec.Lifetime = NumberRange.new(0.5)
	efec.Drag = 0
	efec.Size = NumberSequence.new(0.4)
	efec.Transparency = NumberSequence.new(0.3)
	efec.Speed = NumberRange.new(40)
	efec.LockedToPart = false
	efec.Rotation = NumberRange.new(0,0)
	efec.VelocitySpread = 0
	efec.RotSpeed = NumberRange.new(0,0)
	efec.Enabled = true
	efec.ZOffset = Vector3.new(10, 0, 0)
	CFuncs["Sound"].Create("rbxassetid://438666141", root, 7.5,1)
	shakes(0.6,0.5)

	sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
	sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
	coroutine.resume(coroutine.create(function()
		wait(0.75)
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
		sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
		wait(0.75)
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
		sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
		wait(0.75)
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
		sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
		wait(0.75)
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
		sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
		wait(0.75)
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
		sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
		wait(0.75)
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
		sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
		wait(0.75)
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
		sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
		wait(0.75)
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
		sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
		wait(0.75)
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
		sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
		wait(0.75)
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
		sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
		wait(0.75)
		sphere2(1.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),0.5,0,0.5,BrickColor.new("Really blue"),BrickColor.new("Really blue").Color)
		sphere2(2.5,"Add",root.CFrame*CFrame.new(0,-2.9,0),vt(0.2,0.1,0.2),1,0,1,BrickColor.new("Navy blue"),BrickColor.new("Navy blue").Color)
	end))
	for i = 0, 2, 0.1 do
		swait()
		actualrotationvalue = actualrotationvalue + kan.PlaybackLoudness/100
		handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-1,-6.5)*angles(math.rad(95 + 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.3)
		weldsensor.C0=clerp(weldsensor.C0,cf(0,4,2)*angles(math.rad(-140),math.rad(0),math.rad(0)),.1)
		RH.C0=clerp(RH.C0,cf(1,-1,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
		LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(10)),.4)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(0)),.4)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(27 - 8 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 15 * math.cos(sine / 58) - 7.5 * math.cos(sine / 43.5))),.1)
		RW.C0=clerp(RW.C0,cf(1.45,0.4 + 0.005 * math.cos(sine / 45),0)*angles(math.rad(20 + 6 * math.cos(sine / 74)),math.rad(8 - 5 * math.cos(sine / 53)),math.rad(0)),.1)
		LW.C0=clerp(LW.C0,cf(-1.45,0.4 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(20 - 7 * math.cos(sine / 73)),math.rad(2 - 4 * math.cos(sine / 55)),math.rad(0)),.1)
	end
	attack = false
	wait(8)
	efec.Enabled = false
	wait(1)
	effectsss:Destroy()
	raining = false
end

local Sitt = false

function Relax()
	attack = true
	hum.WalkSpeed = 0
	for i = 0, 6, 0.1 do
		swait()
		actualrotationvalue = actualrotationvalue + kan.PlaybackLoudness/100
		handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-1,-6.5)*angles(math.rad(95 + 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.3)
		weldsensor.C0=clerp(weldsensor.C0,cf(0,4,2)*angles(math.rad(-140),math.rad(0),math.rad(0)),.1)
		RH.C0=clerp(RH.C0,cf(1,-0.75 - 0.05 * math.cos(sine / 32),-0.65)*angles(math.rad(15),math.rad(90),math.rad(0))*angles(math.rad(15),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.06)
		LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),-0.75)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-15),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(57.5 + 2 * math.cos(sine / 32))),.06)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),-0.85 + 0.05 * math.cos(sine / 32))*angles(math.rad(15 - 2 * math.cos(sine / 32)),math.rad(15),math.rad(0 - 1 * math.cos(sine / 44))),.06)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(27 - 8 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 15 * math.cos(sine / 58) - 7.5 * math.cos(sine / 43.5))),.06)
		RW.C0=clerp(RW.C0,cf(1.45,0.4 + 0.005 * math.cos(sine / 45),0)*angles(math.rad(90 + 6 * math.cos(sine / 74)),math.rad(8 - 5 * math.cos(sine / 53)),math.rad(-55)),.06)
		LW.C0=clerp(LW.C0,cf(-1.45,0.4 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(0 - 7 * math.cos(sine / 73)),math.rad(2 - 4 * math.cos(sine / 55)),math.rad(-55)),.06)
	end
	Sitt = true
	repeat
		swait()
		actualrotationvalue = actualrotationvalue + kan.PlaybackLoudness/100
		handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-1,-6.5)*angles(math.rad(75 + 5 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.3)
		weldsensor.C0=clerp(weldsensor.C0,cf(0,4,2)*angles(math.rad(-140),math.rad(0),math.rad(0)),.1)
		RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-75 - 2 * math.cos(sine / 32))),.04)
		LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),-0.75)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(75 + 2 * math.cos(sine / 32))),.04)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),-1.5 + 0.05 * math.cos(sine / 32))*angles(math.rad(15 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.04)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(27 - 8 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 15 * math.cos(sine / 58) - 7.5 * math.cos(sine / 43.5))),.04)
		RW.C0=clerp(RW.C0,cf(1,0.4 + 0.005 * math.cos(sine / 45),-0.65)*angles(math.rad(75 + 6 * math.cos(sine / 74)),math.rad(8 - 5 * math.cos(sine / 53)),math.rad(-91 + 4 * math.cos(sine / 47))),.04)
		LW.C0=clerp(LW.C0,cf(-1,0.4 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(75 - 7 * math.cos(sine / 73)),math.rad(2 - 4 * math.cos(sine / 55)),math.rad(86 - 7 * math.cos(sine / 65))),.04)
	until Sitt == false
	for i = 0, 6, 0.1 do
		swait()
		actualrotationvalue = actualrotationvalue + kan.PlaybackLoudness/100
		handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-1,-6.5)*angles(math.rad(95 + 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.3)
		weldsensor.C0=clerp(weldsensor.C0,cf(0,4,2)*angles(math.rad(-140),math.rad(0),math.rad(0)),.1)
		RH.C0=clerp(RH.C0,cf(1,-0.75 - 0.05 * math.cos(sine / 32),-0.65)*angles(math.rad(15),math.rad(90),math.rad(0))*angles(math.rad(15),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.06)
		LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),-0.75)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(15),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(57.5 + 2 * math.cos(sine / 32))),.06)
		RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),-0.85 + 0.05 * math.cos(sine / 32))*angles(math.rad(15 - 2 * math.cos(sine / 32)),math.rad(15),math.rad(0 - 1 * math.cos(sine / 44))),.06)
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(27 - 8 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 15 * math.cos(sine / 58) - 7.5 * math.cos(sine / 43.5))),.06)
		RW.C0=clerp(RW.C0,cf(1.1,0.4 + 0.005 * math.cos(sine / 45),-0.35)*angles(math.rad(90 + 6 * math.cos(sine / 74)),math.rad(8 - 5 * math.cos(sine / 53)),math.rad(-55)),.06)
		LW.C0=clerp(LW.C0,cf(-1.45,0.4 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(0 - 7 * math.cos(sine / 73)),math.rad(2 - 4 * math.cos(sine / 55)),math.rad(-25)),.06)
	end
	hum.WalkSpeed = storehumanoidWS
	attack = false
end


-------------------------------------

Humanoid.Animator.Parent = nil

-------------------------------------
ModeOfGlitch = 1
local attacktype = 1
local player = game.Players.LocalPlayer


mouse = player:GetMouse()
mouse.Button1Down:connect(function()
	if attack == false and attacktype == 1 then
		attacktype = 2
		--attackone()
	elseif attack == false and attacktype == 2 then
		attacktype = 3
		--attacktwo()
	elseif attack == false and attacktype == 3 then
		attacktype = 1
		--attackthree()
	elseif attack == false and attacktype == 4 then
		attacktype = 1
		--attackfour()
	end
end)
mouse.KeyDown:connect(function(k)
	if k == "e" and attack == false and ModeOfGlitch ~= 2 then
		ModeOfGlitch = 2
		new = 2471149989
		storehumanoidWS = 55
		hum.WalkSpeed = 55
		for i,v in pairs(colorizermod:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Really red")
			end
		end
		imgl2.ImageColor3 = BrickColor.new("Bright red").Color
		techc.ImageColor3 = BrickColor.new("Bright red").Color
		circl.ImageColor3 = BrickColor.new("Really red").Color
		circl2.ImageColor3 = BrickColor.new("Bright red").Color
		imgl2b.ImageColor3 = BrickColor.new("Really red").Color
		ned.TextColor3 = BrickColor.new("Black").Color
		ned.TextStrokeColor3 = BrickColor.new("Really red").Color
		ned.Text = MAYHEM
		MAINRUINCOLOR = BrickColor.new("Maroon")
		kan.PlaybackSpeed = 1.01
		kan.Pitch = 0.99
		kan.SoundId = "rbxassetid://2471149989"
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		FACEid = 179693472
		refec.Color = ColorSequence.new(BrickColor.new("Bright red").Color)
		refec2.Color = refec.Color
		refec3.Color = refec.Color
		efec.Enabled = false
	end

	if k == "l" and attack == false and ModeOfGlitch == 2 then
		ModeOfGlitch = 8
		new = 1182934124
		storehumanoidWS = 25
		hum.WalkSpeed = 25
		for i,v in pairs(colorizermod:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Really black")
			end
		end
		imgl2.ImageColor3 = BrickColor.new("Black").Color
		techc.ImageColor3 = BrickColor.new("Black").Color
		circl.ImageColor3 = BrickColor.new("Really black").Color
		circl2.ImageColor3 = BrickColor.new("Black").Color
		imgl2b.ImageColor3 = BrickColor.new("Really black").Color
		ned.TextColor3 = BrickColor.new("Really black").Color
		ned.TextStrokeColor3 = BrickColor.new("Black").Color
		ned.Text = "LOST DEMON"
		MAINRUINCOLOR = BrickColor.new("Really black")
		kan.PlaybackSpeed = 1.01
		kan.TimePosition = 0
		kan.Pitch = 0.99
		kan.SoundId = "rbxassetid://1182934124"
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		FACEid = 0
		refec.Color = ColorSequence.new(BrickColor.new("Black").Color)
		refec2.Color = refec.Color
		refec3.Color = refec.Color
		efec.Enabled = false
	end

	if k == "r" and attack == false and ModeOfGlitch ~= 3 then
		ModeOfGlitch = 3
		new = 2165256309
		storehumanoidWS = 55
		hum.WalkSpeed = 55
		for i,v in pairs(colorizermod:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("White")
			end
		end
		imgl2.ImageColor3 = BrickColor.new("White").Color
		techc.ImageColor3 = BrickColor.new("White").Color
		circl.ImageColor3 = BrickColor.new("Black").Color
		circl2.ImageColor3 = BrickColor.new("White").Color
		imgl2b.ImageColor3 = BrickColor.new("Black").Color
		ned.TextColor3 = BrickColor.new("Black").Color
		ned.TextStrokeColor3 = BrickColor.new("White").Color
		ned.Text = "PEACE"
		MAINRUINCOLOR = BrickColor.new("White")
		kan.PlaybackSpeed = 1.01
		kan.Pitch = 0.99
		kan.SoundId = "rbxassetid://2165256309"
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		FACEid = 2550404747
		refec.Color = ColorSequence.new(BrickColor.new("Black").Color)
		refec2.Color = refec.Color
		refec3.Color = refec.Color
		efec.Enabled = false
	end

	--for you to do red <3 vvvvvvvvvvvvvvv

	if k == "u" and attack == false and ModeOfGlitch ~= 5 then
		ModeOfGlitch = 5
		new = 1138145518
		storehumanoidWS = 20
		hum.WalkSpeed = 20
		ned.Text = "INSANITY"
		kan.PlaybackSpeed = 1.01
		kan.Pitch = 0.99
		kan.SoundId = "rbxassetid://1138145518"
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		FACEid = 295421997
		efec.Enabled = false
	end

	if k == "l" and attack == false and ModeOfGlitch == 5 then
		ModeOfGlitch = 10
		new = 2116461106
		storehumanoidWS = 35
		hum.WalkSpeed = 35
		ned.Text = "Desorted"
		kan.PlaybackSpeed = 1.01
		kan.TimePosition = 0
		kan.Pitch = 0.96
		kan.SoundId = "rbxassetid://2116461106"
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		FACEid = 0
		efec.Enabled = false
	end

	if k == "t" and attack == false and ModeOfGlitch ~= 7 then
		ModeOfGlitch = 7
		new = 2483763576
		storehumanoidWS = 55
		hum.WalkSpeed = 55
		for i,v in pairs(colorizermod:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Baby blue")
			end
		end
		imgl2.ImageColor3 = BrickColor.new("Pink").Color
		techc.ImageColor3 = BrickColor.new("Pink").Color
		circl.ImageColor3 = BrickColor.new("Baby blue").Color
		circl2.ImageColor3 = BrickColor.new("Pink").Color
		imgl2b.ImageColor3 = BrickColor.new("Baby blue").Color
		ned.TextColor3 = BrickColor.new("Baby blue").Color
		ned.TextStrokeColor3 = BrickColor.new("Pink").Color
		ned.Text = "Virsualy"
		MAINRUINCOLOR = BrickColor.new("Pink")
		kan.PlaybackSpeed = 1.01
		kan.Pitch = 0.99
		kan.SoundId = "rbxassetid://2483763576"
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		FACEid = 22828283
		refec.Color = ColorSequence.new(BrickColor.new("Pink").Color)
		refec2.Color = refec.Color
		refec3.Color = refec.Color
		efec.Enabled = false
	end

	if k == "l" and attack == false and ModeOfGlitch == 7 then
		ModeOfGlitch = 9
		new = 737130590
		storehumanoidWS = 18
		hum.WalkSpeed = 18
		for i,v in pairs(colorizermod:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Baby blue")
			end
		end
		imgl2.ImageColor3 = BrickColor.new("Pink").Color
		techc.ImageColor3 = BrickColor.new("Pink").Color
		circl.ImageColor3 = BrickColor.new("Baby blue").Color
		circl2.ImageColor3 = BrickColor.new("Pink").Color
		imgl2b.ImageColor3 = BrickColor.new("Baby blue").Color
		ned.TextColor3 = BrickColor.new("Baby blue").Color
		ned.TextStrokeColor3 = BrickColor.new("Pink").Color
		ned.Text = "Remix God"
		MAINRUINCOLOR = BrickColor.new("Gold")
		kan.PlaybackSpeed = 1.01
		kan.Pitch = 0.99
		kan.SoundId = "rbxassetid://737130590"
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		FACEid = 226216895
		refec.Color = ColorSequence.new(BrickColor.new("Pink").Color)
		refec2.Color = refec.Color
		refec3.Color = refec.Color
		efec.Enabled = false
	end

	--for you to do red <3 ^^^^^^^^^^^^^^

	if k == "q" and attack == false and ModeOfGlitch ~= 1 then
		--normalmog() ---Disabled due to crashing... only in VSB
		ModeOfGlitch = 1
		new = 923445685
		storehumanoidWS = 16
		hum.WalkSpeed = 16
		for i,v in pairs(colorizermod:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Alder")
			end
		end
		imgl2.ImageColor3 = BrickColor.new("Pastel light blue").Color
		techc.ImageColor3 = BrickColor.new("Pastel light blue").Color
		circl.ImageColor3 = BrickColor.new("Alder").Color
		circl2.ImageColor3 = BrickColor.new("Pastel light blue").Color
		imgl2b.ImageColor3 = BrickColor.new("Alder").Color
		ned.TextColor3 = BrickColor.new("Pastel light blue").Color
		ned.TextStrokeColor3 = BrickColor.new("Alder").Color
		ned.Text = "SYNTHEZIZER"
		kan.PlaybackSpeed = 1.01
		kan.Pitch = 1.01
		kan.SoundId = "rbxassetid://923445685"
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		FACEid = 20418518
		refec.Color = ColorSequence.new(BrickColor.new("Alder").Color)
		refec2.Color = refec.Color
		refec3.Color = refec.Color
		efec.Enabled = false
	end

	if k == "y" and attack == false and ModeOfGlitch ~= 4 then
		ModeOfGlitch = 4
		new = 2404024634
		storehumanoidWS = 10
		hum.WalkSpeed = 10
		for i,v in pairs(colorizermod:GetChildren()) do
			if v:IsA("Part") then
				v.BrickColor = BrickColor.new("Pink")
			end
		end
		imgl2.ImageColor3 = BrickColor.new("Pink").Color
		techc.ImageColor3 = BrickColor.new("Pink").Color
		circl.ImageColor3 = BrickColor.new("Pink").Color
		circl2.ImageColor3 = BrickColor.new("Pink").Color
		imgl2b.ImageColor3 = BrickColor.new("Pink").Color
		ned.TextColor3 = BrickColor.new("Pink").Color
		ned.TextStrokeColor3 = BrickColor.new("Pink").Color
		ned.Text = "DEPRESSED"
		kan.PlaybackSpeed = 1.01
		kan.Pitch = 0.99
		kan.SoundId = "rbxassetid://2785161136"
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		MAINRUINCOLOR = BrickColor.new("Pink")
		FACEid = 1593455410
		refec.Color = ColorSequence.new(BrickColor.new("Pink").Color)
		refec2.Color = refec.Color
		refec3.Color = refec.Color
		efec.Enabled = true
	end

	if k == "p" and attack == false and ModeOfGlitch ~= 6 then
		ModeOfGlitch = 6
		new = 1033438052
		storehumanoidWS = 75
		hum.WalkSpeed = 75
		ned.Text = "RAINBOW"
		kan.PlaybackSpeed = 1.01
		kan.Pitch = 0.99
		kan.SoundId = "rbxassetid://1033438052"
		kan.Looped = true
		kan.Parent = char
		kan:Resume()
		FACEid = 21635489
		efec.Enabled = false
	end

	if (ModeOfGlitch == 4 and attack == false) or Sitt == true then
		if k == "b" then
			if Sitt == false then
				Relax()
			elseif Sitt == true then
				Sitt = false
			end
		end
	end

	if k == "z" and attack == false and ModeOfGlitch == 1 then
		Laserbeamy()
	end
	if k == "x" and attack == false and ModeOfGlitch == 2 then
		EndGROUND()
	end
	if k == "x" and attack == false and ModeOfGlitch == 10 then
		DisortBomb()
	end
	if k == "x" and ModeOfGlitch == 9 and new == 737130590 then
		new = 668004348
		kan.SoundId = "rbxassetid://668004348"
	elseif k == "x" and ModeOfGlitch == 9 and new == 668004348 then
		new = 405474501
		kan.SoundId = "rbxassetid://405474501"
	elseif k == "x" and ModeOfGlitch == 9 and new == 405474501 then
		new = 2080539455
		kan.SoundId = "rbxassetid://2080539455"
	elseif k == "x" and ModeOfGlitch == 9 and new == 2080539455 then
		new = 302040029
		kan.SoundId = "rbxassetid://302040029"
	elseif k == "x" and ModeOfGlitch == 9 and new == 302040029 then
		new = 737130590
		kan.SoundId = "rbxassetid://2294033833"
	end
	if k == "x" and attack == false and ModeOfGlitch == 4 and raining == false then
		DepressedStomp()
	end
	if k == "z" and attack == false and ModeOfGlitch == 2 then
		Laserbeamy2()
	end
	if k == "m" and attack == false then
		uselessnuke()
	end
end)
Humanoid.Name = "SYNTHEZ"
Humanoid.MaxHealth = math.huge
Humanoid.Health = math.huge
Instance.new("ForceField",char).Visible = false
kan.PlaybackSpeed = 1.01
kan.Pitch = 1.01
kan.SoundId = "rbxassetid://923445685"
kan.Looped = true
kan.Parent = char
kan:Resume()
idleanim=.4

coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if ModeOfGlitch == 5 then
			for i,v in pairs(colorizermod:GetChildren()) do
				if v:IsA("Part") then
					v.Color = BrickColor.Random().Color
					imgl2.ImageColor3 = BrickColor.Random().Color
					techc.ImageColor3 = BrickColor.Random().Color
					circl.ImageColor3 = BrickColor.Random().Color
					circl2.ImageColor3 = BrickColor.Random().Color
					imgl2b.ImageColor3 = BrickColor.Random().Color
					ned.TextColor3 = BrickColor.Random().Color
					ned.TextStrokeColor3 = BrickColor.Random().Color
					refec.Color = ColorSequence.new(BrickColor.Random().Color)
					refec2.Color = refec.Color
					refec3.Color = refec.Color
				end
			end
		end
	end
end))

plr.ChildRemoved:connect(function(removed)
	if removed.Name == "kan" then
		kan = Instance.new("Sound", plr)
		kan.Volume = 1
		kan.Looped = true
		kan.Pitch = 1
		kan.Name = "kan"
		kan.SoundId = "rbxassetid://"..new
		kan:Play()
	end
end)
coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if ModeOfGlitch == 7 and kan.PlaybackLoudness >= 150 then
			swait()
			sphere2(6,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,1,1),0.1 + kan.PlaybackLoudness/500,0,0.1 + kan.PlaybackLoudness/500,MAINRUINCOLOR)
		end
	end
end))
coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if ModeOfGlitch == 2 or ModeOfGlitch == 3 and ModeOfGlitch ~= 7 then
			swait(2.5)
			sphereMK(5,math.random(8,14)/45,"Add",root.CFrame*CFrame.new(math.random(-15,15),-10,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.75,0.75,20,-0.0075,MAINRUINCOLOR,0)

		elseif ModeOfGlitch == 7 then
			swait(6.5 - kan.PlaybackLoudness/50)
			sphereMK(1 + kan.PlaybackLoudness/75,math.random(8,14)/45,"Add",root.CFrame*CFrame.new(math.random(-15 - kan.PlaybackLoudness/75,15 + kan.PlaybackLoudness/75),-10,math.random(-15 - kan.PlaybackLoudness/75,15 + kan.PlaybackLoudness/75))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.75,0.75,20,-0.0075,MAINRUINCOLOR,0)
		elseif ModeOfGlitch == 9 and kan.PlaybackLoudness >= 50 then
			swait(20 - kan.PlaybackLoudness/50)
			sphere2(4,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,1,1),0.25,0,0.25,MAINRUINCOLOR)
			if kan.PlaybackLoudness >= 0 then
				RH.C0=clerp(RH.C0,cf(1,-0.6 - 0.1 * math.cos(sine / 15),-0.3)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
			end
			if kan.PlaybackLoudness >= 200 then
				RH.C0=clerp(RH.C0,cf(1,-1.3 - 0.1 * math.cos(sine / 15),-0.3)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
				CameraEnshaking(1,3)
				for i = 0, 4 do
					sphereMK(5,math.random(15,35)/150,"Add",root.CFrame*CFrame.new(math.random(-15,15),-10,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),1,1,20,-0.01,MAINRUINCOLOR.Color,0)
				end
				sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,1,1),0.5,0,0.5,MAINRUINCOLOR)
			end
			local notsp = Instance.new("Part", char)
			notsp.CanCollide = false
			notsp.FormFactor = 3
			notsp.Name = "Ring"
			notsp.Material = "Neon"
			notsp.Size = Vector3.new(10, 1, 10)
			if kan.PlaybackLoudness >= 300 then
				notsp.Size = Vector3.new(25, 1, 25)
			end
			notsp.Transparency = 1
			notsp.TopSurface = 0
			notsp.BottomSurface = 0
			notsp.Anchored = true
			notsp.CFrame = root.CFrame*CFrame.new(0,-3,0)	
		end
	end
end))

coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if ModeOfGlitch == 9 or ModeOfGlitch == 66666666 or ModeOfGlitch == 8889 or ModeOfGlitch == 1264532489 or ModeOfGlitch == 55469696922 or ModeOfGlitch == 4367677813 or ModeOfGlitch == 9999999921111 or ModeOfGlitch == 999999999556 then
			sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,MAINRUINCOLOR,0)
		end
		if ModeOfGlitch == 6 then
			sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,BrickColor.new(r / 255, g / 255, b / 255),0)
		end
		if ModeOfGlitch == 8 then
			sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,BrickColor.new("Really black"),0)
		end
		if ModeOfGlitch == 10 then
			sphereMK(7.5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-40,40),-10,math.random(-40,40))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,MAINRUINCOLOR,0)
		end
		if ModeOfGlitch == 64912 then
			sphereMK(7,math.random(1,10)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,MAINRUINCOLOR,0)
		end
		if ModeOfGlitch == 5555 then
			sphereMK(5,math.random(8,14)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.25,0.25,7.5,-0.0025,MAINRUINCOLOR,0)
		end
	end
end))

coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if ModeOfGlitch == 10 and attack == false then
			for i,v in pairs(colorizermod:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r / 600, 0, 0)
					imgl2.ImageColor3 = Color3.new(r / 600, 0, 0)
					techc.ImageColor3 = Color3.new(r / 600, 0, 0)
					circl.ImageColor3 = Color3.new(r2 / 600, 0, 0)
					circl2.ImageColor3 = Color3.new(r2 / 600, 0, 0)
					imgl2b.ImageColor3 = Color3.new(r / 600, 0, 0)
					ned.TextColor3 = Color3.new(r / 600, 0, 0)
					ned.TextStrokeColor3 = Color3.new(r2 / 600, 0, 0)
					refec.Color = ColorSequence.new(Color3.new(r / 600, 0, 0))
					refec2.Color = refec.Color
					refec3.Color = refec.Color
					MAINRUINCOLOR = BrickColor.new(r / 600, 0, 0)
				end
			end
		elseif ModeOfGlitch == 10 and attack == true then
			for i,v in pairs(colorizermod:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r / 75, 0, 0)
					imgl2.ImageColor3 = Color3.new(r / 75, 0, 0)
					techc.ImageColor3 = Color3.new(r / 75, 0, 0)
					circl.ImageColor3 = Color3.new(r2 / 75, 0, 0)
					circl2.ImageColor3 = Color3.new(r2 / 75, 0, 0)
					imgl2b.ImageColor3 = Color3.new(r / 75, 0, 0)
					ned.TextColor3 = Color3.new(r / 75, 0, 0)
					ned.TextStrokeColor3 = Color3.new(r2 / 75, 0, 0)
					refec.Color = ColorSequence.new(Color3.new(r / 75, 0, 0))
					refec2.Color = refec.Color
					refec3.Color = refec.Color
					MAINRUINCOLOR = BrickColor.new(r / 75, 0, 0)
				end
			end
		end
	end
end))
coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if ModeOfGlitch == 6 then
			for i,v in pairs(colorizermod:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(r / 255, g / 255, b / 255)
					imgl2.ImageColor3 = Color3.new(r / 255, g / 255, b / 255)
					techc.ImageColor3 = Color3.new(r / 255, g / 255, b / 255)
					circl.ImageColor3 = Color3.new(r / 255, g / 255, b / 255)
					circl2.ImageColor3 = Color3.new(r / 255, g / 255, b / 255)
					imgl2b.ImageColor3 = Color3.new(r / 255, g / 255, b / 255)
					ned.TextColor3 = Color3.new(r / -255, g / -255, b / -255)
					ned.TextStrokeColor3 = Color3.new(r / 255, g / 255, b / 255)
					refec.Color = ColorSequence.new(Color3.new(r / 255, g / 255, b / 255))
					refec2.Color = refec.Color
					refec3.Color = refec.Color

				end
			end
		end
	end
end))

coroutine.resume(coroutine.create(function()
	while true do
		swait()
		if ModeOfGlitch == 9 then
			for i,v in pairs(colorizermod:GetChildren()) do
				if v:IsA("Part") then
					v.Color = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
					imgl2.ImageColor3 = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
					techc.ImageColor3 = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
					circl.ImageColor3 = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
					circl2.ImageColor3 = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
					imgl2b.ImageColor3 = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
					ned.TextColor3 = Color3.new(0,0,0)
					ned.TextStrokeColor3 = Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0)
					refec.Color = ColorSequence.new(Color3.new(0 +  kan.PlaybackLoudness/100,0 +  kan.PlaybackLoudness/100,0))
					refec2.Color = refec.Color
					refec3.Color = refec.Color
				end
			end
		end
	end
end))

local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 60)
while true do
	local WALKSPEEDVALUE2 = 12 / (hum.WalkSpeed / 16)
	if mutedtog == false then
		kan.Volume = 1.1
	elseif mutedtog == true then
		kan.Volume = 0
	end
	actualrotationvalue = actualrotationvalue + 1
	techc.Rotation = techc.Rotation + 1
	circl.Rotation = circl.Rotation - kan.PlaybackLoudness/100 - 1
	circl2.Rotation = circl2.Rotation + kan.PlaybackLoudness/75 + 1
	imgl2.Rotation = imgl2.Rotation - kan.PlaybackLoudness/75 + 1
	imgl2b.Rotation = imgl2b.Rotation + kan.PlaybackLoudness/50 - 1
	ned.Rotation = 0 - 2 * math.cos(sine / 24)
	ned.Position = UDim2.new(0.7,0 - 10 * math.cos(sine / 32),0.8,0 - 10 * math.cos(sine / 45))
	CameraManager()
	swait()
	sine = sine + change
	rotingweld.C0=clerp(rotingweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(actualrotationvalue + 750 * math.cos(sine / 1000))),.3)
	rotingweld2.C0=clerp(rotingweld2.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(-actualrotationvalue - 750 * math.cos(sine / 1000))),.3)
	if attack == false and ModeOfGlitch ~= 10 then
		hum.CameraOffset = vt(0 +  0.05 * math.cos(sine / 32),0  -  0.05 * math.cos(sine / 46),0 -  0.05 * math.cos(sine / 57))
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-2,-2.05)*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		handlexweld.C0=clerp(handlexweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),0 + 0.25 * math.cos(sine / 57))*angles(math.rad(0 + 5 * math.cos(sine / 55)),math.rad(0 + 5 * math.cos(sine / 46)),math.rad(0 + 5 * math.cos(sine / 32))),.1)
	elseif attack == false and ModeOfGlitch == 10 then
		hum.CameraOffset = vt(0 +  0.1 * math.cos(sine / 32),0  -  0.1 * math.cos(sine / 46),0 -  0.1 * math.cos(sine / 57))
		actualrotationvalue = actualrotationvalue + 1 + kan.PlaybackLoudness/100
		handlexweld.C1=clerp(handlexweld.C1,cf(0,-2,-2.05)*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
		handlexweld.C0=clerp(handlexweld.C0,cf(0 + 0.25 * math.cos(sine / 63),0 + 0.25 * math.cos(sine / 70),0 + 0.25 * math.cos(sine / 57))*angles(math.rad(0 + 7.5 * math.cos(sine / 55)),math.rad(0 + 7.5 * math.cos(sine / 46)),math.rad(0 + 7.5 * math.cos(sine / 32))),.1)
	end
	local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
	local velderp=RootPart.Velocity.y
	hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
	coroutine.resume(coroutine.create(function()
		if ModeOfGlitch == 2 or ModeOfGlitch == 10 or ModeOfGlitch == 8 or ModeOfGlitch == 3 or ModeOfGlitch == 7 then
			if hitfloor ~= nil then
				effar.Enabled = true
				effar.Color = ColorSequence.new(imgl2b.ImageColor3)
			elseif hitfloor == nil then
				effar.Enabled = false
			end
		elseif ModeOfGlitch ~= 2 and ModeOfGlitch ~= 10 and ModeOfGlitch ~= 8 and ModeOfGlitch ~= 3 and ModeOfGlitch ~= 7 then
			effar.Enabled = false
		end
	end))
	if Head:FindFirstChild("face") then
		Head.face.Texture = "rbxassetid://"..FACEid
	end

	coroutine.resume(coroutine.create(function()
		if ModeOfGlitch == 10 then
			if hitfloor ~= nil then
				slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.01,0.002,0.01),math.random(5,10)/250,BrickColor.new("White"))
			end
		end
	end))

	coroutine.resume(coroutine.create(function()
		if ModeOfGlitch == 5 or ModeOfGlitch == 8 or ModeOfGlitch == 10 then
			if hitfloor ~= nil then
				if ModeOfGlitch ~= 5 and ModeOfGlitch ~= 10 then
					sphereMK(2,math.random(5,20)/45,"Add",root.CFrame*CFrame.new(math.random(-12,12),-10,math.random(-12,12))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.75,0.75,0.75,0,MAINRUINCOLOR,0)
				elseif ModeOfGlitch == 10 then
					sphereMK(2,math.random(5,30)/45,"Add",root.CFrame*CFrame.new(math.random(-40,40),-10,math.random(-40,40))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.75,0.75,0.75,0,MAINRUINCOLOR,0)
				elseif ModeOfGlitch == 5 then
					sphereMK(4,math.random(2.5,17.5)/45,"Add",root.CFrame*CFrame.new(math.random(-9,9),-10,math.random(-9,9))*CFrame.Angles(math.rad(90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.75,0.75,0.75,0,BrickColor.Random(),0)
				end
			end
		end
	end))
--[[coroutine.resume(coroutine.create(function()
if hitfloor ~= nil then
slash(math.random(50,100)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))),vt(0.025,0.01,0.025),math.random(1,10)/250,BrickColor.new("White"))
end
end))]]--
	if equipped==true or equipped==false then
		if attack==false then
			idle=idle+1
		else
			idle=0
		end
		if idle>=500 then
			if attack==false then
				--Sheath()
			end
		end
		if RootPart.Velocity.y > 1 and hitfloor==nil then 
			Anim="Jump"
			if attack==false then
				RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
				RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
				LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
			end
		elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
			Anim="Fall"
			if attack==false then
				RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
				LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
				RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(10),math.rad(0),math.rad(0)),.1)
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5),math.rad(0),math.rad(0)),.1)
				RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(55)),.1)
				LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-55)),.1)
			end
		elseif torvel<1 and hitfloor~=nil then
			Anim="Idle"
			if attack==false then
				if ModeOfGlitch == 1 then
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(22 - 3 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1,0.5 + 0.005 * math.cos(sine / 45),-0.5)*angles(math.rad(84 + 6 * math.cos(sine / 74)),math.rad(8 - 5 * math.cos(sine / 53)),math.rad(-80 + 3 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),0.45)*angles(math.rad(-23 - 3 * math.cos(sine / 73)),math.rad(2 - 1 * math.cos(sine / 55)),math.rad(33 - 3 * math.cos(sine / 45))),.1)
				elseif ModeOfGlitch == 2 then
					actualrotationvalue = actualrotationvalue + 8 * math.cos(sine / 100)
					handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C1=clerp(handlexweld.C1,cf(0,1,-4 - 0.25 * math.cos(sine / 32))*angles(math.rad(-110),math.rad(0),math.rad(0)),.3)
					RH.C0=clerp(RH.C0,cf(1,-0.5 - 0.1 * math.cos(sine / 32),-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.8 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(22 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 32),3 + 0.5 * math.cos(sine / 32))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 + 2 * math.cos(sine / 56))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 - 2 * math.cos(sine / 37)),math.rad(0 + 5 * math.cos(sine / 43) - 5 * math.cos(sine / 0.25)),math.rad(22 - 2 * math.cos(sine / 56))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(5 + 3 * math.cos(sine / 43)),math.rad(-16 - 5 * math.cos(sine / 52)),math.rad(13 + 9 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1.35,1 + 0.025 * math.cos(sine / 45),-0.2)*angles(math.rad(148 - 2 * math.cos(sine / 51)),math.rad(0 - 4 * math.cos(sine / 64)),math.rad(22 - 2 * math.cos(sine / 45))),.1)
				elseif ModeOfGlitch == 3 then
					actualrotationvalue = actualrotationvalue + 8 * math.cos(sine / 100)
					handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C1=clerp(handlexweld.C1,cf(0,1.5,-4 - 1 * math.cos(sine / 32))*angles(math.rad(-50),math.rad(0),math.rad(0)),.3)
					RH.C0=clerp(RH.C0,cf(1,-0.3 - 0.1 * math.cos(sine / 32),-0.5)*angles(math.rad(0),math.rad(85),math.rad(10)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.8 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(30),math.rad(-85),math.rad(-10)),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 32),3 + 1 * math.cos(sine / 32) + kan.PlaybackLoudness/1000 * math.sin(sine / 32))*angles(math.rad(-50 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 + 2 * math.cos(sine / 56))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(15 - 2 * math.cos(sine / 37)),math.rad(0 + 5 * math.cos(sine / 43)),math.rad(0 - 2 * math.cos(sine / 56))),.1)
					RW.C0=clerp(RW.C0,cf(1.2,1 + 0.025 * math.cos(sine / 32),0.3)*angles(math.rad(185 + 3 * math.cos(sine / 32)),math.rad(-10 - 5 * math.cos(sine / 32)),math.rad(-30 + 9 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1.2,1 + 0.025 * math.cos(sine / 32),0.3)*angles(math.rad(185 + 3 * math.cos(sine / 32)),math.rad(10 + 5 * math.cos(sine / 32)),math.rad(30 - 9 * math.cos(sine / 45))),.1)
				elseif ModeOfGlitch == 4 then
					actualrotationvalue = actualrotationvalue + kan.PlaybackLoudness/100
					handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C1=clerp(handlexweld.C1,cf(0,-1,-6.5)*angles(math.rad(95 + 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.3)
					weldsensor.C0=clerp(weldsensor.C0,cf(0,4,2)*angles(math.rad(-140),math.rad(0),math.rad(0)),.1)
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(15),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(15),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(15 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(27 - 8 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 15 * math.cos(sine / 58) - 7.5 * math.cos(sine / 43.5))),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.4 + 0.005 * math.cos(sine / 45),0)*angles(math.rad(20 + 6 * math.cos(sine / 74)),math.rad(8 - 5 * math.cos(sine / 53)),math.rad(0)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.4 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(20 - 7 * math.cos(sine / 73)),math.rad(2 - 4 * math.cos(sine / 55)),math.rad(0)),.1)
				elseif ModeOfGlitch == 5 then
					actualrotationvalue = actualrotationvalue + 55
					hum.CameraOffset = vt(0 +  0.05 * math.cos(sine / 5),0  -  0.05 * math.cos(sine / 7),0 -  0.05 * math.cos(sine / 3))
					handlexweld.C1=clerp(handlexweld.C1,cf(0,-2,-2.05)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C0=clerp(handlexweld.C0,cf(0 + 0.5 * math.cos(sine / 31.5),0 + 0.5 * math.cos(sine / 45),0 + 0.5 * math.cos(sine / 23.5))*angles(math.rad(0 + 5 * math.cos(sine / 19)),math.rad(0 + 5 * math.cos(sine / 16)),math.rad(0 + 5 * math.cos(sine / 8))),.3)
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 12),0)*angles(math.rad(15),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 12),0)*angles(math.rad(15),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 12),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(15 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 10 * math.random(0,2)),math.rad(30 - 30 * math.random(0,2)),math.rad(30 - 30 * math.random(0,2))),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.4 + 0.005 * math.cos(sine / 45),0)*angles(math.rad(190 - 27 * math.random(0,2)),math.rad(20 - 20 * math.random(0,2)),math.rad(-10 - 7 * math.random(0,2))),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.4 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(190 - 27 * math.random(0,2)),math.rad(20 - 20 * math.random(0,2)),math.rad(17 - 7 * math.cos(sine / 1))),.1)
				elseif ModeOfGlitch == 6 then
					actualrotationvalue = actualrotationvalue + 20 * math.cos(sine / 100)
					RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 15),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 15),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.1 * math.cos(sine / 15))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(30 - 1 * math.cos(sine / 44))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(0 - 10 * math.cos(sine / 15)),math.rad(5 + 1 * math.cos(sine / 58)),math.rad(-30 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1,0.5 + 0.1 * math.cos(sine / 15),-0.5)*angles(math.rad(84),math.rad(8),math.rad(-80)),.1)
					LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.1 * math.cos(sine / 15),-0.45)*angles(math.rad(84),math.rad(8),math.rad(80)),.1)
				elseif ModeOfGlitch == 7 then
					actualrotationvalue = actualrotationvalue + kan.PlaybackLoudness/50 + 1
					handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C1=clerp(handlexweld.C1,cf(0,-0.4,-3.5 - 0.2 * math.cos(sine / 32))*angles(math.rad(-130 + 15 * math.sin(sine / 61)),math.rad(0),math.rad(0 + 5 * math.sin(sine / 39))),.3)
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * CFrame.new(0, 0, 2 + 0.3 * math.cos(sine / 20)) * angles(math.rad(15 + 2.5 * math.sin(sine / 24)), math.rad(0), math.rad(0 + 1.25 * math.sin(sine / 47))), 0.15)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-2.5 * math.sin(sine / 20)), math.rad(0), math.rad(0)), 0.3)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -0.4 - 0.1 * math.cos(sine / 20), -.4 + 0.025 * math.cos(sine / 20)) * RHCF * angles(math.rad(2.5 + 3 * math.sin(sine / 20)), math.rad(0), math.rad(-15 + 2.5 * math.sin(sine / 20))), 0.15)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.9 - 0.1 * math.cos(sine / 20), 0.025 * math.cos(sine / 20)) * LHCF * angles(math.rad(2.5 + 3 * math.sin(sine / 20)), math.rad(0), math.rad(15 + 2.5 * math.sin(sine / 20))), 0.15)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, 0.2 - 0.025 * math.cos(sine / 20)) * angles(math.rad(-30), math.rad(-0), math.rad(-30)), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.1, 0.5, 0.2 - 0.025 * math.cos(sine / 20)) * angles(math.rad(-30), math.rad(0), math.rad(30)), 0.1)
				elseif ModeOfGlitch == 8 then
					local snap = math.random(1,22)
					if snap == 1 then
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(32 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),1)
					end
					local snap2 = math.random(1,52)
					if snap2 == 1 then
						RW.C0=clerp(RW.C0,CFrame.new(1.5, 0.5, -0.2 - 0.025 * math.cos(sine / 20)) * angles(math.rad(45 + math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),1)
					end
					local snap3 = math.random(1,52)
					if snap3 == 1 then
						LW.C0=clerp(LW.C0,CFrame.new(-1.5, 0.5, -0.2 - 0.025 * math.cos(sine / 20)) * angles(math.rad(47 + math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(math.random(-5,5))),1)
					end
					actualrotationvalue = actualrotationvalue + math.random(-10,15)
					handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C1=clerp(handlexweld.C1,cf(0,-1,-6.5)*angles(math.rad(68 + 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.3)
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * CFrame.new(0, 0, 2 + 0.3 * math.cos(sine / 20)) * angles(math.rad(35), math.rad(0), math.rad(0)), 0.15)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(20), math.rad(0), math.rad(0)), 0.3)
					RH.C0=clerp(RH.C0,cf(1,-0.6 - 0.05 * math.cos(sine / 32),-0.1)*angles(math.rad(28),math.rad(80),math.rad(0)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.9 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(25),math.rad(-80),math.rad(0)),.1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.2 - 0.025 * math.cos(sine / 20)) * angles(math.rad(45), math.rad(-0), math.rad(5 + 5 * math.sin(sine/20))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2 - 0.025 * math.cos(sine / 20)) * angles(math.rad(47), math.rad(0), math.rad(-5 - 5 * math.sin(sine/20))), 0.1)
				elseif ModeOfGlitch == 9 then
					actualrotationvalue = actualrotationvalue + kan.PlaybackLoudness/50
					RH.C0=clerp(RH.C0,cf(1,-0.6 - kan.PlaybackLoudness/800 - 0.1 * math.cos(sine / 15),-0.3)*angles(math.rad(-10),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(1 - 2 * math.cos(sine / 32))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 15),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.1 * math.cos(sine / 15))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(10 - 1 * math.cos(sine / 44))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 - 3 * math.cos(sine / 37) + kan.PlaybackLoudness/30),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 5 * math.cos(sine / 58) - 7.5 * math.cos(sine / 43.5))),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.4 + 0.005 * math.cos(sine / 45),0)*angles(math.rad(145 - kan.PlaybackLoudness/5),math.rad(0),math.rad(10)),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.7 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(180),math.rad(2 - 4 * math.cos(sine / 55)),math.rad(30)),.1)
				elseif ModeOfGlitch == 10 then
					local snap = math.random(1,32)
					if snap == 1 then
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(32 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),4)
					end
					RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5 - 2 * math.cos(sine / 41)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-4 - 7 * math.cos(sine / 39))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5 - 2 * math.cos(sine / 41)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 8 * math.cos(sine / 31))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.07 * math.cos(sine / 47),0.425 + 0.15 * math.cos(sine / 39))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(32 + 6 * math.cos(sine / 72)),math.rad(2 - 4 * math.cos(sine / 58)),math.rad(14 + 1 * math.cos(sine / 45))),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(32 - 7 * math.cos(sine / 66)),math.rad(6 - 5 * math.cos(sine / 59)),math.rad(-9 - 3 * math.cos(sine / 45))),.1)
				end
			end
		elseif torvel>2 and torvel<100 and hitfloor~=nil then
			Anim="Walk"
			if attack==false then
				if ModeOfGlitch == 1 then
					RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 - 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 5 * math.cos(sine / 8))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 5 * math.cos(sine / 8))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 8))*angles(math.rad(0 - 50 * math.cos(sine / 8)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 4))),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
				elseif ModeOfGlitch == 4 then
					actualrotationvalue = actualrotationvalue + kan.PlaybackLoudness/100
					handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C1=clerp(handlexweld.C1,cf(0,-1,-6.5)*angles(math.rad(95 + 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.3)
					weldsensor.C0=clerp(weldsensor.C0,cf(0,4,2)*angles(math.rad(-140),math.rad(0),math.rad(0)),.1)
					RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 5),0)*angles(math.rad(5),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 10)),math.rad(0 + 35 * math.cos(sine / 10))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 5),0)*angles(math.rad(5),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 10)),math.rad(0 + 35 * math.cos(sine / 10))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(15 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 3 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 15 * math.cos(sine / 58) - 7.5 * math.cos(sine / 43.5))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5,0 + 0.25 * math.cos(sine / 10))*angles(math.rad(0 - 50 * math.cos(sine / 10)),math.rad(0),math.rad(5 - 10 * math.cos(sine / 5))),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 10))*angles(math.rad(0 + 50 * math.cos(sine / 10)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 5))),.1)
				elseif ModeOfGlitch == 5 then
					actualrotationvalue = actualrotationvalue + 55
					hum.CameraOffset = vt(0 +  0.05 * math.cos(sine / 5),0  -  0.05 * math.cos(sine / 7),0 -  0.05 * math.cos(sine / 3))
					handlexweld.C1=clerp(handlexweld.C1,cf(0,-2,-2.05)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C0=clerp(handlexweld.C0,cf(0 + 0.5 * math.cos(sine / 31.5),0 + 0.5 * math.cos(sine / 45),0 + 0.5 * math.cos(sine / 23.5))*angles(math.rad(0 + 5 * math.cos(sine / 19)),math.rad(0 + 5 * math.cos(sine / 16)),math.rad(0 + 5 * math.cos(sine / 8))),.3)
					RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 5),0)*angles(math.rad(5),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 10)),math.rad(0 + 35 * math.cos(sine / 10))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 5),0)*angles(math.rad(5),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 10)),math.rad(0 + 35 * math.cos(sine / 10))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(15 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 44))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(30 - 10 * math.random(0,2)),math.rad(30 - 30 * math.random(0,2)),math.rad(30 - 30 * math.random(0,2))),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.4 + 0.005 * math.cos(sine / 45),0)*angles(math.rad(190 - 27 * math.random(0,2)),math.rad(20 - 20 * math.random(0,2)),math.rad(-10 - 7 * math.random(0,2))),.1)
					LW.C0=clerp(LW.C0,cf(-1.45,0.4 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(190 - 27 * math.random(0,2)),math.rad(20 - 20 * math.random(0,2)),math.rad(17 - 7 * math.cos(sine / 1))),.1)
				elseif ModeOfGlitch == 2 or ModeOfGlitch == 7 then
					actualrotationvalue = actualrotationvalue + 14
					handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C1=clerp(handlexweld.C1,cf(0,0,-4)*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
					RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
				elseif ModeOfGlitch == 3 then
					actualrotationvalue = actualrotationvalue + 14
					handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C1=clerp(handlexweld.C1,cf(0,0,-4)*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
					RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,0.5 + 0.1 * math.cos(sine / 28))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
				elseif ModeOfGlitch == 9 then
					RH.C0=clerp(RH.C0,cf(1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1 + 0.05 * math.cos(sine / 4),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 35 * math.cos(sine / 8))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.05,-0.05 - 0.05 * math.cos(sine / 4))*angles(math.rad(5 + 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - root.RotVelocity.Y - 5 * math.cos(sine / 8))),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(10 - 3 * math.cos(sine / 4)),math.rad(0 + root.RotVelocity.Y/1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 5 * math.cos(sine / 8))),.1)
					RW.C0=clerp(RW.C0,cf(1.45,0.4 + 0.005 * math.cos(sine / 45),0)*angles(math.rad(145 - kan.PlaybackLoudness/5),math.rad(0),math.rad(10)),.1)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0 - 0.25 * math.cos(sine / 8))*angles(math.rad(0 + 50 * math.cos(sine / 8)),math.rad(0),math.rad(-5 + 10 * math.cos(sine / 4))),.1)
				elseif ModeOfGlitch == 6 then
					actualrotationvalue = actualrotationvalue + 20 * math.cos(sine / 100)
					handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C1=clerp(handlexweld.C1,cf(0,-2,-3)*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)
					RH.C0 = clerp(RH.C0, cf(1, -0.75 - 0.25 * math.cos(sine / 3), -0.25 - 0.25 * math.cos(sine / 3)) * angles(math.rad(0), math.rad(90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 95 * math.cos(sine / 6))), 0.1)
					LH.C0 = clerp(LH.C0, cf(-1, -0.75 + 0.25 * math.cos(sine / 3), -0.25 + 0.25 * math.cos(sine / 3)) * angles(math.rad(0), math.rad(-90), math.rad(0)) * angles(math.rad(0), math.rad(0), math.rad(0 + 95 * math.cos(sine / 6))), 0.1)
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, -0.125 + 0.125 * math.cos(sine / 3)) * angles(math.rad(20), math.rad(0), math.rad(0 - 15 * math.cos(sine / 6))), 0.1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-10 + 2.5 * math.cos(sine / 100)), math.rad(0), math.rad(0 + 15 * math.cos(sine / 6))), 0.1)
					RW.C0 = clerp(RW.C0, cf(1.5, 0.5, 0) * angles(math.rad(0 - 155 * math.cos(sine / 6)), math.rad(0), math.rad(5 - 10 * math.cos(sine / 3))), 0.1)
					LW.C0 = clerp(LW.C0, cf(-1.5, 0.5, 0) * angles(math.rad(0 + 155 * math.cos(sine / 6)), math.rad(0), math.rad(-5 + 10 * math.cos(sine / 3))), 0.1)
				elseif ModeOfGlitch == 10 then
					local snap = math.random(1,32)
					if snap == 1 then
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(32 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),4)
					end
					RH.C0=clerp(RH.C0,cf(1,-0.4,-0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5 - 2 * math.cos(sine / 41)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-4 - 7 * math.cos(sine / 39))),.1)
					LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-1.5 - 2 * math.cos(sine / 41)),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(15 + 8 * math.cos(sine / 31))),.1)
					RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.07 * math.cos(sine / 47),0.425 + 0.15 * math.cos(sine / 39))*angles(math.rad(52 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
					Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-15 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
					RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
				elseif ModeOfGlitch == 8 then
					local snap = math.random(1,22)
					if snap == 1 then
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-5 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),1)
					end
					actualrotationvalue = actualrotationvalue + math.random(-10,15)
					handlexweld.C0=clerp(handlexweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					handlexweld.C1=clerp(handlexweld.C1,cf(0,-1,-6.5)*angles(math.rad(68 + 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.3)
					RootJoint.C0 = clerp(RootJoint.C0, RootCF * CFrame.new(0, 0, 2 + 0.3 * math.cos(sine / 20)) * angles(math.rad(35), math.rad(0), math.rad(0)), 0.15)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-10), math.rad(0), math.rad(0)), 0.3)
					RH.C0=clerp(RH.C0,cf(1,-0.6 - 0.05 * math.cos(sine / 32),-0.1)*angles(math.rad(-18 - 5 * math.sin(sine/20)),math.rad(80),math.rad(0)),.1)
					LH.C0=clerp(LH.C0,cf(-1,-0.9 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(-15 - 5 * math.sin(sine/20)),math.rad(-80),math.rad(0)),.1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.2 - 0.025 * math.cos(sine / 20)) * angles(math.rad(-25 - 5 * math.sin(sine/20)), math.rad(-0), math.rad(5 + 5 * math.sin(sine/20))), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.2 - 0.025 * math.cos(sine / 20)) * angles(math.rad(-27 - 5 * math.sin(sine/20)), math.rad(0), math.rad(-5 - 5 * math.sin(sine/20))), 0.1)
				end
			end
		end
	end
end
