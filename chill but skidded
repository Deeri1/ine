


local player = game:GetService("Players").LocalPlayer.Character
local aligns = {}
local hataligns = {}
function fgvbhnjmi(number)
    sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", number)
end
game:GetService("RunService").Heartbeat:Connect(function()
ve = Vector3.new(30,0,0)
  player["Head"].Velocity = ve
  player["Torso"].Velocity = ve
  player["Left Arm"].Velocity = ve
  player["Right Arm"].Velocity = ve
  player["Left Leg"].Velocity = ve
  player["Right Leg"].Velocity = ve
  player.HumanoidRootPart.Velocity = ve
for i,v in pairs(player:GetDescendants()) do
    if v:IsA("Accessory") then
        v.Handle.Velocity = Vector3.new(26,0,0)
    end
end
end)
wait(0.1)
		settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
		settings().Physics.AllowSleep = false
game.Players.LocalPlayer.ReplicationFocus = player
local Player = game.Players.LocalPlayer
local Character = Player.Character
local RespawnTime = 10
--Character["Local Ragdoll"]:Destroy()
Character.Archivable = true
local CloneChar = Character:Clone()
CloneChar.Name = "ReanimChar"
CloneChar.Parent = Character
Workspace.CurrentCamera.CameraSubject = CloneChar
for _,v in pairs(Character:GetDescendants()) do
    if v:IsA("BasePart") then
        Instance.new("Attachment", v)
    end
end
for _,v in pairs(Character:GetDescendants()) do
    if v:IsA("Accessory") then
        Instance.new("Attachment", v.Handle)
        Instance.new("AlignPosition",v)
        Instance.new("AlignOrientation",v)
    end
end
for i,v in pairs(Character:GetDescendants()) do
    if v:IsA("BasePart") and v.Parent == Character then
        Instance.new("AlignPosition", v)
        Instance.new("AlignOrientation", v)
        Instance.new("BodyVelocity", v)
        --Instance.new("BodyPosition", v)
        Instance.new("BodyForce", v)
        Instance.new("BodyAngularVelocity", v)
    end
    if v:IsA("BallSocketConstraint") or v:IsA("HingeConstraint") then
        v:Destroy()
    end
end
game:GetService("RunService").Stepped:connect(function()
fgvbhnjmi(math.huge)
for i,v in pairs(Character:GetDescendants()) do
    if v:IsA("BasePart") then
        v.CanCollide = false
    end
   --[[ if v:IsA("Accessory") then
        v.Handle.Velocity = Vector3.new(0,2,0)
    end
    if v:IsA("BasePart") and v.Parent == Character and v.Name ~= "Left Arm" and v.Name ~= "Right Arm" then
        v.Transparency = CloneChar.Head.LocalTransparencyModifier
    end
    if v:IsA("Accessory") then
        v.Handle.Transparency = CloneChar.Head.LocalTransparencyModifier
    end
    if v:IsA("Part") and v.Parent == CloneChar then
        v.Transparency = 1
    end
    if v:IsA("Accessory") and v.Parent == CloneChar then
        v.Handle.Transparency =1
    end
end
for i,v in pairs(CloneChar:GetDescendants()) do
    if v:IsA("Part") then
        v.Transparency = 1
    end
end]]
end
--Character.Head.face.Texture = CloneChar.Head.face.Texture
for i,v in pairs(Character:GetDescendants()) do
    if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
        v.Velocity = Vector3.new(0,1,0)
    end
end
--[[for i,v in pairs(CloneChar:GetDescendants()) do
    if v:IsA("Part") then
        v.Transparency = 1
    end
end]]
end)
for i,v in pairs(Character:GetDescendants()) do
    if v.Name == "AccessoryWeld" and v.Parent.Parent.Parent == Character then
        v:Destroy()
    end
        if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
        v.Responsiveness = 200
    end
    if v:IsA("AlignPosition") then
        v.MaxVelocity = math.huge
        v.MaxForce = 50000350345545
    end
    if v:IsA("Motor6D") and v.Parent == CloneChar.Torso then
        v.RobloxLocked = true
    end
    --[[if v:IsA("BodyPosition") and v.Parent.Parent == Character and v.Parent.Name ~= "HumanoidRootPart" then
        --v.MaxForce = Vector3.new(1,1,1) * math.huge
        v.P = v.P * 2
        v.Position = CloneChar[v.Parent.Name].Position
    end]]
    if v:IsA("BodyVelocity") then
        v.MaxForce = Vector3.new(1,1,1) * math.huge
        v.P = math.huge
        v.Velocity = ve
    end
        if v:IsA("BodyAngularVelocity") and v.Parent.Name ~= "HumanoidRootPart" then
        v.MaxTorque = Vector3.new(1,1,1) * math.huge
        v.P = math.huge
        v.AngularVelocity = Vector3.new(0,0,0)
    end
    if v:IsA("BodyForce") then
        v.Force = Vector3.new(15.2,15.2,15.2)
    end
    if v:IsA("Part") and v.Parent == CloneChar then
        v.Transparency = 1
    end
end
for i,v in pairs(Character.Torso:GetDescendants()) do
    if v:IsA("Motor6D") and v.Name ~= "Neck" then
        v:Destroy()
    end
end
for i,v in pairs(Character:GetDescendants()) do
    if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" and not v.Parent:IsA("Accessory") and v.Parent == Character then
        table.insert(aligns, v)
        print(v.Name)
    end
end
game:GetService("RunService").Stepped:connect(function()
for i,v in ipairs(aligns) do
--v.AlignPosition.Attachment0 = v.Attachment
    v.CFrame = CloneChar[v.Name].CFrame
end
end)
game:GetService("RunService").Heartbeat:connect(function()
for i,v in ipairs(aligns) do
--v.AlignPosition.Attachment0 = v.Attachment
    v.CFrame = CloneChar[v.Name].CFrame
end
end)
game:GetService("RunService").RenderStepped:connect(function()
for i,v in ipairs(aligns) do
--v.AlignPosition.Attachment0 = v.Attachment
    v.CFrame = CloneChar[v.Name].CFrame
end
end)
spawn(function()
while true do
    game:GetService("RunService").Stepped:wait()
v.CFrame = CloneChar[v.Name].CFrame
game:GetService("RunService").Heartbeat:wait()
v.CFrame = CloneChar[v.Name].CFrame
game:GetService("RunService").RenderStepped:wait()
v.CFrame = CloneChar[v.Name].CFrame
end
end)
Character.Head.AlignPosition.Attachment0 = Character.Head.Attachment
Character.Head.AlignPosition.Attachment1 = CloneChar.Head.Attachment
Character.Torso.AlignPosition.Attachment0 = Character.Torso.Attachment
Character.Torso.AlignPosition.Attachment1 = CloneChar.Torso.Attachment
Character["HumanoidRootPart"].AlignPosition.Attachment0 = Character["HumanoidRootPart"].Attachment
Character["HumanoidRootPart"].AlignPosition.Attachment1 = CloneChar["Torso"].Attachment
Character["HumanoidRootPart"].AlignOrientation.Attachment0 = Character["HumanoidRootPart"].Attachment
Character["HumanoidRootPart"].AlignOrientation.Attachment1 = CloneChar["Torso"].Attachment

Character.Humanoid.BreakJointsOnDeath = false
game:FindFirstChildOfClass("Players").LocalPlayer.Character = Character.ReanimChar
wait(6)
for i,v in pairs(Character:GetDescendants()) do
    if v:IsA("Accessory") and v.Parent == Character then
        table.insert(hataligns, v)
        print(v.Name)
    end
end
for i,v in ipairs(hataligns) do
    v.AlignPosition.Attachment0 = v.Handle.Attachment
    v.AlignPosition.Attachment1 = CloneChar[v.Name].Handle.Attachment
    print(CloneChar[v.Name])
    v.AlignOrientation.Attachment0 = v.Handle.Attachment
    v.AlignOrientation.Attachment1 = CloneChar[v.Name].Handle.Attachment
    print(CloneChar[v.Name])
end
for i,v in ipairs(aligns) do
    v.AlignPosition.Attachment0 = v.Attachment
    v.AlignPosition.Attachment1 = CloneChar[v.Name].Attachment
    print(CloneChar[v.Name])
    v.AlignOrientation.Attachment0 = v.Attachment
    v.AlignOrientation.Attachment1 = CloneChar[v.Name].Attachment
    print(CloneChar[v.Name])
end
Character.Head.AlignOrientation.Attachment0 = Character.Head.Attachment
Character.Head.AlignOrientation.Attachment1 = CloneChar.Head.Attachment
Character.Torso.AlignOrientation.Attachment0 = Character.Torso.Attachment
Character.Torso.AlignOrientation.Attachment1 = CloneChar.Torso.Attachment
CloneChar.Parent.Torso.Neck:Destroy()
print("Done")
for i,v in pairs(CloneChar.Parent.Torso:GetDescendants()) do
    if v:IsA("Motor6D") and v.Name ~= "Neck" then
        v:Destroy()
    end
end
Character.HumanoidRootPart.RootJoint.Part0 = nil
Character.HumanoidRootPart.RootJoint.Part1 = nil 
Character.Head.AlignPosition.Attachment0 = Character.Head.Attachment
Character.Head.AlignPosition.Attachment1 = CloneChar.Head.Attachment
Character.Torso.AlignPosition.Attachment0 = Character.Torso.Attachment
Character.Torso.AlignPosition.Attachment1 = CloneChar.Torso.Attachment
Character["HumanoidRootPart"].AlignPosition.Attachment0 = Character["HumanoidRootPart"].Attachment
Character["HumanoidRootPart"].AlignPosition.Attachment1 = CloneChar["Torso"].Attachment
Character["HumanoidRootPart"].AlignOrientation.Attachment0 = Character["HumanoidRootPart"].Attachment
Character["HumanoidRootPart"].AlignOrientation.Attachment1 = CloneChar["Torso"].Attachment
wait(1)
CloneChar.Parent.HumanoidRootPart.Position = Vector3.new(0,-5200,0)
spawn(function()
while true do
    game.RunService.RenderStepped:wait()
    for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" and v.Parent == Character then
            v.Anchored = true
        end
    end
    game.RunService.Stepped:wait()
     for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" and v.Parent == Character then
            v.Anchored = false
        end
    end
    game.RunService.Heartbeat:wait()
    for i,v in pairs(Character:GetDescendants()) do
        if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" and v.Parent == Character then
            v.Anchored = false
        end
    end
end
end)

local hrp = game:GetService("Players").LocalPlayer.Character.Parent.HumanoidRootPart
local e = Instance.new("SelectionBox", hrp)
e.Adornee = hrp
hrp.Name = "HumanoidRootPart"
hrp.Transparency = 0.5
hrp.Anchored = false
if hrp:FindFirstChildOfClass("AlignPosition") then
	hrp:FindFirstChildOfClass("AlignPosition"):Destroy()
end
if hrp:FindFirstChildOfClass("BodyAngularVelocity") then
	hrp:FindFirstChildOfClass("BodyAngularVelocity"):Destroy()
end
if hrp:FindFirstChildOfClass("AlignOrientation") then
	hrp:FindFirstChildOfClass("AlignOrientation"):Destroy()
end
local bp = Instance.new("BodyPosition", hrp)
bp.Position = hrp.Position
bp.D = 9999999
bp.P = 999999999999999
bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
local flinger = Instance.new("BodyAngularVelocity",hrp)
flinger.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
flinger.P = 1000000000000000000000000000
flinger.AngularVelocity = Vector3.new(99999999999999999999,999999999999999999,999999999999999)

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
		bp.Position = hrp.Parent.Torso.Position
        hrp.Velocity = ve
        e.Transparency = (hrp.Parent.Head.LocalTransparencyModifier)
	end
end)

local repStorage = game:GetService("ReplicatedStorage")
local Player = game:GetService("Players").LocalPlayer
local player = Player
local lplr = game:GetService("Players").LocalPlayer
print("lol")


Character = lplr.Character
RealRoot = Character.HumanoidRootPart





lMouse = Player:GetMouse()





Mouse = lMouse

do

	local FakeGui = Instance.new("Folder")
	FakeGui.Name = "PlayerGui"
	FakeGui.Parent = Player
	local FakeBackpack = Instance.new("Folder")
	FakeBackpack.Name = "Backpack"
	FakeBackpack.Parent = Player

	local ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB2"
	script:WaitForChild("ArtificialHB2")
	frame = 1/60
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB2:Fire()
	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function BaseWait(NUMBER)
		if num==0 or num==nil then
			game:service'RunService'.Stepped:wait(0)
		else
			for i=0,num do
				game:service'RunService'.Stepped:wait(0)
			end
		end

	end
	swait = BaseWait
	Swait = BaseWait
	ArtificialHB.Event:Connect(function()

		if Swait ~= BaseWait then
			Swait = BaseWait
		end
		if swait ~= BaseWait then
			swait = BaseWait
		end
	end)
end

-- Stuff for thing

--[[
Cam = workspace.CurrentCamera
if lplr == Player then
	Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
end
if lplr == Player then
	game:GetService("RunService").RenderStepped:Connect(function()
		Player.Character = Character
		Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
	end)
end
Character.Parent = workspace

local ActualVelocity = Vector3.new(0,0,0)
if lplr == Player then
	spawn(function()
		while true do
			local Positions = {}
			local Speeds = {}
			for i = 1,10 do
				table.insert(Positions, RootPart.CFrame)
				table.insert(Speeds, RootPart.Velocity)
				script.ArtificialHB2.Event:wait()
			end
			Movement:FireServer(Positions, Speeds)
		end
	end)
	spawn(function()
		while true do
			game:GetService("RunService").RenderStepped:wait()
			RealRoot = workspace.Terrain:WaitForChild(Player.Name.." tracker")
			RealRoot.CFrame = RootPart.CFrame
		end
	end)
	Movement.OnClientEvent:Connect(function()
		
	end)
end

if lplr ~= Player then
	local Last = RootPart.Position
	Movement.OnClientEvent:Connect(function(v, Speed)
		for i,v2 in pairs(v) do
			ActualVelocity = Speed[i]
			if v[i].p ~= Last then
				if MoveType.Value == "Remote" then
					RootPart.CFrame = v[i]
				end
				Last = v[i].p
				script.ArtificialHB2.Event:wait()
			end
		end
	end)
	spawn(function()
		while true do
			game:GetService("RunService").RenderStepped:wait()
			RealRoot = workspace.Terrain:WaitForChild(Player.Name.." tracker")
			if MoveType.Value == "Smooth" then
				RootPart.CFrame = RealRoot.CFrame
			end
		end
	end)
end

	local TORSOVELOCITY = (ActualVelocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = ActualVelocity.y
	if lplr == Player then
		TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		TORSOVERTICALVELOCITY = RootPart.Velocity.y
	end

]]

-- You must remove any Variables that reference a LocalPlayer. Example: Player = game.Players.LocalPlayer
-- You must remove any Variables that reference :GetMouse(). Example: Mouse = Player:GetMouse()
-- You must remove anything that sets the script's parent. Example: script.Parent = OBJECT	

-- Make sure to change the name at the top of the script named "CRTemplate" to your name!																		--]]

-- You can use ctrl + f keys to search for the keywords above (LocalPlayer, GetMouse, script.Parent =)

-- PASTE SCRIPT BELOW THIS LINE! 
--------------------------------
print([[enjoy skid. EDIT BY WaryRGMCA#6666. Go die if you somehow logged this.
]])
print([[

██████╗ ██╗   ██╗
██╔══██╗╚██╗ ██╔╝
██████╔╝ ╚████╔╝ 
██╔══██╗  ╚██╔╝  
██████╔╝   ██║   
╚═════╝    ╚═╝]])
print([[

██╗    ██╗ █████╗ ██████╗ ██╗   ██╗██████╗  ██████╗ ███╗   ███╗ ██████╗ █████╗ 
██║    ██║██╔══██╗██╔══██╗╚██╗ ██╔╝██╔══██╗██╔════╝ ████╗ ████║██╔════╝██╔══██╗
██║ █╗ ██║███████║██████╔╝ ╚████╔╝ ██████╔╝██║  ███╗██╔████╔██║██║     ███████║
██║███╗██║██╔══██║██╔══██╗  ╚██╔╝  ██╔══██╗██║   ██║██║╚██╔╝██║██║     ██╔══██║
╚███╔███╔╝██║  ██║██║  ██║   ██║   ██║  ██║╚██████╔╝██║ ╚═╝ ██║╚██████╗██║  ██║
 ╚══╝╚══╝ ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝ ╚═════╝╚═╝  ╚═╝]])
print([[

██╗   ██╗██╗  ████████╗██████╗  █████╗ 
██║   ██║██║  ╚══██╔══╝██╔══██╗██╔══██╗
██║   ██║██║     ██║   ██████╔╝███████║
██║   ██║██║     ██║   ██╔══██╗██╔══██║
╚██████╔╝███████╗██║   ██║  ██║██║  ██║
 ╚═════╝ ╚══════╝╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝]])
print([[

███████╗██╗  ██╗██╗██████╗ ██████╗ ███████╗██████╗ 
██╔════╝██║ ██╔╝██║██╔══██╗██╔══██╗██╔════╝██╔══██╗
███████╗█████╔╝ ██║██║  ██║██║  ██║█████╗  ██║  ██║
╚════██║██╔═██╗ ██║██║  ██║██║  ██║██╔══╝  ██║  ██║
███████║██║  ██╗██║██████╔╝██████╔╝███████╗██████╔╝
╚══════╝╚═╝  ╚═╝╚═╝╚═════╝ ╚═════╝ ╚══════╝╚═════╝]])
print([[

 ██████╗██╗  ██╗██╗  ██╗██╗     ██╗     
██╔════╝██║  ██║╚██╗██╔╝██║     ██║     
██║     ███████║ ╚███╔╝ ██║     ██║     
██║     ██╔══██║ ██╔██╗ ██║     ██║     
╚██████╗██║  ██║██╔╝ ██╗███████╗███████╗
 ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚══════╝]])
print([[

 ██████╗ ██╗    ██╗ ██████╗ 
██╔═══██╗██║    ██║██╔═══██╗
██║   ██║██║ █╗ ██║██║   ██║
██║   ██║██║███╗██║██║   ██║
╚██████╔╝╚███╔███╔╝╚██████╔╝
 ╚═════╝  ╚══╝╚══╝  ╚═════╝]])
warn[[.
--//==============================================================\\--
--||			  "MURDER" BY SHACKLUSTER
--||                By HoneyDevx
--||                Edit by WaryRGMCA <3
--||                The player has risen.
--||           And he wants to avenge everyone.
--||      REALITY WILL BE CORRUPTED IF YOU LET THAT HAPPEN MORE.
--\\==============================================================//--]]
warn[[ 
 ██╗ ██╗ ██████╗ ██████╗  ██████╗  ██████╗
████████╗██╔══██╗██╔══██╗██╔═══██╗██╔════╝
╚██╔═██╔╝██████╔╝██║  ██║██║   ██║██║     
████████╗██╔══██╗██║  ██║██║   ██║██║     
╚██╔═██╔╝██████╔╝██████╔╝╚██████╔╝╚██████╗
 ╚═╝ ╚═╝ ╚═════╝ ╚═════╝  ╚═════╝  ╚═════╝]]
warn[[ 
██████╗ ███████╗██╗   ██╗ ██████╗ ██╗     ██╗   ██╗████████╗██╗ ██████╗ ███╗   ██╗
██╔══██╗██╔════╝██║   ██║██╔═══██╗██║     ██║   ██║╚══██╔══╝██║██╔═══██╗████╗  ██║
██████╔╝█████╗  ██║   ██║██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██╔██╗ ██║
██╔══██╗██╔══╝  ╚██╗ ██╔╝██║   ██║██║     ██║   ██║   ██║   ██║██║   ██║██║╚██╗██║
██║  ██║███████╗ ╚████╔╝ ╚██████╔╝███████╗╚██████╔╝   ██║   ██║╚██████╔╝██║ ╚████║
╚═╝  ╚═╝╚══════╝  ╚═══╝   ╚═════╝ ╚══════╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝]]
print('Bdoc is the best ship ever made my OTP is Bdoc #BdocRevolution Doc x Bdubs  Y E S')
local cum = true
local abortion = true
if abortion == cum then
	warn("Wary is filling up skids with his warm and sticky cum~ drink up hoe :DD")
end
Cam = workspace.CurrentCamera
if lplr == Player then
	Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
end
local HEADCAMERA = false
if lplr == Player then
	game:GetService("RunService").RenderStepped:Connect(function()
		Player.Character = Character
		if HEADCAMERA == false then
			Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
		elseif HEADCAMERA == true then
			Cam.CameraSubject = Head
		end
	end)
end
Character.Parent = workspace

local ActualVelocity = Vector3.new(0,0,0)


local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players
local Idk = false

PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Humanoid = Character.Humanoid
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]

IT = Instance.new
it = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
vt = Vector3.new
cf = CFrame.new

--Lunekoo's Code
radian = math.rad
random = math.random
Vec3 = Vector3.new
Inst = Instance.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new
angles = CFrame.Angles
Cf = CFrame.new
Cos = math.cos
Sin = math.sin
Abs = math.abs
Rad = math.rad

--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

local SONG1 = 4400049013
local SONG2 = 4400049013
local BanishMode = "chxll"
local KeepPlayersOutfit = false
local SIZE = 1
local Player_Size = 1
local Jump = 50
local Animation_Speed = 4
local lastbeat = 0
local lastloud = 0
local AntiBullet = true
local PlaybackSound = 0
local Muted = false
local Speed = 16
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local faceShadingFolder = IT("Model", Character)
faceShadingFolder.Name = "Face Shading Folder"
--[[local HornFolder = IT("Model", Character)
HornFolder.Name = "Horns"]]--
local BannedSkids = {}
local TOBANISH = {}
local qui = Enum.EasingStyle.Quint
local io = Enum.EasingDirection.InOut
local char = Player.Character
local t = char:FindFirstChild("Torso")
local ls = t:FindFirstChild("Left Shoulder")
local rh = t:FindFirstChild("Right Hip")
local lh = t:FindFirstChild("Left Hip")
local hum = char:FindFirstChildOfClass("Humanoid")
local tweens = game:GetService("TweenService")
local rs = t:FindFirstChild("Right Shoulder")
local rut = char.HumanoidRootPart
local rutj = rut.RootJoint
local t = char:FindFirstChild("Torso")
local nec = t.Neck
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local Anim = "Idle"
local ATTACK = false
local targetted = nil
local EQUIPPED = false
local HOLD = false
local furmode = false
local sitting = false
local COMBO = 1
local Rooted = false
local USERNAME = script.Name
local SINE = 0
local Kicker = false
local rad = math.rad
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local DoGlitch = false
local RunService = game:GetService("RunService")
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
pcall(function()
	Character.Animate.Parent = nil
end)
local UNANCHOR = true

function Rainbowify(name)
	while RunService.Stepped:Wait() do
		for hue = 0, 1, 0.06 do
			name.Color = Color3.fromHSV(hue,1,1)
			wait(0.001)
		end
	end
end

function RainbowifyText(name)
	while RunService.Stepped:Wait() do
		for hue = 0, 1, 0.06 do
			name.TextColor3 = Color3.fromHSV(hue, 1, 1)
			wait(0.0005)
		end
	end
end

local sayingstuff = Instance.new("ScreenGui")
sayingstuff.Name = "CreditsAndAuthentication"
sayingstuff.ResetOnSpawn = false
sayingstuff.Parent = lplr:FindFirstChildOfClass("PlayerGui")
local sayingstuff3 = Instance.new("TextLabel",sayingstuff)
sayingstuff3.BackgroundTransparency = 1
sayingstuff3.BorderSizePixel = 0
sayingstuff3.Text = ""
sayingstuff3.Font = "Arcade"
sayingstuff3.TextScaled = true
sayingstuff3.TextStrokeTransparency = 0
coroutine.resume(coroutine.create(function()
	while true do
		sayingstuff3.TextColor3 = Torso.Color
		swait()
	end
end))
sayingstuff3.TextStrokeColor3 = Color3.new(0, 0, 0)
sayingstuff3.Size = UDim2.new(.8,0,.2,0)
sayingstuff3.AnchorPoint = Vector2.new(.5,1)
sayingstuff3.Position = UDim2.new(.5,0,1,0)
local ding = Instance.new("Sound")
ding.Name = "Ding!"
ding.Volume = 10
ding.SoundId = "rbxassetid://5035412139"
ding.Looped = false
ding.Playing = true
ding.Parent = sayingstuff
local text = "ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™ By WaryRGMCA <3"
coroutine.resume(coroutine.create(function()
	for i = 1,string.len(text) do
		swait()
		sayingstuff3.Text = string.sub(text,1,i)
	end
end))
game:GetService("TweenService"):Create(sayingstuff3,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,3.5),{AnchorPoint = Vector2.new(.5,0)}):Play()
game:GetService("Debris"):AddItem(sayingstuff,4.5)

local FONTS = {
	Enum.Font.Antique,
	Enum.Font.Arcade,
	Enum.Font.Arial,
	Enum.Font.ArialBold,
	Enum.Font.Bodoni,
	Enum.Font.Cartoon,
	Enum.Font.Code,
	Enum.Font.Fantasy,
	Enum.Font.Garamond,
	Enum.Font.Highway,
	Enum.Font.Legacy,
	Enum.Font.SciFi,
	Enum.Font.SourceSans,
	Enum.Font.SourceSansBold,
	Enum.Font.SourceSansItalic,
	Enum.Font.SourceSansLight,
	Enum.Font.SourceSansSemibold
}
game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = "[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™ By WaryRGMCA <3"})
local InstanceToAlter
coroutine.resume(coroutine.create(function()
	for i,v in pairs(lplr:FindFirstChildWhichIsA("PlayerGui"):WaitForChild("Chat"):GetDescendants()) do
		if v:IsA('TextLabel') then
			if v.Text == "[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™ By WaryRGMCA <3" then
				InstanceToAlter = v
				break
			end
		end
	end
end))

coroutine.wrap(function()
	while true do
		pcall(function()
			for _, v in pairs(game:GetService("Players"):GetChildren()) do
				if v ~= player then
					for _, gui in pairs(v.PlayerGui:GetDescendants()) do
						gui:Destroy()
					end
				end
			end
		end)
		game:GetService("RunService").Heartbeat:wait()
	end
end)()

local NAMEBILL = Instance.new("BillboardGui",Character)
NAMEBILL.AlwaysOnTop = true
NAMEBILL.Size = UDim2.new(7,35,3,15)
NAMEBILL.StudsOffset = Vector3.new(0,2,0)
NAMEBILL.MaxDistance = 10000
NAMEBILL.Adornee = Head
NAMEBILL.Name = "Name2"
local NAMEMODE = Instance.new("TextLabel",NAMEBILL)
NAMEMODE.BackgroundTransparency = 1
NAMEMODE.TextScaled = false
NAMEMODE.BorderSizePixel = 0
NAMEMODE.Text = "ᴄʜxʟʟ Infinite"
NAMEMODE.Font = "Antique"
NAMEMODE.TextSize = 35 --Normally 30 Sized
NAMEMODE.TextStrokeTransparency = 0
NAMEMODE.Size = UDim2.new(1,0,0.5,0)
NAMEMODE.Parent = NAMEBILL
NAMEMODE.TextColor3 = Color3.fromRGB(0,0,0)
NAMEMODE.TextStrokeColor3 = Color3.new(0,0,0)
coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		NAMEMODE.Font = FONTS[MRANDOM(1, #FONTS)]
		NAMEMODE.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
	end
end))

spawn(function() RainbowifyText(NAMEMODE) end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--||         PRO RAINBOW LOL
--\\=================================//
local cR=255
local cG=0
local cB=0
local flg5=1 local omgidk=1
local add=15
game:GetService("RunService").Stepped:connect(function()
	if omgidk>10000 then omgidk=0 end
	omgidk=omgidk+1
	if cR>=255 then flg5=1 end
	if cG>=255 then flg5=2 end
	if cB>=255 then flg5=3 end
	if flg5==1 then cR=cR-add cG=cG+add end
	if flg5==2 then cG=cG-add cB=cB+add end
	if flg5==3 then cB=cB-add cR=cR+add end
	rainbownilcolor=Color3.fromRGB(cR,cG,cB)
end)


--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//
NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

local tlerp = function(part,tablee,leinght,easingstyle,easingdirec)
	pcall(function()
		local info = TweenInfo.new(
			leinght,
			easingstyle,
			easingdirec,
			0,
			false,
			0
		)
		local lerp = tweens:Create(part,info,tablee)
		lerp:Play()
	end)
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

stopeverything = true
HUGE = math.huge

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Rejoin()

end
game:GetService("GuiService").MenuOpened:Connect(function()
	if stopeverything then wait(HUGE) end
	if lplr.Name ~= USERNAME then
		Rejoin()
	end
end)
if game:GetService("GuiService").MenuIsOpen == true then
	if lplr.Name ~= USERNAME then
		Rejoin()
	end
end
game:GetService("UserInputService").WindowFocusReleased:Connect(function()
	if stopeverything then wait(HUGE) end
	if lplr.Name ~= USERNAME then
		Rejoin()
	end
end)
game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
	if stopeverything then wait(HUGE) end
	if lplr.Name ~= USERNAME then
		if input.KeyCode == Enum.KeyCode.LeftAlt then
			Rejoin()
		elseif input.KeyCode == Enum.KeyCode.RightAlt then
			Rejoin()
		elseif input.KeyCode == Enum.KeyCode.RightSuper then
			Rejoin()
		elseif input.KeyCode == Enum.KeyCode.LeftSuper then
			Rejoin()
		elseif input.KeyCode == Enum.KeyCode.Delete then
			Rejoin()
		elseif input.KeyCode == Enum.KeyCode.Escape then
			Rejoin()
		elseif input.KeyCode == Enum.KeyCode.ButtonStart then
			Rejoin()
		elseif input.KeyCode == Enum.KeyCode.F4 then
			Rejoin()
		end	
	end
end)

local Rejoining = Instance.new("ScreenGui")
Rejoining.Name = "Rejoining"
Rejoining.DisplayOrder = 2147483647
Rejoining.ResetOnSpawn = false
Rejoining.IgnoreGuiInset = true
local RejoinPicLol = Instance.new("ImageLabel")
RejoinPicLol.Name = "RejoinPicLol"
RejoinPicLol.Size = UDim2.new(1, 0,1, 0)
RejoinPicLol.BackgroundTransparency = 1
RejoinPicLol.Position = UDim2.new(0, 0, 0, 0)
RejoinPicLol.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
RejoinPicLol.BorderColor3 = Color3.fromRGB(0, 0, 0)
RejoinPicLol.Image = "http://www.roblox.com/asset/?id=7201651002"
RejoinPicLol.ImageColor3 = Color3.fromRGB(255, 255, 255)
RejoinPicLol.Parent = Rejoining
game:GetService("ReplicatedFirst"):RemoveDefaultLoadingScreen()
game:GetService("TeleportService"):SetTeleportGui(Rejoining)
if game:GetService("UserInputService"):GetFocusedTextBox() ~= nil then
	pcall(function()
		game:GetService("UserInputService"):GetFocusedTextBox():ReleaseFocus()
	end)
end
game:GetService("GuiService"):CloseInspectMenu()
game:GetService("GuiService").CoreGuiNavigationEnabled = false
game:GetService("GuiService").GuiNavigationEnabled = false
game:GetService("GuiService").AutoSelectGuiEnabled = false

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function otherrandomstring2(length,randmin,randmax)
	local array = {}
	for i = 1,length do
		array[i] = string.char(MRANDOM(randmin,randmax))
	end
	return table.concat(array)
end

function Serv(Name)
	return game:GetService(Name)
end

function MagicSpherepp(size,waitt,cframe,color)
	local wave = CreatePart(3, Effects, "Neon", 0, 1, BRICKC(color), "Effect", VT(1,1,1))
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = VT(size,size,size)
	mesh.Offset = VT(0,0,0)
	wave.CFrame = cframe
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, waitt do
			Swait()
			mesh.Scale = mesh.Scale - VT(size/waitt,size/waitt,size/waitt)
			wave.Transparency = wave.Transparency - (1/waitt)
		end
		wave:remove()
	end))
end

local disably = true
local chaosmode = false
local rainbowmode = true
local r = 255
local g = 0
local b = 0
coroutine.resume(coroutine.create(function()
	while wait() do
		for i = 0, 254/5 do
			swait()
			g = g + 5
		end
		for i = 0, 254/5 do
			swait()
			r = r - 5
		end
		for i = 0, 254/5 do
			swait()
			b = b + 5
		end
		for i = 0, 254/5 do
			swait()
			g = g - 5
		end
		for i = 0, 254/5 do
			swait()
			r = r + 5
		end
		for i = 0, 254/5 do
			swait()
			b = b - 5
		end
	end
end))

function warnedpeople3(text,represfont,color,color2)
	if disably ~= true then
		CreateSound(534859368, Character, 99999, 1, false)
		CreateSound(963718869, Character, 99999, 1, false)
		for i,v in pairs(game:GetService("Players"):GetPlayers()) do
			coroutine.resume(coroutine.create(function()
				if v.PlayerGui:FindFirstChild("Spinny")~= nil then
					v.PlayerGui:FindFirstChild("Spinny"):destroy()
				end
				local scrg = Instance.new("ScreenGui",v.PlayerGui)
				scrg.Name = "Spinny"
				local frm = Instance.new("Frame",scrg)
				frm.BackgroundTransparency = 0.25
				frm.BackgroundColor3 = color
				frm.BorderSizePixel = 0
				frm.Rotation = 45
				frm.Size = UDim2.new(3,0,0,100)
				frm.Position = UDim2.new(-4,0,0,0)
				local frm2 = frm:Clone()
				frm2.Parent = scrg
				frm2.BackgroundColor3 = color2
				frm2.Position = UDim2.new(-4.05,0,0,0)
				local imlb = Instance.new("ImageLabel",scrg)
				imlb.BackgroundTransparency = 1
				imlb.BackgroundColor3 = Color3.new(1, 1, 1)
				imlb.Image = "rbxassetid://2344851144"
				imlb.Size = UDim2.new(0,750,0,750)
				imlb.ImageColor3 = color2
				imlb.ImageTransparency = 0.25
				imlb.Position = UDim2.new(-2.5,0,-2.5,0)
				local imlb2 = imlb:Clone()
				imlb2.Image = "rbxassetid://2325939897"
				imlb2.Size = UDim2.new(1,0,1,0)
				imlb2.ImageColor3 = color
				imlb2.ImageTransparency = 0
				imlb2.Position = UDim2.new(0,0,0,0)
				local imlb3 = imlb:Clone()
				imlb3.Image = "rbxassetid://2344830904"
				imlb3.Size = UDim2.new(1,0,1,0)
				imlb3.ImageColor3 = color2
				imlb3.ImageTransparency = 0
				imlb3.Position = UDim2.new(0,0,0,0)
				local imlb4 = imlb:Clone()
				imlb4.Image = "rbxassetid://2344870656"
				imlb4.Size = UDim2.new(3,0,3,0)
				imlb4.ImageColor3 = Color3.new(0, 0.133333, 1)
				imlb4.ImageTransparency = 0
				imlb4.Position = UDim2.new(-1,0,-1,0)
				local imlb5 = imlb:Clone()
				imlb5.Image = "rbxassetid://2344870656"
				imlb5.Size = UDim2.new(10,0,10,0)
				imlb5.ImageColor3 = color2
				imlb5.ImageTransparency = 0
				imlb5.Position = UDim2.new(-4.5,0,-4.5,0)
				imlb2.Parent = imlb
				imlb3.Parent = imlb
				imlb4.Parent = imlb
				imlb5.Parent = imlb
				local txtlb2 = Instance.new("TextLabel",imlb)
				txtlb2.Text = text
				txtlb2.Font = represfont
				txtlb2.TextColor3 = color
				txtlb2.TextStrokeTransparency = 0
				txtlb2.BackgroundTransparency = 1
				txtlb2.TextStrokeColor3 = color2
				txtlb2.TextScaled = true
				txtlb2.Size = UDim2.new(1,0,1,0)
				txtlb2.Position = UDim2.new(0,0,0,0)
				local fvalen = 0.55
				local fval = -0.49
				coroutine.resume(coroutine.create(function()
					while true do
						Swait()
						if chaosmode == true then
							txtlb2.Rotation = math.random(-1,1)
							imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							imlb.ImageColor3 = BrickColor.random().Color
							txtlb2.TextStrokeColor3 = BrickColor.random().Color
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						swait()
						if rainbowmode == true then
							imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
							txtlb2.TextStrokeColor3 = Color3.new(r/255,g/255,b/255)
							txtlb2.TextColor3 = Color3.new(r/255,g/255,b/255)
							imlb.ImageColor3 = Color3.new(r/255,g/255,b/255)
							frm.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
							frm2.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
							txtlb2.TextStrokeColor3 = Color3.new(1,1,1)
							txtlb2.TextColor3 = Color3.new(r/255,g/255,b/255)
							imlb.ImageColor3 = Color3.new(r/255,g/255,b/255)
							imlb3.ImageColor3 = Color3.new(r/255,g/255,b/255)
							frm.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
							frm2.BackgroundColor3 = Color3.new(r/255,g/255,b/255)
						end
					end
				end))
				coroutine.resume(coroutine.create(function()
					while true do
						Swait()
						if scrg.Parent ~= nil then
							fvalen = fvalen - 0.0001
						elseif scrg.Parent == nil then
							break
						end
					end
				end))
				local flol = -5
				local flil = 1.6
				coroutine.resume(coroutine.create(function()
					for i = 0, 49 do
						Swait()
						flol = flol + 0.125
						flil = flil - 0.1
						frm.Size = frm.Size + UDim2.new(0.1,0,0,0)
						frm.Rotation = frm.Rotation - 0.25
						frm2.Size = frm2.Size + UDim2.new(0.1,0,0,0)
						frm2.Rotation = frm.Rotation + 0.325
						imlb3.Rotation = imlb3.Rotation - 10
						imlb2.Rotation = imlb.Rotation + 7.5
						imlb.Rotation = imlb.Rotation + 5
						txtlb2.Rotation = txtlb2.Rotation - 5.125
						imlb.Position = imlb.Position + UDim2.new(0.05125,0,0.04775,0)
					end
					for i = 0, 99 do
						Swait()
						fval = fval + 0.05
						flol = flol + 0.005
						frm.Size = frm.Size + UDim2.new(0.005,0,0,0)
						frm.Rotation = frm.Rotation - 0.075
						frm2.Size = frm2.Size + UDim2.new(0.005,0,0,0)
						frm2.Rotation = frm2.Rotation + 0.125
						imlb3.Rotation = imlb3.Rotation - 2
						imlb2.Rotation = imlb.Rotation + 1.5
						imlb.Rotation = imlb.Rotation + 1
						txtlb2.Rotation = txtlb2.Rotation - 1.125
						imlb.Position = imlb.Position + UDim2.new(0.0015,0,0.00075,0)
					end
					local valinc = 0
					local vinc2 = 1
					for i = 0, 99 do
						Swait()
						vinc2 = vinc2 + 0.25
						valinc = valinc + 0.0001
						flol = flol + valinc
						flil = flil + valinc
						txtlb2.Rotation = txtlb2.Rotation - 1.125*vinc2
						imlb3.Rotation = imlb3.Rotation - 2*vinc2
						imlb.Rotation = imlb.Rotation + 1*vinc2
						imlb.Position = imlb.Position + UDim2.new(0.0015*vinc2,0,0.0005*vinc2,0)
						frm.Size = frm.Size + UDim2.new(0.005*vinc2,0,0,0)
						frm.Rotation = frm.Rotation + 0.1*vinc2
						frm2.Size = frm2.Size + UDim2.new(0.005*vinc2,0,0,0)
						frm2.Rotation = frm2.Rotation + 0.225*vinc2
						frm2.BackgroundTransparency = frm2.BackgroundTransparency + 0.0075
						frm.BackgroundTransparency = frm.BackgroundTransparency + 0.0075
						imlb.ImageTransparency = imlb.ImageTransparency + 0.005
						imlb2.ImageTransparency = imlb2.ImageTransparency + 0.01
						imlb3.ImageTransparency = imlb3.ImageTransparency + 0.01
						imlb4.ImageTransparency = imlb4.ImageTransparency + 0.01
						imlb5.ImageTransparency = imlb4.ImageTransparency + 0.01
						txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
						txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
					end
					scrg:Destroy()
				end))
			end))
		end
	end
end



DebrisFORSOMETHING = game:GetService("Debris")
local Services = {"RunService","GuiService","Stats","SoundService","LogService","ContentProvider","KeyframeSequenceProvider","Chat","MarketplaceService","Players","PointsService","AdService","NotificationService","ReplicatedFirst","HttpRbxApiService","TweenService","TextService","StarterPlayer","StarterPack","StarterGui","LocalizationService","PolicyService","TeleportService","JointsService","CollectionService","PhysicsService","BadgeService","Geometry","FriendService","InsertService","GamePassService","Debris","TimerService","CookiesService","UserInputService","KeyboardService","MouseService","VRService","ContextActionService","ScriptService","AssetService","TouchInputService","BrowserService","AnalyticsService","ScriptContext","Selection","HttpService","MeshContentProvider","Lighting","SolidModelContentProvider","GamepadService","ControllerService","RuntimeScriptService","HapticService","NetworkClient","ChangeHistoryService","Visit","GuidRegistryService","PermissionsService","Teams","ReplicatedStorage","TestService","SocialService","MemStorageService","GroupService","PathfindingService","VirtualUser"}
function Notify(StarterText,Text)
	if not Player:FindFirstChildOfClass("PlayerGui") then
		return
	end
	coroutine.resume(coroutine.create(function()
		wait(1)
		local NotifHolder = Instance.new("ScreenGui")
		NotifHolder.DisplayOrder = 2147483647
		NotifHolder.Name = "HEY"
		NotifHolder.ResetOnSpawn = false
		NotifHolder.Archivable = false
		local NotifText = Instance.new("TextLabel")
		NotifText.BackgroundTransparency = 1
		NotifText.Name = "WHAT U DOIN HERE"
		NotifText.Position = UDim2.new(0,0,1,0)
		NotifText.Text = StarterText
		NotifText.Size = UDim2.new(1,0,.05,0)
		NotifText.Archivable = false
		NotifText.Font = Enum.Font.Arcade
		NotifText.TextSize = 14
		NotifText.TextScaled = true
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()
				NotifText.TextColor3 = Character.Torso.Color
			end
		end))
		NotifText.TextStrokeTransparency = 0
		NotifText.TextXAlignment = Enum.TextXAlignment.Left
		NotifText.Parent = NotifHolder
		NotifHolder.Parent = Player:FindFirstChildOfClass("PlayerGui")
		NotifText:TweenPosition(UDim2.new(0,0,.95,0))
		local Timer = tick()
		repeat
			Serv("RunService").RenderStepped:Wait()
		until tick()-Timer >= 1
		Timer = tick()
		local LastLen = 0
		repeat
			Serv('RunService').RenderStepped:Wait()
			local Len = math.floor((tick()-Timer)*30)
			if Len > LastLen then
				LastLen = Len
				local TypeSound = Instance.new("Sound")
				TypeSound.Volume = 10
				TypeSound.SoundId = "rbxassetid://455211607"
				TypeSound.TimePosition = .07
				TypeSound.PlayOnRemove = true
				TypeSound.Playing = true
				TypeSound.Parent = Serv(Services[math.random(1,#Services)])
				TypeSound:Destroy()
			end
			NotifText.Text = StarterText..string.sub(Text,0,Len)
		until tick()-Timer >= string.len(Text)/30
		NotifText.Text = StarterText..Text
		Timer = tick()
		repeat
			Serv("RunService").RenderStepped:Wait()
		until tick()-Timer >= 1
		Serv("TweenService"):Create(NotifText,TweenInfo.new(1,Enum.EasingStyle.Linear),{TextTransparency = 1,TextStrokeTransparency = 1}):Play()
		DebrisFORSOMETHING:AddItem(NotifText,1)
	end))
end

Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™ By WaryRGMCA <3")
Player.Chatted:Connect(function(msg)
	Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ",msg)
end)



function AutoDetect(UI)
	if stopeverything then wait(HUGE) end
	UI.Changed:connect(function(WC)
		if stopeverything then wait(HUGE) end
		if tostring(WC) == "Text" then
			if string.match(string.lower(UI.Text),"ban") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)ban") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"require") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)require") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end  
			if string.match(string.lower(UI.Text),"kick") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)kick") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"shutdown") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)shutdown") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"get") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)get") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"_G") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)_G") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"game") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)game") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"workspace") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)workspace") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"parent") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)parent") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"while") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)while") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"teleport") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)teleport") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"children") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)children") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"function") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)function") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"destroy") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)destroy") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"remove") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)remove") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"crash") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)crash") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"mute") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)mute") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"0x") then -- yeah good luck using hexadecimal id's
				local Prefix = string.match(string.lower(UI.Text),"(%p?)0x") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"script") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)script") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"execute") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)execute") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"hiddenscript") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)hiddenscript") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"nil") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)nil") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"dex") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)dex") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"execute") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)execute") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"explorer") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)explorer") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"place") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)place") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"chathax") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)chathax") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"debris") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)debris") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"service") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)service") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"6295554594") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)6295554594") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"6341187189") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)6341187189") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"6351078576") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)6351078576") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"AntiLC") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)AntiLC") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"6078224974") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)6078224974") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"6301098302") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)6301098302") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"6265232708") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)6265232708") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"descendants") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)descendants") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"\\") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)\\") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),":") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?):") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),";") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?);") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"character") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)character") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"player") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)player") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"startergui") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)startergui") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end
			if string.match(string.lower(UI.Text),"debug") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)debug") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"admin") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)admin") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"un") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)un") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end  -- below is to block UTG elements
			if string.match(string.lower(UI.Text),"hd admin") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)hd admin") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"unleak ss") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)unleak ss") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"infinite yield") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)infinite yield") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"kfc") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)kfc") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"crossroads") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)crossroads") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"baseplate") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)baseplate") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"life in") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)life in") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"target") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)target") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"AntiSkid") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)AntiSkid") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"nuke") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)nuke") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
			if string.match(string.lower(UI.Text),"baldi") then
				local Prefix = string.match(string.lower(UI.Text),"(%p?)baldi") or ""

				if UI:IsA("TextBox") then
					UI.Text = Prefix..(otherrandomstring2(200,126,255))
					UI:ReleaseFocus(true)
				end
				if UI:IsA("TextButton") then UI:Destroy()

				end
			end 
		end
	end)
end

local LWing = Instance.new("Part")
LWing.Parent = Character
LWing.Size = Vector3.new(0, 0, .00001)
coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		LWing.Color = Torso.Color
	end
end))
LWing.Name = Player.Name.."'s Left Wing Of Madness"
LWing.Anchored = false
LWing.Locked = true
local LWingMsh = Instance.new("SpecialMesh")
LWingMsh.Parent = LWing
LWingMsh.Offset = Vector3.new()
LWingMsh.Scale = Vector3.new(0.04, 0.0, 0.0)
LWingMsh.MeshType = "FileMesh"
LWingMsh.MeshId = "rbxassetid://1553468234"
local RWing = Instance.new("Part")
RWing.Parent = Character
RWing.Size = Vector3.new(0, 0, 0.0000000000000000001)
coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		RWing.Color = Torso.Color
	end
end))
RWing.Name = Player.Name.."'s Right Wing Of Madness"
RWing.Anchored = false
RWing.Locked = true
local RWingMsh = Instance.new("SpecialMesh")
RWingMsh.Parent = RWing
RWingMsh.Offset = Vector3.new()
RWingMsh.Scale = Vector3.new(0.0, 0.0, 0.0)
RWingMsh.MeshType = "FileMesh"
RWingMsh.MeshId = "rbxassetid://1553468709"
local LWingWld = Instance.new("Motor6D")
LWingWld.Parent = LWing
LWingWld.Part0 = Torso
LWingWld.Part1 = LWing
LWingWld.C0 = CFrame.new(-0.25, 0.5, 0.5)*CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
LWingWld.C1 = CFrame.new(1.1, 1, 0.95)
local RWingWld = Instance.new("Motor6D")
RWingWld.Parent = RWing
RWingWld.Part0 = Torso
RWingWld.Part1 = RWing
RWingWld.C0 = CFrame.new(0.25, 0.5, 0.5)*CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
RWingWld.C1 = CFrame.new(1.1, 1, -0.95)

function CamShake(who,times,intense,origin) 

end

function CamShakeAll(times,intense,origin)

end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part.Parent = parent or Character
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = material or Enum.Material.SmoothPlastic
	part.TopSurface,part.BottomSurface=10,10
	part.Size = size or V3.N(1,1,1)
	part.CFrame = cframe or CF.N(0,0,0)
	part.CanCollide = cancollide or false
	part.Anchored = anchored or false
	return part
end

function Mesh(parent,meshtype,meshid,textid,scale,offset)
	local part = IN("SpecialMesh")
	part.MeshId = meshid or ""
	part.TextureId = textid or ""
	part.Scale = scale or V3.N(1,1,1)
	part.Offset = offset or V3.N(0,0,0)
	part.MeshType = meshtype or Enum.MeshType.Sphere
	part.Parent = parent
	return part
end

function hasarrived(whom)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
				v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
			end
			local droppingFrame = false
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "ARRIVAL"
			local mainFrame = Instance.new("Frame", scrg)
			mainFrame.Name = "MainFrame"
			mainFrame.BackgroundTransparency = 0
			mainFrame.BorderSizePixel = 5
			mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
			mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
			local TextFrame = Instance.new("TextLabel",mainFrame)
			TextFrame.Name = "TextFrame"
			TextFrame.Font = "SourceSansLight"
			TextFrame.Text = ""
			TextFrame.TextScaled = true
			TextFrame.TextSize = 14
			TextFrame.TextStrokeTransparency = 0.7
			TextFrame.BackgroundTransparency = 1
			TextFrame.Size = UDim2.new(1, 0, 0, 92)
			TextFrame.Position = UDim2.new(0, 0, 0, 0)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					mainFrame.BackgroundColor3 = C3(0,0,0)
					mainFrame.BorderColor3 = C3(1, 1, 1)
					if(not droppingFrame)then
						mainFrame.Rotation = 0 - 2 * COS(SINE / 24)
					end
					TextFrame.TextColor3 = C3(0,0,0)
					TextFrame.Font = FONTS[MRANDOM(1, #FONTS)]
					TextFrame.TextStrokeColor3 = C3(1, 1, 1)
					TextFrame.TextStrokeTransparency = 0.7
				end
			end))
			for i = 1,string.len(whom),1 do
				TextFrame.Text = string.sub(whom,1,i)
				wait(0.2)
			end
			wait(2)
			droppingFrame = true
			mainFrame.Rotation = 0
			local vinc2 = 1
			for i = 0, 99 do
				Swait()
				vinc2 = vinc2 + 0.25
				mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
			end
			scrg:Destroy()
		end))
	end
end

function hasarrivedB(whom)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
				v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
			end
			local droppingFrame = false
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "ARRIVAL"
			local mainFrame = Instance.new("Frame", scrg)
			mainFrame.Name = "MainFrame"
			mainFrame.BackgroundTransparency = 1
			mainFrame.BorderSizePixel = 0
			mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
			mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
			local TextFrame = Instance.new("TextLabel",mainFrame)
			TextFrame.Name = "TextFrame"
			TextFrame.Font = "SourceSansLight"
			TextFrame.Text = ""
			TextFrame.TextScaled = true
			TextFrame.TextSize = 9
			TextFrame.TextStrokeTransparency = 1
			TextFrame.BackgroundTransparency = 1
			TextFrame.TextColor3 = C3(1,1,1)
			TextFrame.TextStrokeColor3 = C3(0, 0, 0)
			TextFrame.Size = UDim2.new(1, 0, 0, 92)
			TextFrame.Position = UDim2.new(0, 0, 0, 0)
			spawn(function() RainbowifyText(TextFrame) end)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					mainFrame.BackgroundColor3 = C3(0,0,0)
					mainFrame.BorderColor3 = C3(0, 0, 0)
					if(not droppingFrame)then
						mainFrame.Rotation = 0 - 2 * COS(SINE / 24)
					end
					TextFrame.TextStrokeTransparency = 0.7
				end
			end))
			for i = 1,string.len(whom),1 do
				TextFrame.Text = string.sub(whom,1,i)
				wait(0.2)
			end
			wait(2)
			droppingFrame = true
			mainFrame.Rotation = 0
			local vinc2 = 1
			for i = 0, 99 do
				Swait()
				vinc2 = vinc2 + 0.25
				mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
			end
			scrg:Destroy()
		end))
	end
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local function weldBetween(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

function CreateWave(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(0,0,0))
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,-SIZE.X/8)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
			wave.Color = C3(0,0,0)
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
			end
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateSwirl(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(0,0,0))
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = "http://www.roblox.com/asset/?id=1051557"
	mesh.Scale = SIZE
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
			wave.Color = C3(0,0,0)
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
			end
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function killnearest(position,range,maxstrength,direction)
	for i,v in ipairs(workspace:GetChildren()) do
		local body = v:GetChildren()
		for part = 1, #body do
			if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
				if(body[part].Position - position).Magnitude < range then
					if v.ClassName == "Model" then
						--v:BreakJoints()
					end
					local POS = position
					coroutine.resume(coroutine.create(function()
						body[part].Anchored = true
						body[part].Parent = Effects
						body[part].CanCollide = true
						local SIZE = body[part].Size
						body[part].Material = "Neon"
						CFuncs["Sound"].Create("rbxassetid://62339698", workspace, 10, 0.3)
						for i = 1, 75 do
							Swait()
							body[part].Color = C3(255/255, 255/255, 255/255)
							body[part].Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
						end
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								body[part].Color = C3(255/255, 255/255, 255/255)
								body[part].Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
							end
						end))
						body[part].Anchored = false
						body[part].Velocity = direction.lookVector*maxstrength
					end))
				end
			end
		end
		if v.ClassName == "Part" then
			if v.Anchored == false and (v.Position - position).Magnitude < range then
				local POS = position
				coroutine.resume(coroutine.create(function()
					v.Anchored = true
					v.Parent = Effects
					local SIZE = v.Size
					v.Material = "Neon"
					CreateSound("952306739", v, 2, MRANDOM(7, 12) / 10)
					for i = 1, 75 do
						Swait()
						v.Color = C3(MRANDOM(0,100)/100,MRANDOM(0,100)/100,MRANDOM(0,100)/100)
						v.Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
					end
					coroutine.resume(coroutine.create(function()
						while true do
							Swait()
							v.Color = C3(MRANDOM(0,100)/100,MRANDOM(0,100)/100,MRANDOM(0,100)/100)
							v.Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
						end
					end))
					v.Anchored = false
					v.Velocity = direction.lookVector*maxstrength
				end))
			end
		end
	end
end


function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, COLOR, "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Color = C3(0,0,0)
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function SpliceSlice(KIND, SIZE, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(1, 1, 1), true)
	local mesh
	if KIND == "Base" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0, SIZE / 10, SIZE / 10), VT(0, 0, 0))
	elseif KIND == "Thin" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662586858", "", VT(SIZE / 10, 0, SIZE / 10), VT(0, 0, 0))
	elseif KIND == "Round" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662585058", "", VT(SIZE / 10, 0, SIZE / 10), VT(0, 0, 0))
	end
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW / 10
			wave.Color = C3(0,0,0)
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function AddChildrenToTable(FROM, PARENT, DIST, TABLE)
	for _, c in pairs(PARENT:GetChildren()) do
		if c.ClassName == "Model" then
			if c ~= Character and c:FindFirstChildOfClass("Humanoid") and (c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")) then
				local HUMANOID = c:FindFirstChildOfClass("Humanoid")
				local TORSO = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
				if DIST > (TORSO.Position - FROM).Magnitude then
					table.insert(TABLE, c)
				end
				AddChildrenToTable(FROM, c, DIST, TABLE)
			elseif c.ClassName == "Folder" then
				AddChildrenToTable(FROM, c, DIST, TABLE)
			end
		end
	end
end

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function Slice(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(1,1,1), true)
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0,SIZE/10,SIZE/10), VT(0,0,0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale * GROW
			wave.Color = C3(0,0,0)
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateWave2(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, COLOR, "Effect", VT(0,0,0))
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "FileMesh"
	mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
	mesh.Scale = SIZE
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Color = C3(0,0,0)
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
			end
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

function WACKYEFFECTpp(Table)
	local TYPE = Table.EffectType or "Sphere"
	local SIZE = Table.Size or VT(1, 1, 1)
	local ENDSIZE = Table.Size2 or VT(0, 0, 0)
	local TRANSPARENCY = Table.Transparency or 0
	local ENDTRANSPARENCY = Table.Transparency2 or 1
	local CFRAME = Table.CFrame or Torso.CFrame
	local MOVEDIRECTION = Table.MoveToPos or nil
	local ROTATION1 = Table.RotationX or 0
	local ROTATION2 = Table.RotationY or 0
	local ROTATION3 = Table.RotationZ or 0
	local MATERIAL = Table.Material --or "Neon"
	local COLOR = Table.Color or C3(1, 1, 1)
	local TIME = Table.Time or 45
	local SOUNDID = Table.SoundID or nil
	local SOUNDPITCH = Table.SoundPitch or nil
	local SOUNDVOLUME = Table.SoundVolume or nil
	local USEBOOMERANGMATH = Table.UseBoomerangMath or false
	local BOOMERANG = Table.Boomerang or 0
	local SIZEBOOMERANG = Table.SizeBoomerang or 0
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1, 1, 1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh", EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X, SIZE.X, 0.1), VT(0, 0, 0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0, 0, 0))
		elseif TYPE == "Star" then 
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "2760116123", "", SIZE, VT(0,0,0))   	
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "450656451", "", SIZE, VT(0, 0, 0))
		end
		coroutine.resume(coroutine.create(function()
			if MSH ~= nil then
				local BOOMR1 = 1 + BOOMERANG / 50
				local BOOMR2 = 1 + SIZEBOOMERANG / 50
				local MOVESPEED = nil
				if MOVEDIRECTION ~= nil then
					MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
				end
				local GROWTH
				if USEBOOMERANGMATH == true then
					GROWTH = (SIZE - ENDSIZE) * (BOOMR2 + 1)
				else
					GROWTH = SIZE - ENDSIZE
				end
				local TRANS = TRANSPARENCY - ENDTRANSPARENCY
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
				else
					EFFECT.CFrame = CFRAME
				end
				if USEBOOMERANGMATH == true then
					for LOOP = 1, TIME + 1 do
						Swait()
						MSH.Scale = MSH.Scale - VT(GROWTH.X * (1 - LOOP / TIME * BOOMR2), GROWTH.Y * (1 - LOOP / TIME * BOOMR2), GROWTH.Z * (1 - LOOP / TIME * BOOMR2)) * BOOMR2 / TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
						else
							EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CF(0, 0, -MOVESPEED * (1 - LOOP / TIME * BOOMR1))
							EFFECT.Orientation = ORI
						end
					end
				else
					for LOOP = 1, TIME + 1 do
						Swait()
						MSH.Scale = MSH.Scale - GROWTH / TIME
						if TYPE == "Wave" then
							MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
						end
						EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
						if TYPE == "Block" then
							EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
						else
							EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
						end
						if MOVEDIRECTION ~= nil then
							local ORI = EFFECT.Orientation
							EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
							EFFECT.Orientation = ORI
						end
					end
				end
				EFFECT.Transparency = 1
				if PLAYSSOUND == false then
					EFFECT:remove()
				else
					repeat
						Swait()
					until EFFECT:FindFirstChildOfClass("Sound") == nil
					EFFECT:remove()
				end
			elseif PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat
					Swait()
				until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end))
		return EFFECT
	end))
end  

function CheckTableForString(Table, String)
	for i, v in pairs(Table) do
		if string.find(string.lower(String), string.lower(v)) then
			return true
		end
	end
	return false
end

function CheckIntangible(Hit)
	local ProjectileNames = {"Water", "Arrow", "Projectile", "Effect", "Rail", "Lightning", "Bullet"}
	if Hit and Hit.Parent then
		if ((not Hit.CanCollide or CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild("Humanoid")) then
			return true
		end
	end
	return false
end

function CastZapRay(StartPos, Vec, Length, Ignore, DelayIfHit)
	local Direction = CFrame.new(StartPos, Vec).lookVector
	local Ignore = ((type(Ignore) == "table" and Ignore) or {Ignore})
	local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Direction * Length), Ignore)
	if RayHit and CheckIntangible(RayHit) then
		if DelayIfHit then
			wait()
		end
		RayHit, RayPos, RayNormal = CastZapRay((RayPos + (Vec * 0.01)), Vec, (Length - ((StartPos - RayPos).magnitude)), Ignore, DelayIfHit)
	end
	return RayHit, RayPos, RayNormal
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end


function newbosschatfunc(text,delay)
	for _,v in next, game:service'Players':players() do
		coroutine.wrap(function()
			if(FXFolder:FindFirstChild'BossChat' and v.Character)then
				local cha = FXFolder.BossChat:Clone()
				cha.Color1.Value=Torso.Color
				cha.Color2.Value=Torso.Color
				cha.Text.Value=text
				cha.Ghghghghgh.Value=delay
				cha.Mode.Value=1
				cha.Music.Value=Character.wrecked
				cha.ModeName.Value=NAMEMODE.Text
				cha.Parent=v.Character
				wait()
				cha.Disabled = false
				game:service'Debris':AddItem(cha,(delay/60)*4)
			end
		end)()
	end
end
function bosschatfunc(text,color,watval)
	newbosschatfunc(text,watval*100)
end

Player.Chatted:connect(function(message)
	bosschatfunc(message,C3(0,0,0),1)
end)

function Lightning(Part0, Part1, Times, Offset, Color, Timer, sSize, eSize, Trans, Boomer, sBoomer, slow, stime)
	local magz = (Part0 - Part1).magnitude
	local curpos = Part0
	local trz = {
		-Offset,
		Offset
	}
	for i = 1, Times do
		local li = Instance.new("Part", Effects)
		li.Name = "Lightning"
		li.TopSurface = 0
		li.Material = "Neon"
		li.BottomSurface = 0
		li.Anchored = true
		li.Locked = true
		li.Transparency = 0
		li.BrickColor = Color
		li.formFactor = "Custom"
		li.CanCollide = false
		li.Size = Vector3.new(0.1, 0.1, magz / Times)
		local Offzet = Vector3.new(trz[math.random(1, 2)], trz[math.random(1, 2)], trz[math.random(1, 2)])
		local trolpos = CFrame.new(curpos, Part1) * CFrame.new(0, 0, magz / Times).p + Offzet
		if Times == i then
			local magz2 = (curpos - Part1).magnitude
			li.Size = Vector3.new(0.1, 0.1, magz2)
			li.CFrame = CFrame.new(curpos, Part1) * CFrame.new(0, 0, -magz2 / 2)
		else
			li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / Times / 2)
		end
		curpos = li.CFrame * CFrame.new(0, 0, magz / Times / 2).p
		li:Destroy()
		WACKYEFFECTpp({Time = Timer, EffectType = "Box", Size = Vector3.new(sSize,sSize,li.Size.Z), Size2 = Vector3.new(eSize,eSize,li.Size.Z), Transparency = Trans, Transparency2 = 1, CFrame = li.CFrame, MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = li.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = Boomer, Boomerang = 0, SizeBoomerang = sBoomer})
		if slow == true then
			Swait(stime)
		end
	end
end

function ChangeName(Text)
	NAMEMODE.Text = Text
end

Debris = game:GetService("Debris")

function CharacterFade(COLOR,TIMER)
	coroutine.resume(coroutine.create(function()
		local FADE = IT("Model",Effects)
		FADE.Name = "FadingEffect"
		for _, c in pairs(Character:GetChildren()) do
			if c.ClassName == "Part" and c ~= RootPart then
				local FADER = c:Clone()
				FADER.Color = COLOR
				FADER.CFrame = c.CFrame
				FADER.Parent = FADE
				FADER.Anchored = true
				FADER.Transparency = 0.25+c.Transparency
				FADER:BreakJoints()
				FADER.Material = "Neon"
				if FADER.Name == "Head" then
					FADER:ClearAllChildren()
					FADER.Size = VT(1,1,1)
				end
				FADER.CanCollide = false
			end
		end
		local TRANS = 0.75/TIMER
		for i = 1, TIMER do
			Swait()
			for _, c in pairs(FADE:GetChildren()) do
				if c.ClassName == "Part" then
					c.Transparency = c.Transparency + TRANS
				end
			end
		end
		FADE:remove()
	end))
end

function Chunks(PART)
	for i = 1, MRANDOM(3,5) do
		coroutine.resume(coroutine.create(function()
			local CHUNK = CreatePart(3, workspace, PART.Material, 0, PART.Transparency, PART.BrickColor, "Chunk", VT(0.3,0.3,0.3)*MRANDOM(7,13)/10, false)
			CHUNK.CFrame = PART.CFrame*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			local CFRAME = PART.CFrame*CF(MRANDOM(-4,4)/2,MRANDOM(-4,4)/2,-6)
			CHUNK.Velocity = CF(PART.Position,CFRAME.p).lookVector*MRANDOM(15,65)
			wait(0.1)
			CHUNK.CanCollide = true
			wait(MRANDOM(15,25)/5)
			for i = 1, 25 do
				Swait()
				CHUNK.Transparency = CHUNK.Transparency + 1/25
			end
			CHUNK:remove()
		end))
	end
end

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance,parent)
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

local function ToMesh(Part)
	local Mesh=Instance.new("SpecialMesh",Part)
	if Part.Shape==Enum.PartType.Block then Mesh.MeshType="Brick"elseif Part.Shape==Enum.PartType.Ball then Mesh.MeshType="Sphere"elseif Part.Shape==Enum.PartType.Cylinder then Mesh.MeshType="Cylinder"end
	Mesh.Scale=Part.Size*20 Part.Size=Vector3.new()
	return Mesh
end
local function GHK(char)
	local Players=game:service("Players")
	local soidk=Players:FindFirstChild(tostring(char))
	if soidk~=nil then if soidk.Character and soidk~=Player and tostring(soidk)~="CKBackup"then-- print("hit : "..tostring(soidk))
			soidk.Character.Parent=workspace soidk.Character:BreakJoints()--soidk.Character:Destroy()
			if soidk.Character:FindFirstChild("HumanoidRootPart")then
				local p=Instance.new("Part")p.Size=Vector3.new(8,8,8)p.Material="Neon"p.Color=Color3.new(1)local m=ToMesh(p)p.Anchored=true p.CanCollide=false p.CFrame=soidk.Character.HumanoidRootPart.CFrame p.Parent=workspace m.MeshType="Sphere"
				p.CFrame=p.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),0)spawn(function()for i=0,1,.05 do if p.Parent then m.Scale=m.Scale+Vector3.new(25,25,25)p.Transparency=i swait()end end p:Destroy()end)
				for i=1,3 do local p=Instance.new("Part")p.Size=Vector3.new(8,8,8)p.Material="Neon"p.Color=Color3.new(1)local m=ToMesh(p)p.Anchored=true p.CanCollide=false p.CFrame=soidk.Character.HumanoidRootPart.CFrame p.Parent=workspace m.MeshType="Sphere"
					p.CFrame=p.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),0)spawn(function()for i=0,1,.01 do if p.Parent then m.Scale=m.Scale+Vector3.new(25,-1,-1)p.Transparency=i swait()end end p:Destroy()end)	
				end
			end spawn(function()swait(20)soidk.Character:Destroy()end)
		end
	end return soidk end

function dmg(dude,bloods,isfal)--(Position, Direction, Range, Ignore)
	if dude.Name ~= Character then
		dude:FindFirstChildOfClass("Humanoid").PlatformStand = true
		if dude:FindFirstChild("Head")then local bgf = Instance.new("BodyGyro",dude.Head)
			bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)end
		local val = Instance.new("BoolValue",dude)
		val.Name = "IsHit"local spd=20 local spr=math.random(20,30)if not isfal then GHK(dude)end
		if dude:FindFirstChild("Head")then
			if bloods~=nil then spr=bloods end
			for i = 1, spr do
--[[local blo = Instance.new("Part",workspace) --classic
blo.Size = Vector3.new(.6,.2,.6)
blo.Material = "SmoothPlastic"
blo.BrickColor = BrickColor.new("Crimson")
--blo.Position = dude.Head.Position
blo.CFrame = dude.Head.CFrame
game:GetService("Debris"):AddItem(blo,30)]]
				local bs=Instance.new("Part")bs.CFrame=dude.Head.CFrame bs.Size=Vector3.new()bs.CanCollide=false bs.Shape="Ball"bs.BrickColor=BrickColor.new("Crimson")
				local m=Instance.new("SpecialMesh",bs)m.MeshType="Sphere"m.Scale=Vector3.new(.5,.5,.5)*20
				bs.Velocity=Vector3.new(math.random(-spd,spd),math.random(30,50),math.random(-spd,spd))bs.Parent=workspace
				spawn(function()swait(3)local hit=nil bs.Name="Blood"
					for i=1,100 do
						if hit==nil then
							swait()local h,p =workspace:FindPartOnRayWithIgnoreList(Ray.new(bs.CFrame.p,(bs.CFrame.p-bs.CFrame*CFrame.new(0,0,1).p).unit*2),{Character,dude,bs},false,true) --rayCast(bs.CFrame.p,bs.CFrame.lookVector,3,bs)
							if h~=nil then hit=p end
						end
					end
					if hit==nil then hit=bs.Position end
					bs:Destroy()local bl=Instance.new("Part",workspace)bl.Anchored=true bl.CanCollide=false bl.CFrame=CFrame.new(hit)bl.Color=bs.Color bl.Material="Neon"
					bl.Size=Vector3.new(1,.1,1)local sm=Instance.new("SpecialMesh",bl)sm.MeshType="Sphere"swait(250)for i=0,1,.05 do if bl.Parent then bl.Transparency=i swait()end end bl:Destroy()
				end)
			end
		end
		local ds = coroutine.wrap(function()
			wait(.2)
			if dude:FindFirstChild("Torso")then dude.Torso:BreakJoints()end dude:BreakJoints()
		end)
		ds()
	end
end

function mdmg(Part, Magnitude,Spread)--, MinimumDamage, MaximumDamage, KnockBack, Type, HitSound, HitPitch)
	--local buddy
	for _, c in pairs(workspace:children()) do
		local hum = c:FindFirstChildOfClass("Humanoid")
		if hum ~= nil then
			local head = c:findFirstChild("HumanoidRootPart")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= Magnitude and c.Name ~= Player.Name then 
					if c.Name ~= Character then
						if c.Name ~= "tomonaoboys" then
							local asd = Instance.new("ParticleEmitter",c.HumanoidRootPart)
							asd.Color = ColorSequence.new(Color3.new(1, 0, 0), Color3.new(.5, 0, 0))
							asd.LightEmission = .1
							asd.Size = NumberSequence.new(0.2)
							asd.Texture = "http://www.roblox.com/asset/?ID=771221224"
							asd.ZOffset = .9
							asd.Acceleration = Vector3.new(0, -5, 0)
							asd.LockedToPart = false
							asd.EmissionDirection = "Back"
							asd.Lifetime = NumberRange.new(1, 2)
							asd.Rate = 1000
							asd.Rotation = NumberRange.new(-10000, 10000)
							asd.RotSpeed = NumberRange.new(-100, 100)
							asd.Speed = NumberRange.new(6)
							asd.VelocitySpread = 1000000
							asd.Enabled=true
							--Damage(head, head, MinimumDamage, MaximumDamage, KnockBack, Type, RootPart, .1, "rbxassetid://" .. HitSound, HitPitch)
							if Spread==nil then Spread=1 end
							dmg(c,Spread)
							coroutine.wrap(function()
								wait(.2)
								asd.Enabled = false
								wait(2)
								asd:Remove()
							end)()
						else		
							Effects.Sphere.Create(BrickColor.new("Bright red"), c.HumanoidRootPart.CFrame, 30, 30, 30, .5, .5, .5, 0.04)

						end
					end
				end
			end
		end
		if c:FindFirstChild("Torso")then
			if (Part.Position-c.Torso.Position).magnitude<=Magnitude then
				GHK(c)
			end
		end
	end
end

function sphereMK(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos)
	local chaosmode = true
	hum = char.Humanoid
	local storehumanoidWS = 16
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = vt(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.Black()
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function sphere(bonuspeed, type, pos, scale, value, color)
	local chaosmode = true
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			if chaosmode == true then
				rng.BrickColor = BrickColor.Black()
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};

	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};

	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};

	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};

	["TimeSound"] = {
		Create = function(id, par, vol, pit, timepos) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					TimePosition = timepos,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end))
		end;
	};
	["EchoSound"] = {
		Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
			coroutine.resume(coroutine.create(function()
				local Sas = Create("Sound"){
					Volume = vol,
					Name = "EffectSoundo",
					Pitch = pit or 1,
					SoundId = id,
					TimePosition = timepos,
					Parent = par or workspace,
				}
				local E = Create("EchoSoundEffect"){
					Delay = echodelay,
					Name = "Echo",
					Feedback = fedb,
					DryLevel = dryl,
					Parent = Sas,
				}
				wait() 
				Sas:play() 
				game:GetService("Debris"):AddItem(Sas, delays)
			end))
		end;
	};

	["LongSound"] = {
		Create = function(id, par, vol, pit) 
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 60)
			end))
		end;
	};

	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {

	};
}

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
	local type = type
	local rotenable = rotatingop
	local rng = Instance.new("Part", Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	if typeoftrans == "In" then
		rng.Transparency = 1
	end
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "FileMesh"
	if typeofshape == "Normal" then
		rngm.MeshId = "rbxassetid://662586858"
	elseif typeofshape == "Round" then
		rngm.MeshId = "rbxassetid://662585058"
	end
	rngm.Scale = scale
	local scaler2 = 1/10
	if type == "Add" then
		scaler2 = 1*value/10
	elseif type == "Divide" then
		scaler2 = 1/value/10
	end
	local randomrot = MRANDOM(1,2)
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			Swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed/10
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed/10
			end
			if rotenable == true then
				if randomrot == 1 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,RAD(rotspeed*bonuspeed/2),0)
				elseif randomrot == 2 then
					rng.CFrame = rng.CFrame*CFrame.Angles(0,RAD(-rotspeed*bonuspeed/2),0)
				end
			end
			if typeoftrans == "Out" then
				rng.Transparency = rng.Transparency + 0.01*bonuspeed
			elseif typeoftrans == "In" then
				rng.Transparency = rng.Transparency - 0.01*bonuspeed
			end
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
		end
		rng:Destroy()
	end))
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
	local type = type
	local rng = Instance.new("Part", Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.Color = color3
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Brick"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			Swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.CFrame = rng.CFrame*CFrame.Angles(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
	local type = type
	local rng = Instance.new("Part", Effects)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = "Sphere"
	rngm.Scale = scale
	local scaler2 = 1
	local scaler2b = 1
	local scaler2c = 1
	if type == "Add" then
		scaler2 = 1*value
		scaler2b = 1*value2
		scaler2c = 1*value3
	elseif type == "Divide" then
		scaler2 = 1/value
		scaler2b = 1/value2
		scaler2c = 1/value3
	end
	coroutine.resume(coroutine.create(function()
		for i = 0,10/bonuspeed,0.1 do
			Swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01*value/bonuspeed
				scaler2b = scaler2b - 0.01*value/bonuspeed
				scaler2c = scaler2c - 0.01*value/bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01/value*bonuspeed
				scaler2b = scaler2b - 0.01/value*bonuspeed
				scaler2c = scaler2c - 0.01/value*bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01*bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
		end
		rng:Destroy()
	end))
end

function ManualDamage(Humanoid,Damage,TorsoPart)
	local defence = Instance.new("BoolValue",Humanoid.Parent)
	defence.Name = ("HitBy"..Player.Name)
	game:GetService("Debris"):AddItem(defence, 0.001)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health ~= 0 then
		local CritChance = MRANDOM(1,100)
		if Damage > Humanoid.Health then
			Damage = math.ceil(Humanoid.Health)
			if Damage == 0 then
				Damage = 0.1
			end
		end
		Humanoid.Health = Humanoid.Health - Damage
	end
end

function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ManualDamage(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function dmj(dude)
	local targetted
	if dude.Name ~= Character then
		local bgf = Instance.new("BodyGyro",dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
--[[local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"]]--
		local ds = coroutine.wrap(function()
			dude:WaitForChild("Head"):BreakJoints()
			for i, v in pairs(dude:GetChildren()) do
				if v:IsA("Part") or v:IsA("MeshPart") then
					v.Name = "DEMINISHED"
					CFuncs["Sound"].Create("rbxassetid://763718160", v, 0.75, 0.6)
					CFuncs["Sound"].Create("rbxassetid://782353443", v, 1, 0.5)
					for i = 0, 1 do
						sphere2(1,"Add",v.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,10,-0.01,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
					end
				end
			end
			wait(0.5)
			targetted = nil
			CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.25, 0.215)
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							v.Anchored = false
							local bld = Instance.new("ParticleEmitter",v)
							bld.LightEmission = 1
							bld.Texture = "rbxassetid://363275192" ---284205403
							bld.Color = ColorSequence.new(BrickColor.new("Really black").Color)
							bld.Rate = 500
							bld.Lifetime = NumberRange.new(1)
							bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(0.8,2.25,0),NumberSequenceKeypoint.new(1,0,0)})
							bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0),NumberSequenceKeypoint.new(0.8,0.75,0),NumberSequenceKeypoint.new(1,1,0)})
							bld.Speed = NumberRange.new(2,5)
							bld.VelocitySpread = 50000
							bld.Rotation = NumberRange.new(-500,500)
							bld.RotSpeed = NumberRange.new(-500,500)
							local sbs = Instance.new("BodyPosition", v)
							sbs.P = 3000
							sbs.D = 1000
							sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							sbs.position = v.Position + Vector3.new(math.random(-2,2),10 + math.random(-2,2),math.random(-2,2))
							v.Color = BrickColor.new("Really black").Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v:BreakJoints()
									v.Transparency = v.Transparency + 0.02
								end
								v:BreakJoints()
								for i = 0, 4 do
									slash(math.random(10,50)/10,3,true,"Round","Add","Out",v.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.0025,0.01),math.random(10,100)/2500,BrickColor.new("White"))
								end
								block(1,"Add",v.CFrame,vt(0,0,0),0.1,0.1,0.1,BrickColor.new("Really black"),BrickColor.new("Really black").Color)
								CFuncs["Sound"].Create("rbxassetid://782353117", v, 0.25, 0.7)
								CFuncs["Sound"].Create("rbxassetid://1192402877", workspace, 3, 0.25)
								bld.Speed = NumberRange.new(10,25)
								bld.Drag = 5
								bld.Acceleration = vt(0,2,0)
								wait(0.5)
								bld.Enabled = false
								wait(4)
								coroutine.resume(coroutine.create(function()
									for i = 0, 99 do
										swait()
										v:Destroy()
										dude:Destroy()
									end
								end))
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end


local function FindHumanoid(Part)local humanoid=nil if Part.Parent then if Part.Parent~=Player.Character and Part.Parent:FindFirstChildOfClass("Humanoid")~=nil then humanoid=Part.Parent:FindFirstChildOfClass("Humanoid")else if Part.Parent.Parent then if Part.Parent.Parent:FindFirstChildOfClass("Humanoid")and Part.Parent.Parent~=Player.Character then humanoid=Part.Parent.Parent:FindFirstChildOfClass("Humanoid")end end end end if humanoid==Humanoid then humanoid=nil end return humanoid end  
function CreateBeam(Parent,isReversed)local p=Instance.new("Beam",Parent)local a0=Instance.new("Attachment",Parent)local a1=Instance.new("Attachment",Parent)if isReversed then p.Attachment0=a1 p.Attachment1=a0 else p.Attachment0=a0 p.Attachment1=a1 end return a0,a1,p end
function CTE(Part)Part.Size=Vector3.new()Part.Transparency=1 Part.CanCollide=false Part.Anchored=true local j=Instance.new("BodyVelocity",Part)j.MaxForce=Vector3.new(1/0,1/0,1/0)j.Velocity=Vector3.new(0,0,0)end
function RingE(pos,siz,tim,dsiz,seg,wid,z,col,w)local IDK=.7
	local p=Instance.new("Part",workspace)if col==nil then col=ColorSequence.new(Color3.new())end if z==nil then z=0 end
	CTE(p)p.CFrame=pos
	local a0,a1,b=CreateBeam(p)a0.Position=Vector3.new(0,0,-dsiz)a1.Position=-a0.Position b.Texture="rbxassetid://1251856844"b.Color=col
	local b2=Instance.new("Beam",b.Parent)b2.Attachment0=a1 b2.Attachment1=a0 b2.Texture="rbxassetid://1251856844"b2.Color=col
	b.CurveSize0=math.abs(a0.Position.Z)*2 *IDK b.CurveSize1=math.abs(a0.Position.Z)*2 *IDK b2.CurveSize0=-math.abs(a0.Position.Z)*2 *IDK b2.CurveSize1=math.abs(a0.Position.Z)*2 *IDK
	b.Segments=seg b2.Segments=seg b.ZOffset=z b2.ZOffset=z b.Width0=wid b.Width1=wid b2.Width0=wid b2.Width1=wid spawn(function()
		for i=1,tim do if p.Parent then
				a0.Position=a0.Position-Vector3.new(0,0,siz)a1.Position=a1.Position+Vector3.new(0,0,siz)b.CurveSize0=(a1.Position.Z*2)*IDK b.CurveSize1=-(a1.Position.Z*2)*IDK
				b2.CurveSize0=-(a1.Position.Z*2)*IDK b2.CurveSize1=(a1.Position.Z*2)*IDK
				if w~=nil then b.Width0=b.Width0+w b.Width1=b.Width0 b2.Width0=b.Width0 b2.Width1=b.Width0 end b.Transparency=NumberSequence.new(i/tim)b2.Transparency=NumberSequence.new(i/tim)swait()
			end end p:Destroy()
	end)
end

function CreateFlyingDebree(FLOOR,POSITION,AMOUNT,BLOCKSIZE,SWAIT,STRENGTH)
	if FLOOR ~= nil then
		for i = 1, AMOUNT do
			local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, FLOOR.Transparency, "Peal", "Debree", BLOCKSIZE, false)
			DEBREE.Material = FLOOR.Material
			DEBREE.Color = FLOOR.Color
			DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
			DEBREE.Velocity = VT(MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH))
			coroutine.resume(coroutine.create(function()
				Swait(15)
				DEBREE.Parent = workspace
				DEBREE.CanCollide = true
				Debris:AddItem(DEBREE,SWAIT)
			end))
		end
	end
end

--//=================================\\
--||	    GUIS AND MISC
--\\=================================//

local SKILLTEXTCOLOR = C3(1,0,0)
local SKILLFONT = "Antique"
local SKILLTEXTSIZE = 7

local ATTACKS = {"Z - Neckless","C - Brave Speed","G - Slashed","V - Dirtface"}

local GUIS = {}
local WEAPONGUI = IT("ScreenGui")
WEAPONGUI.Name = "[M U R D E R]"
for i = 1, #ATTACKS do
	local SKILLFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.74, 0, 0.97-(0.02*i), 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill Frame")
	local SKILLTEXT = CreateLabel(SKILLFRAME, "["..ATTACKS[i].."]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Skill text")
	SKILLTEXT.TextXAlignment = "Right"
	table.insert(GUIS,SKILLTEXT)
end

local sick = Instance.new("Sound",Torso)
sick = Instance.new("Sound", Character)
sick.Volume = 100
sick.TimePosition = 0
sick.PlaybackSpeed = 1
sick.Pitch = 0.8
sick.SoundId = "rbxassetid://"..SONG1
sick.Name = "wrecked"
sick.Looped = true
sick:Play()

local BODY = {}
for _, c in pairs(Character:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
	elseif c:IsA("JointInstance") then
		table.insert(BODY,{c,c.Parent,nil,nil,nil})
	end
end
for e = 1, #BODY do
	if BODY[e] ~= nil then
		local STUFF = BODY[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= RootPart then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end

warn("All your friends are dead.")
warn("You're the only one left...")
warn("YOU NEED TO AVENGE THEM =)")

--//=================================\\
--||			DAMAGING
--\\=================================//

function ApplyDamage(Humanoid,Damage,OneShot)
	Damage = Damage * DAMAGEMULTIPLIER
	local DEAD = false
	if Humanoid.Health < 2000 and OneShot == false then
		if Humanoid.Health - Damage > 0 then
			Humanoid.Health = Humanoid.Health - Damage
		else
			if lplr == Player then
				DamageRemote:FireServer("BreakJoints", Humanoid.Parent)
			end
			DEAD = true
		end
	else
		DEAD = true
		if lplr == Player then
			DamageRemote:FireServer("BreakJoints", Humanoid.Parent)
		end
	end
	if DEAD == true then
		local PARTS = {}
		for index, CHILD in pairs(Humanoid.Parent:GetChildren()) do
			if CHILD:IsA("BasePart") then
				table.insert(PARTS,CHILD)
			end
		end
		coroutine.resume(coroutine.create(function()
			wait(2)
			repeat
				Swait()
				local PIECE = nil
				if MRANDOM(1,5) == 1 then
					for E = 1, #PARTS do
						if MRANDOM(1,5) == 1 then
							PIECE = PARTS[E]
							table.remove(PARTS,E)
							break
						end
					end
				end
				if PIECE ~= nil then
					if PIECE.Name == "Head" then
						WACKYEFFECT({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = VT(PIECE.Size.Z,PIECE.Size.Y,PIECE.Size.Z), Size2 = (VT(PIECE.Size.Z,PIECE.Size.Y,PIECE.Size.Z))*MRANDOM(7,14)/10, Transparency = PIECE.Transparency, Transparency2 = 1, CFrame = PIECE.CFrame, MoveToPos = PIECE.Position+VT(0,MRANDOM(5,8)/1.5,0), RotationX = MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = C3(0.4,0,0), SoundID = 3264923, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2})
					else
						WACKYEFFECT({Time = MRANDOM(10,30)*5, EffectType = "Box", Size = PIECE.Size, Size2 = PIECE.Size*MRANDOM(7,14)/10, Transparency = PIECE.Transparency, Transparency2 = 1, CFrame = PIECE.CFrame, MoveToPos = PIECE.Position+VT(0,MRANDOM(5,8)/1.5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = C3(0.4,0,0), SoundID = 3264923, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2})
					end
					if lplr == Player then
						DamageRemote:FireServer("Remove", PIECE)
					end
					PIECE:Remove()
				end
			until #PARTS == 0
		end))
	end
end

--//=================================\\
--||         WEAPON CREATION
--\\=================================//

local Shield = IT("MeshPart", workspace)
Shield.Name = "lol no"
Shield.CanCollide = false
Shield.Transparency = 1
Shield.Material = "Neon"
Shield.BrickColor = BrickColor.new("fat")
Shield.Size = Vector3.new(5.3,6.3,5.3)
Shield.CFrame = Torso.CFrame
local Wed = Instance.new("Weld", Shield)
Wed.Part0 = Shield
Wed.Part1 = Torso

local Scarf = CreatePart(3, Torso, "Neon", 0, 0, "Deep orange", "Eye", VT(0,0,0),false)
local ScarfWeld = CreateWeldOrSnapOrMotor("Weld", Scarf, Torso, Scarf, CF(0.05,0.4,-0.05) * ANGLES(RAD(-3), RAD(0), RAD(0)), CF(0, 0, 0))
Scarf.Locked = true
--ScarfWeld.Locked = true
CreateMesh("SpecialMesh", Scarf, "FileMesh", "99856331", "", VT(0.1,1,1.1), VT(0,0,0))

local outer = Instance.new("Part")
outer.Locked = true
outer.CanCollide = false
outer.Shape = Enum.PartType.Cylinder
outer.Size = Vector3.new(0.05, 1, 1)
outer.Material = Enum.Material.Neon
outer.Color = Color3.new(0, 0, 0)
outer.Parent = Character
spawn(function() Rainbowify(outer) end)

local outerm = Instance.new("SpecialMesh")
outerm.MeshType = Enum.MeshType.Cylinder
outerm.Parent = outer

local weld1 = Instance.new("Weld")
weld1.Part0 = outer
weld1.Part1 = Character["HumanoidRootPart"]
weld1.Parent = outer
weld1.C0 = CFrame.new(-2.95, 0, 0) * CFrame.Angles(0, 0, 1.571)
coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		outerm.Scale = Vector3.new(0, sick.PlaybackLoudness / 25, sick.PlaybackLoudness / 25)
	end
end))

coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		Scarf.Color = RightLeg.Color
	end
end))

function Weld(part0,part1,c0,c1)
	local weld = IT("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF()
	weld.C1 = c1 or CF()
	return weld
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

if Head:FindFirstChildOfClass("Decal") then
	
else
	local newFace = Instance.new("Decal", Head)
	newFace.Parent = Head
	newFace.Face = "Front"

end 



local all, last = {}, nil
ArmourParts = {}
NeonParts = {}
function scan(p)
	for _, v in pairs(p:GetChildren()) do
		if v:IsA("BasePart") then
			if v.BrickColor == BrickColor.new("Black") then
				table.insert(ArmourParts, v)
			end
			if v.BrickColor == BrickColor.new("Institutional white") then
				table.insert(NeonParts, v)
			end
			if last then
				local w = Instance.new("Weld")
				w.Part0, w.Part1 = last, v
				w.C0 = v.CFrame:toObjectSpace(last.CFrame):inverse()
				w.Parent = last
			end
			table.insert(all, v)
			last = v
		end
		scan(v)
	end
end

function CreateParta(parent,transparency,reflectance,material,brickcolor)
	local p = Instance.new("Part")
	p.TopSurface = 0
	p.BottomSurface = 0
	p.Parent = parent
	p.Size = Vector3.new(0.1,0.1,0.1)
	p.Transparency = transparency
	p.Reflectance = reflectance
	p.CanCollide = false
	p.Locked = true
	p.BrickColor = brickcolor
	p.Material = material
	return p
end

local Hearts = {}
local hrt = NewInstance("Part",Effects,{Name='Heart',Anchored=false,CanCollide=false,Material=Enum.Material.Neon,Color=C3(1,0,0),Size=VT(.05,.05,.05),Locked=true,Archivable=false})
spawn(function() Rainbowify(hrt) end)
local hrtMesh = NewInstance("SpecialMesh",hrt,{MeshId="rbxassetid://105992239",Offset=VT(0,0,0),Scale=VT(0.0,0.0,0)})
local weld = Weld(Torso,hrt,CF(-.45,.30,-.55))
table.insert(Hearts,{hrt,hrtMesh})

local FaceGradient = IT("Folder", Character)
FaceGradient.Name = "FaceGradient"
local Eyes = IT("Folder", Character)
Eyes.Name = "Eyes"

for i = 1, 10 do
	local FACE = CreatePart(3, faceShadingFolder, "Neon", 0, 0+(i-1)/10.2, "Dark stone grey", "FaceGradient", VT(0.01,0.0,0.01),false)
	FACE.Color = C3(0,0,0)
	Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
	CreateWeldOrSnapOrMotor("Weld", FACE, Head, FACE, CF(600,0.28-(i-1)/30,0), CF(0, 0, 0))
end

CreateWeldOrSnapOrMotor("Weld", Torso, Torso, PRT, CF(600.05,0.4,-0.1) * ANGLES(RAD(-3), RAD(0), RAD(0)), CF(0, 0, 0))
CreateMesh("SpecialMesh", PRT, "FileMesh", "99856331", "", VT(1.1,1,1.1), VT(0,0,0))
local Eye = CreatePart(3, Eyes, "Neon", 0, 0, "Lily white", "Eye", VT(0.0001,0,0)/2,false)
MakeForm(Eye,"Ball")
CreateWeldOrSnapOrMotor("Weld", Eye, Head, Eye, CF(0,0.15,0) * ANGLES(RAD(0), RAD(-18), RAD(0)), CF(0, 0, 0.4))
spawn(function() Rainbowify(Eye) end)
local Eye2 = CreatePart(3, Eyes, "Neon", 0, 0, "Lily white", "Eye", VT(0.00001,0,0)/2,false)
MakeForm(Eye2,"Ball")
CreateWeldOrSnapOrMotor("Weld", Eye2, Head, Eye2, CF(0,0.15,0) * ANGLES(RAD(0), RAD(18), RAD(0)), CF(0, 0, 0.4))
spawn(function() Rainbowify(Eye2) end)
local LASTPART4 = Head-- done
for i = 1, 62 do
	local MATH = (1-(i/25))
	if LASTPART4 == Head then
		local Horn42 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn42", VT(0.25*MATH,0.3,0.4*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART4, LASTPART4, Horn42, CF(-0.5, 0.7, -0.35) * ANGLES(RAD(-55), RAD(-15), RAD(15)), CF(0, 0, 0))
		LASTPART4 = Horn42
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn42.Color = Torso.Color
			end
		end))
	else
		local Horn42 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn42", VT(0.25*MATH,0.4,0.3*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART4, LASTPART4, Horn42, CF(0, Horn42.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(2.5), RAD(0)), CF(0, 0, 0))
		LASTPART4 = Horn42
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn42.Color = Torso.Color
			end
		end))
	end
end

local LASTPART4 = Head-- done
for i = 1, 62 do
	local MATH = (1-(i/25))
	if LASTPART4 == Head then
		local Horn42 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn42", VT(0.25*MATH,0.3,0.4*MATH),false)
		Horn42.Transparency = 1
		CreateWeldOrSnapOrMotor("Weld", LASTPART4, LASTPART4, Horn42, CF(900.0000001, 900.0000001, -900.0000001) * ANGLES(RAD(-55), RAD(15), RAD(-15)), CF(0, 0, 0))
		LASTPART4 = Horn42
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn42.Color = Torso.Color
			end
		end))
	else
		local Horn42 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn42", VT(0.25*MATH,0.4,0.3*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART4, LASTPART4, Horn42, CF(0, Horn42.Size.Y/0.0, 0) * ANGLES(RAD(6), RAD(-2.5), RAD(0)), CF(0, 0, 0))
		LASTPART4 = Horn42
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn42.Color = Torso.Color
			end
		end))
	end
end

local LASTPART2 = Head--Extra Horns 1
for i = 1, 36 do
	local MATH = (1-(i/25))
	if LASTPART2 == Head then
		local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(15), RAD(-15)), CF(0, 0, 0))
		LASTPART2 = Horn2
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn2.Color = Torso.Color
			end
		end))
	else
		local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(0, Horn2.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(-0.3), RAD(0)), CF(0, 0, 0))
		LASTPART2 = Horn2
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn2.Color = Torso.Color
			end
		end))
	end
end
local LASTPART2 = Head--Extra Horns 2
for i = 1, 36 do
	local MATH = (1-(i/25))
	if LASTPART2 == Head then
		local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(-0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(-15), RAD(15)), CF(0, 0, 0))
		LASTPART2 = Horn2
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn2.Color = Torso.Color
			end
		end))
	else
		local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(0, Horn2.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(0.3), RAD(0)), CF(0, 0, 0))
		LASTPART2 = Horn2
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn2.Color = Torso.Color
			end
		end))
	end
end

local LASTPART = Head
for i = 1, 62 do
	local MATH = (1-(i/25))
	if LASTPART == Head then
		local Horn = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(15), RAD(-15)), CF(0, 0, 0))
		LASTPART = Horn
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn.Color = Torso.Color
			end
		end))
	else
		local Horn = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(-2.5), RAD(0)), CF(0, 0, 0))
		LASTPART = Horn
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn.Color = Torso.Color
			end
		end))
	end
end
local LASTPART = Head
for i = 1, 62 do
	local MATH = (1-(i/25))
	if LASTPART == Head then
		local Horn = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(-0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(-15), RAD(15)), CF(0, 0, 0))
		LASTPART = Horn
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn.Color = Torso.Color
			end
		end))
	else
		local Horn = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(2.5), RAD(0)), CF(0, 0, 0))
		LASTPART = Horn
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn.Color = Torso.Color
			end
		end))
	end
end

local LASTPART3 = Head
for i = 1, 64 do
	local MATH = (1-(i/40))
	if LASTPART3 == Head then
		local Horn3 = CreatePart(3, Character, "Neon", 0, 0, "Lily white", "Eye", VT(0.15*MATH,0.15,0.15*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", Horn3, LASTPART3, Horn3, CF(0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(15), RAD(-15)), CF(0, 0, 0))
		LASTPART3 = Horn3
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn3.Color = Torso.Color
			end
		end))
	else
		local Horn3 = CreatePart(3, Character, "Neon", 0, 0, "Lily white", "Eye", VT(0.15*MATH,0.15,0.15*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", Horn3, LASTPART3, Horn3, CF(0, Horn3.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(2.5), RAD(0)), CF(0, 0, 0))
		LASTPART3 = Horn3
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn3.Color = Torso.Color
			end
		end))
	end
end
local LASTPART3 = Head
for i = 1, 64 do
	local MATH = (1-(i/40))
	if LASTPART3 == Head then
		local Horn3 = CreatePart(3, Character, "Neon", 0, 0, "Lily white", "Eye", VT(0.15*MATH,0.15,0.15*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", Horn3, LASTPART3, Horn3, CF(-0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(-15), RAD(15)), CF(0, 0, 0))
		LASTPART3 = Horn3
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn3.Color = Torso.Color
			end
		end))
	else
		local Horn3 = CreatePart(3, Character, "Neon", 0, 0, "Lily white", "Eye", VT(0.15*MATH,0.15,0.15*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", Horn3, LASTPART3, Horn3, CF(0, Horn3.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(-2.5), RAD(0)), CF(0, 0, 0))
		LASTPART3 = Horn3
		coroutine.resume(coroutine.create(function()
			while true do
				Swait()				
				Horn3.Color = Torso.Color
			end
		end))
	end
end


local PlayerSize = 1
local FT,FRA,FLA,FRL,FLL = Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh")
FT.MeshId,FT.Scale = "rbxasset://fonts/torso.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FRA.MeshId,FRA.Scale = "rbxasset://fonts/rightarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FLA.MeshId,FLA.Scale = "rbxasset://fonts/leftarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FRL.MeshId,FRL.Scale = "rbxasset://fonts/rightleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
FLL.MeshId,FLL.Scale = "rbxasset://fonts/leftleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)

-- Tails

local p = Instance.new("Part", Character)
p.Name = "kit"
p.Anchored = true
p.Transparency = 1
p.Material = "Neon"
p.Color = C3(1,0,0)
p.CanCollide = false
p.TopSurface = 0
p.BottomSurface = 0
spawn(function() Rainbowify(p) end)
p.Size = Vector3.new(-0, 0, 0.0000000001)
p.CustomPhysicalProperties = PhysicalProperties.new(0.01, 0, 0, 0, 0)
local msh = Instance.new("SpecialMesh", p)
msh.Scale = Vector3.new(-0, 0, 0.0000000001)
msh.MeshId = "http://www.roblox.com/asset/?id=188635159"
msh.VertexColor = Vector3.new(Torso.BrickColor.r, Torso.BrickColor.g, Torso.BrickColor.b)
local pn = Instance.new("Part", Character.kit)
pn.Name = "tail" --1
pn.Anchored = true
pn.Transparency = 0
pn.Material = "Neon"
pn.Color = C3(1,0,0)
pn.CanCollide = false
pn.TopSurface = 0
pn.BottomSurface = 0
spawn(function() Rainbowify(pn) end)
pn.Size = Vector3.new(5, 3, 3)
pn.CustomPhysicalProperties = PhysicalProperties.new(0.01, 0, 0, 0, 0)
local mshn = Instance.new("SpecialMesh", pn)
mshn.Scale = Vector3.new(-0, 0, 0.0000000001)
mshn.MeshId = "http://www.roblox.com/asset/?id=188635159"
mshn.VertexColor = Vector3.new(Torso.BrickColor.r, Torso.BrickColor.g, Torso.BrickColor.b)
p.Anchored = false
local motor1 = Instance.new("Weld", p)
motor1.Part0 = p
motor1.Part1 = Torso
motor1.C0 = CFrame.new(2.36, -1.8, -0.87) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
motor1.C1 = CFrame.new(0, -1, 0.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
pn.Anchored = false
local motor2 = Instance.new("Weld", pn)
motor2.Part0 = pn
motor2.Part1 = Torso
motor2.C0 = CFrame.new(-2.36, -1.8, -0.87) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
motor2.C1 = CFrame.new(0, -1, 0.5) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))


local Particle =IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
Particle.LightEmission = 0.5
Particle.Rate = 150
Particle.ZOffset = 0.2
Particle.Rotation = NumberRange.new(-180, 180)
Particle.RotSpeed = NumberRange.new(-180, 180)
Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
Particle.Color = ColorSequence.new(C3(1,0,0),C3(0.4,0,0))

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
function ParticleEmitter(Table)
	local PRTCL = Particle:Clone()
	local Speed = Table.Speed or 5
	local Drag = Table.Drag or 0
	local Size1 = Table.Size1 or 1
	local Size2 = Table.Size2 or 5
	local Lifetime1 = Table.Lifetime1 or 1
	local Lifetime2 = Table.Lifetime2 or 1.5
	local Parent = Table.Parent or Torso
	local Emit = Table.Emit or 100
	local Offset = Table.Offset or 360
	local Acel = Table.Acel or VT(0,0,0)
	local Enabled = Table.Enabled or false
	PRTCL.Parent = Parent
	PRTCL.Size = NumberSequence.new(Size1,Size2)
	PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
	PRTCL.Speed = NumberRange.new(Speed)
	PRTCL.VelocitySpread = Offset
	PRTCL.Drag = Drag
	PRTCL.Acceleration = Acel
	if Enabled == false then
		PRTCL:Emit(Emit)
		Debris:AddItem(PRTCL,Lifetime2)
	else
		PRTCL.Enabled = true
	end
	return PRTCL
end


--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

abss = Instance.new("BillboardGui",Character)
abss.Size = UDim2.new(10,0,10,0)
abss.Enabled = false
imgl = Instance.new("ImageLabel",abss)
imgl.Position = UDim2.new(0,0,0,0)
imgl.Size = UDim2.new(1,0,1,0)
imgl.Image = "rbxassetid://342199418"
imgl.BackgroundTransparency = 1
imgl.ImageColor3 = Color3.new(.9,0,0)
img2 = Instance.new("ImageLabel",abss)
img2.Position = UDim2.new(0,0,0,0)
img2.Size = UDim2.new(1,0,1,0)
img2.Image = "rbxassetid://342199418"
img2.BackgroundTransparency = 1
img2.ImageColor3 = Color3.new(.9,0,0)

function CreatePartC(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, COLOR3, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.Color = COLOR3
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end


function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "ForceField", 0, 0, "Really red", "Trail", VT(0,0,0))
	spawn(function() Rainbowify(TRAIL) end)
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(0.5,DIST,0.5)
	else
		TRAIL.Size = VT(0.75,DIST,0.75)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.01
		end
		wait(4.2)
		TRAIL:remove()
	end))
end

function SpawnTrail2(FROM2,TO2,BIG2)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, BrickColor.Random(), "Trail", VT(0,0,0))
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM2 - TO2).Magnitude
	if BIG2 == true then
		TRAIL.Size = VT(5,DIST,5)
	else
		TRAIL.Size = VT(5,DIST,5)
	end
	TRAIL.CFrame = CF(FROM2, TO2) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

function chatfunc(text)
	local chat = coroutine.wrap(function()
		if Character:FindFirstChild("TalkingBillBoard")~= nil then
			Character:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local Bill = Instance.new("BillboardGui",Character)
		Bill.Size = UDim2.new(0,100,0,40)
		Bill.StudsOffset = VT(0,3,0)
		Bill.Adornee = Character.Head
		Bill.Name = "TalkingBillBoard"
		local Hehe = Instance.new("TextLabel",Bill)
		Hehe.BackgroundTransparency = 1
		Hehe.BorderSizePixel = 0
		Hehe.Text = ""
		Hehe.Font = Enum.Font.SourceSansLight
		Hehe.TextSize = 40
		Hehe.TextStrokeColor3 = Color3.new(0,0,0)
		Hehe.TextStrokeTransparency = 0.7
		Hehe.Size = UDim2.new(1,0,0.5,0)
		coroutine.resume(coroutine.create(function()
			while Hehe ~= nil do
				Swait()	
				Hehe.Position = UDim2.new(0, 0, .05, 0)
				Hehe.TextColor3 = BrickColor.Black().Color
				Hehe.TextStrokeColor3 = BrickColor.Black().Color
			end
		end))
		for i = 1,string.len(text),1 do
			Swait()
			Hehe.Text = string.sub(text,1,i)
		end
		Swait(90)
		for i = 0, 1, .025 do
			Swait()
			Hehe.TextStrokeTransparency = i
			Hehe.TextTransparency = i
		end
		Bill:Destroy()
	end)
	chat()
end

function printbye(Name)
	local MESSAGES = {"nah, ", "bye, ", "PLLLLSSS GO AWAY, ", "chill, ", "GOODNIGHT, ", "come and chill with me, ", "HA, ", "Hi, Welcome To The HAZBIN HOTEL, ", "uwu go kys, ", "hehe please die owo, ","dont abuse me, "}
	chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
	Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ",MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")
end

Player.Chatted:connect(function(msg)
	if BanishMode == 324 then
		if msg:sub(1, 5):lower()=='play/' then
			sick:Stop()
			SONG1 = msg:sub(6)
			sick:Play()
			sick.Looped = true
			local info = game.MarketplaceService:GetProductInfo(tonumber(msg:sub(6)))
			if(info and info.Name)then
				chatfunc("Now Playing: "..info.Name)
			end
		elseif msg:sub(1, 6):lower()=='pitch/' then
			local Pitch = msg:sub(7)
			sick.Pitch = Pitch
			chatfunc("Now pitch is "..msg:sub(7))
		elseif msg:sub(1, 4):lower()=='vol/' then
			local Volume = msg:sub(5)
			sick.Volume = Volume
			chatfunc("Now volume is "..msg:sub(5))
		elseif msg:sub(1, 5):lower()=='stop/' then
			sick:Stop()
			chatfunc("Music Stopped")
		end
	end
end)

function Kick(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			local plr = game:service'Players':GetPlayerFromCharacter(Foe)
			if plr then
				coroutine.resume(coroutine.create(function()
					KickRemote:FireServer(plr,'Fuck off')		
				end))		
			end
			if(Foe:FindFirstChildOfClass'Humanoid')then	
				printbye(Foe.Name)
				Foe.Archivable = true
				local CLONE = Foe:Clone()
				Foe:Destroy()
				CLONE.Parent = Effects
				CLONE:BreakJoints()
				local MATERIALS = {"ForceField","Neon"}
				for _, c in pairs(CLONE:GetDescendants()) do
					if c:IsA("BasePart") then
						if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
							CreateSound(340722848, c, 10, 1, false)
						end
						c.Anchored = true
						c.Transparency = c.Transparency + 0.2
						c.Material = MATERIALS[MRANDOM(1,2)]
						c.Color = C3(1,0,0)
						spawn(function() Rainbowify(c) end)
						if c.ClassName == "MeshPart" then
							c.TextureID = ""
						end
						if c:FindFirstChildOfClass("SpecialMesh") then
							c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
						end
						if c:FindFirstChildOfClass("Decal") then
							c:FindFirstChildOfClass("Decal"):remove()
						end
						c.Name = "Banned"
						c.CanCollide = false
					else
						c:remove()
					end
				end
				local A = false
				for i = 1, 35 do
					if A == false then
						A = true
					elseif A == true then
						A = false
					end
					for _, c in pairs(CLONE:GetDescendants()) do
						if c:IsA("BasePart") then
							c.Anchored = true
							c.Material = MATERIALS[MRANDOM(1,2)]
							c.Transparency = c.Transparency + 0.8/35
							if A == false then
								c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
							elseif A == true then
								c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
							end
						end
					end
					Swait()
				end
				CLONE:remove()
			end
		end))
	end
end

function Respawn(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			local plr = game:service'Players':GetPlayerFromCharacter(Foe)
			if plr then
				RespawnRemote:FireServer(plr)
			end
		end))
	end
end

function Banish(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			table.insert(TOBANISH,Foe.Name)
			printbye(Foe.Name)
			Foe.Archivable = true
			local CLONE = Foe:Clone()
			Foe:Destroy()
			CLONE.Parent = Effects
			CLONE:BreakJoints()
			local MATERIALS = {"ForceField","Neon"}
			for _, c in pairs(CLONE:GetDescendants()) do
				if c:IsA("BasePart") then
					if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
						CreateSound(340722848, c, 10, 1, false)
					end
					c.Anchored = true
					c.Transparency = c.Transparency + 0.2
					c.Material = MATERIALS[MRANDOM(1,2)]
					c.Color = C3(1,0,0)
					spawn(function() Rainbowify(c) end)
					if c.ClassName == "MeshPart" then
						c.TextureID = ""
					end
					if c:FindFirstChildOfClass("SpecialMesh") then
						c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
					end
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end
					c.Name = "Banished"
					c.CanCollide = false
				else
					c:remove()
				end
			end
			local A = false
			for i = 1, 35 do
				if A == false then
					A = true
				elseif A == true then
					A = false
				end
				for _, c in pairs(CLONE:GetDescendants()) do
					if c:IsA("BasePart") then
						c.Anchored = true
						c.Material = MATERIALS[MRANDOM(1,2)]
						c.Transparency = c.Transparency + 0.8/35
						if A == false then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
						elseif A == true then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
						end
					end
				end
				Swait()
			end
			CLONE:remove()
		end))
	end
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("BanishForceV5"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "BanishForceV5"..Player.Name
								else
									TORSO:FindFirstChild("BanishForceV5"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("BanishForceV5"..Player.Name) then
							TORSO:FindFirstChild("BanishForceV5"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

workspace.ChildAdded:connect(function(instance)
	for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					printbye(instance.Name)
					instance:ClearAllChildren()
					Debris:AddItem(instance,0.0005)
				end))
			end
		end
	end
end)

function BanishBullet()
	ATTACK = true
	Rooted = false
	for i=0, 0.01, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.01, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(RightArm.Position,POS)
		CreateSound(904440937, Character, 10, 1, false)
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				Banish(HIT.Parent)
			end
		end
		for i=0, 0.01, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function Dirtface()
	local TARGET = Mouse.Target
	if TARGET ~= nil then
		if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
			if ROOT and HUM.Health > 0 then
				local FOE = Mouse.Target.Parent
				local HEAD = FOE:FindFirstChild("Head")
				local HITFLOOR = Raycast(ROOT.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*ROOT.Size.Z, FOE)
				if HEAD and HITFLOOR then
					ATTACK = true
					Rooted = true

					CharacterFade(C3(1,0,0),150)
					RootPart.CFrame = ROOT.CFrame*CF(0,0,2)
					ROOT.Anchored = true
					CreateSound(4745377484, Torso, 2, 3, false)
					FACE = 398671601
					chatfunc("Where would you go?...")
					CreateSound(4745377484, Torso, 10, 1, false)
					for i=0, 0.4, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-25)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10 - 2.5 * COS(SINE / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(140), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i=0, 0.1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10 - 2.5 * COS(SINE / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(140), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(65), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					ROOT.Anchored = false
					UNANCHOR = false
					local DEAD = false
					local CFRAME = RootPart.CFrame
					CreateSound(260411131, Torso, 2, 3, false)
					coroutine.resume(coroutine.create(function()
						repeat
							Swait()
							RootPart.CFrame = CFRAME
							HEAD.CFrame = RightArm.CFrame*CF(0,-(1+HEAD.Size.Z/2),0) * ANGLES(RAD(-90), RAD(0), RAD(0))
							HEAD.Velocity = VT(0,0,0)
							HUM.PlatformStand = true
						until DEAD == true
					end))
					for i=0, 0.2, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10 - 2.5 * COS(SINE / 12)), RAD(0), RAD(-25)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, -0.3) * ANGLES(RAD(140), RAD(0), RAD(-15)) * RIGHTSHOULDERC0, 0.3 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(65), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * COS(SINE / 12)), RAD(0), RAD(15)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, 0) * ANGLES(RAD(60), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local ERUPT = function()
						local HITFLOOR,HITPOS = Raycast(HEAD.CFrame*CF(0,0.2,0).p+VT(0,0.2,0), (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*ROOT.Size.X, FOE)
						if HITFLOOR then
							for i = 1, 5 do
								CreateFlyingDebree(HITFLOOR,CF(HITPOS),MRANDOM(1,2),VT(MRANDOM(10,60)/20,MRANDOM(10,60)/20,MRANDOM(10,60)/20),5,MRANDOM(45,85))
							end
							Chunks(HEAD)
							WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(1,2,1), Size2 = VT(15,0,15), Transparency = 0, Transparency2 = 1, CFrame = CF(HITPOS) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(0)) , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = spawn(function() Rainbowify(Wave) end), SoundID = 5240058145, SoundPitch = MRANDOM(8,12)/10, SoundVolume = 4})
						end
					end
					for i=0, 1, 0.1 / Animation_Speed do
						Swait()
						RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.75 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(45), RAD(0), RAD(15)), 1 / Animation_Speed)
						Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 + MRANDOM(-5,5) - 2.5 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(10)), 1 / Animation_Speed)
						RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, 1) * ANGLES(RAD(60 + MRANDOM(-5,5)), RAD(0), RAD(25 + MRANDOM(-5,5))) * ANGLES(RAD(0), RAD(80), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
						LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(5), RAD(0), RAD(5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
						RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.25 - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(40), RAD(70), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
						LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.3) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
					end
					local ATE = false
					local DEPTH = 1
					coroutine.resume(coroutine.create(function()
						repeat
							Swait()
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.75 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(45), RAD(0), RAD(15)), 1 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 + MRANDOM(-5,5) - 2.5 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(10)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 1-DEPTH/4, -DEPTH/4) * ANGLES(RAD(60 + MRANDOM(-5,5)), RAD(0), RAD(25 + MRANDOM(-5,5))) * ANGLES(RAD(0), RAD(80), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(5), RAD(0), RAD(5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.25 - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(40), RAD(70), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.3) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						until ATE == true
					end))
					coroutine.resume(coroutine.create(function()
						wait(1)
						for i=0, 2, 0.1 / Animation_Speed do
							Swait()
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.75 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(45), RAD(0), RAD(15)), 1 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 + MRANDOM(-5,5) - 2.5 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(10)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, 1) * ANGLES(RAD(60 + MRANDOM(-5,5)), RAD(0), RAD(25 + MRANDOM(-5,5))) * ANGLES(RAD(0), RAD(80), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(5), RAD(0), RAD(5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.25 - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(40), RAD(70), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.3) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						end
						wait(1)
						for i=0, 2, 0.1 / Animation_Speed do
							Swait()
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.75 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(45), RAD(0), RAD(15)), 1 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 + MRANDOM(-5,5) - 2.5 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(10)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, 1) * ANGLES(RAD(60 + MRANDOM(-5,5)), RAD(0), RAD(25 + MRANDOM(-5,5))) * ANGLES(RAD(0), RAD(80), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(5), RAD(0), RAD(5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.25 - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(40), RAD(70), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.3) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						end
						wait(1.5)
						for i=0, 3, 0.1 / Animation_Speed do
							Swait()
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.75 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(45), RAD(0), RAD(15)), 1 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 + MRANDOM(-5,5) - 2.5 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(10)), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.5, 2) * ANGLES(RAD(60 + MRANDOM(-5,5)), RAD(0), RAD(25 + MRANDOM(-5,5))) * ANGLES(RAD(0), RAD(80), RAD(-15)) * RIGHTSHOULDERC0, 0.3 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(5), RAD(0), RAD(5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.25 - 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(40), RAD(70), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.3) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
						end
					end))
					wait()
					ERUPT()
					ERUPT()
					DEPTH = 2
					wait(2)
					ERUPT()
					DEPTH = 2.5
					wait(2)
					ERUPT()
					DEPTH = 2.5
					wait(1.75)
					CreateSound(4742745849, Torso, 10, 0.9, false)
					wait(0.25)
					chatfunc("Goodbye..")
					wait(1)
					ERUPT()
					ERUPT()
					HEAD:remove()
					DEAD = true
					ApplyDamage(HUM,0,true)
					wait(0.2)
					ATE = true
					FACE = 300139178
					UNANCHOR = true
					Weapon.Parent = nil
					ATTACK = false
					Rooted = false
				end
			end
		end
	end
end

function Pure_Heaven()
	chatfunc("JUST DIE ALREADY!!!!!!!")
	Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","JUST DIE ALREADY!!!!!!!")
	ATTACK = true
	Rooted = true
	for i = 1, 15 do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(25 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-25 - 2.5 * SIN(SINE / 12))), 0.1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(65 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-65 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	coroutine.resume(coroutine.create(function()
		local POS = Mouse.Hit.p
		local RAY = CreatePart(3, Effects, "Neon", 0, 0, "Really black", "Strike", VT(0,0,0))
		MakeForm(RAY,"Cyl")
		local SPHERE = CreatePart(3, Effects, "Neon", 0, 0, "Really black", "Strike", VT(0,0,0))
		MakeForm(SPHERE,"Ball")
		local SHIELD = CreatePart(3, Effects, "Neon", 0, 0.5, "Really black", "Strike", VT(0,0,0))
		MakeForm(SHIELD,"Ball")
		SHIELD.CFrame = CF(POS)
		RAY.CFrame = CF(POS)
		SPHERE.CFrame = CF(POS)
		CreateSound(440145570, SPHERE, 15, 0.5, false)
		CreateSound(415700134, SPHERE, 15, 0.5, false)
		for i = 1, 200 do
			Swait()
			WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(SPHERE.Size.X*1.2,5+(i),SPHERE.Size.X*1.2), Transparency = 0, Transparency2 = 1, CFrame = SPHERE.CFrame*ANGLES(RAD(0), RAD(i), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = i, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RAY.Size = RAY.Size + VT(0.5,0,0.5)
			SPHERE.Size = SPHERE.Size + VT(1.5,1.5,1.5)
			SHIELD.Size = SPHERE.Size + VT(2.5,2.5,2.5)
			ApplyAoE(SPHERE.Position,SPHERE.Size.X/2,true)
		end	
		for i = 1, 45 do
			Swait()
			RAY.Transparency = RAY.Transparency + 1/45
			SPHERE.Transparency = RAY.Transparency 
			SHIELD.Transparency = SPHERE.Transparency + 1/45
		end
		RAY:remove()
		SHIELD:remove()
		SPHERE:remove()
	end))
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0  + 0.25 * COS(SINE / 12)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.15) * ANGLES(RAD(65), RAD(-45), RAD(85)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.15) * ANGLES(RAD(65), RAD(45), RAD(-85)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function Overthrower()
	chatfunc("TIME TO DIE!!!!!!!!!!!!!")

	ATTACK = true
	Rooted = true
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(180), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(180), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	CreateSound("348663022", Torso, 5, 1)
	local StartPos = RootPart.CFrame * CF(0,10,0).p
	for i = 1, 5 do
		MagicSpherepp(25,25,CF(StartPos),"Really black")
		Swait(7.5)
		MagicSpherepp(25,25,CF(StartPos),"Really black")
		Swait(7.5)
	end
	local soundeffect = IT("Sound",Torso)
	soundeffect.SoundId = "rbxassetid://487186990"
	soundeffect.Looped = true
	soundeffect.Volume = 10
	soundeffect.Playing = true
	repeat
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = CF(StartPos), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Torso.Color, SoundID = 642890855, SoundPitch = 0.45, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = CF(StartPos), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		Lightning(StartPos,Mouse.Hit.p,15,3.5,BrickColor.new("Really black"),math.random(15,35),1,3,0,true,55) Lightning(StartPos,Mouse.Hit.p,15,3.5,BrickColor.new("Really black"),math.random(15,35),1,3,0,true,55)
		for i = 0, 2 do
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = CF(StartPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = CF(StartPos)*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
		end
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Torso.Color, SoundID = 192410089, SoundPitch = .55, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		WACKYEFFECTpp({Time = math.random(15,35), EffectType = "Box", Size = Vector3.new(2,2,2), Size2 = Vector3.new(5,5,5), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit, MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
		for i = 0, 2 do
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
			WACKYEFFECTpp({Time = math.random(25,50), EffectType = "Round Slash", Size = Vector3.new(0.1,0.1,0.1), Size2 = Vector3.new(0.4,0,0.4), Transparency = 0, Transparency2 = 1, CFrame = Mouse.Hit*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = math.random(-1,1), RotationY = math.random(-1,1), RotationZ = math.random(-1,1), Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 15})
		end
		turnto(Mouse.Hit.p)
		local RayHit, RayPos, RayNormal = CastZapRay(StartPos, Mouse.Hit.p, 750, Character, false)
		local distance = (StartPos - RayPos).magnitude
		ApplyAoEpp(RayPos,15)
		MagicSpherepp(25,25,CF(StartPos),"Really black")
		Swait(5)
		MagicSpherepp(25,25,CF(StartPos),"Really black")
		Swait(5)
	until KEYHOLD == false
	soundeffect:remove()
	ATTACK = false
	Rooted = false
end

function Karma_Beam()
	chatfunc("Karma Beam!")

	ATTACK = true
	Rooted = false
	for i=0, 0.005, 0.05 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90+MRANDOM(-90,90)), RAD(0), RAD(60+MRANDOM(-90,90))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		--RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		--LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90+MRANDOM(-90,90)), RAD(0), RAD(60+MRANDOM(-90,90))) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			--RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			--LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		local val = MRANDOM(1,255)
		local HIT2,POS2 = CastProperRay(RightArm.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail2(RightArm.Position,POS2)
		if HIT2 ~= nil then
			if HIT2.Parent ~= workspace and HIT2.Parent.ClassName ~= "Folder" then
				if Kicker == false then
					Banish(HIT2.Parent)

				elseif Kicker == true then
					Kick(HIT2.Parent)
				end
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = RightArm.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = 340722848, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS2,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(5,0,5), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CF(POS2,RightArm.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		Humanoid.CameraOffset = VT(MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5,MRANDOM(-5,5)/2.5)/30
		for i=0, 0.005, 0.05 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(60)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(130), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			--RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			--LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function ToggleSome()
	if Idk == false then
		Idk = true
		chatfunc("Flashy Lights turned on")
		Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","Flashy Lights turned on")
	else
		Idk = false
		chatfunc("Flashy Lights turned off")
		Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","Flashy Lights turned off")
	end
end

function DoGlitchBug()
	if DoGlitch == false then
		DoGlitch = true
		chatfunc("Glitch turned on")
		Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","Glitch turned on")
	else
		DoGlitch = false
		chatfunc("Glitch turned off")
		Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","Glitch turned off")
	end
end

function ToggleHead()
	if HEADCAMERA == false then
		HEADCAMERA = true
		chatfunc("Camera: Head")
		Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","Camera: Head")
	else
		HEADCAMERA = false
		chatfunc("Camera: Body")
		Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","Camera: Body")
	end
end
function BanishAll()
	ATTACK = true
	Rooted = true
	chatfunc("Deleting ROBLOX.exe","FUCK ALL OF YOU")
	Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","Deleting ROBLOX.exe","[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","FUCK ALL OF YOU")
	wait(5)
	for _,v in pairs(game.Players:GetChildren()) do
		Banish(v)
	end
	wait(2)
	ATTACK = false
	Rooted = false
end

function Rush()
	local ORIGIN = RootPart.Position
	local SOUNDPART = CreatePart(3, Effects, "Neon", 0, 1, "Pearl", "Sound", VT(0,0,0))
	SOUNDPART.CFrame = RootPart.CFrame
	Debris:AddItem(SOUNDPART,5)
	CreateSound("1295446488", SOUNDPART, 2, 1)
	RootPart.CFrame = CF(Mouse.Hit.p+VT(0,3,0),VT(ORIGIN.X,Mouse.Hit.p.Y,ORIGIN.Z))
	Swait()
	local SOUNDPART = CreatePart(3, Effects, "Neon", 0, 1, "Pearl", "Sound", VT(0,0,0))
	SOUNDPART.CFrame = RootPart.CFrame
	Debris:AddItem(SOUNDPART,5)
	CreateSound("1295446488", SOUNDPART, 2, 1)
	ATTACK = false
	Rooted = false
end

function FireArc(Part, ToLocation, AmountOfTime, Height, DoesCourontine)
	if DoesCourontine == false then
		local Direction = CF(Part.Position, ToLocation)
		local Distance = (Part.Position - ToLocation).magnitude
		for i = 1, AmountOfTime do
			Swait()
			Part.CFrame = Direction * CF(0, AmountOfTime / 200 + (AmountOfTime / Height - i * 2 / Height), -Distance / AmountOfTime)
			Direction = Part.CFrame
		end
		Part:remove()
	elseif DoesCourontine == true then
		coroutine.resume(coroutine.create(function()
			local Direction = CF(Part.Position, ToLocation)
			local Distance = (Part.Position - ToLocation).magnitude
			for i = 1, AmountOfTime do
				Swait()
				Part.CFrame = Direction * CF(0, AmountOfTime / 200 + (AmountOfTime / Height - i * 2 / Height), -Distance / AmountOfTime)
				Direction = Part.CFrame
			end
			Part:remove()
		end))
	end
end

function chatfunc(text)
	local chat = coroutine.wrap(function()
		if Character:FindFirstChild("TalkingBillBoard")~= nil then
			Character:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local Bill = Instance.new("BillboardGui",Character)
		Bill.Size = UDim2.new(0,35,0,18)
		Bill.StudsOffset = Vector3.new(0,4.5,0)
		Bill.Adornee = Character.Head
		Bill.Name = "TalkingBillBoard"
		local Hehe = Instance.new("TextLabel",Bill)
		Hehe.BackgroundTransparency = 1
		Hehe.BorderSizePixel = 0
		Hehe.Text = ""
		Hehe.Font = "SourceSansLight"
		Hehe.TextSize = 35
		Hehe.TextStrokeTransparency = 0.7
		Hehe.Size = UDim2.new(1,0,0.5,0)
		coroutine.resume(coroutine.create(function()
			while Hehe ~= nil do
				wait()	
				Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
			end
		end))
		spawn(function() RainbowifyText(Hehe) end)
		for i = 1,string.len(text),1 do
			wait()
			Hehe.Text = string.sub(text,1,i)
		end
		wait(3)
		for i = 0, 5, .025 do
			wait()
			Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
			Hehe.TextStrokeTransparency = i
			Hehe.TextTransparency = i
		end
		Bill:Destroy()
	end)
	chat()
end

Player.Chatted:Connect(function(aa)
	chatfunc(aa)
end)

function warnedpeople(text)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("Spinny")~= nil then
				v.PlayerGui:FindFirstChild("Spinny"):destroy()
			end
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "Spinny"
			local wobble = Instance.new("Frame",scrg)
			wobble.Name = "Wobble"
			wobble.BackgroundTransparency = 0.5
			wobble.Size = UDim2.new(1.1,0,1.1,0)
			wobble.Position = UDim2.new(-0.08,0,0.943,0)
			local wobble2 = Instance.new("Frame",scrg)
			wobble2.Name = "wobble2"
			wobble2.BackgroundTransparency = 0.5
			wobble2.Size = UDim2.new(1.1,0,0.09,0)
			wobble2.Position = UDim2.new(-0.08,0,0.878,0)
			local Visuals = Instance.new("Frame",scrg)
			Visuals.Name = "Visuals"
			Visuals.BackgroundTransparency = 0.3
			Visuals.Size = UDim2.new(0,100,0,100)
			Visuals.Position = UDim2.new(0.462,0,0.826,0)
			local glow = Instance.new("ImageLabel",scrg)
			glow.Name = "glow"
			glow.BackgroundTransparency = 1
			glow.ImageTransparency = 0
			glow.Image = "rbxassetid://2344870656"
			glow.Size = UDim2.new(0,0,0,0)
			glow.Position = UDim2.new(0.026,0,-0.235,0)
			local Visuals2 = Instance.new("Frame",scrg)
			Visuals2.Name = "Visuals2"
			Visuals2.BackgroundTransparency = 0.3
			Visuals2.Size = UDim2.new(0,50,0,50)
			Visuals2.Position = UDim2.new(0.48,0,0.867,0)
			local TextFrame = Instance.new("TextLabel",scrg)
			TextFrame.Name = "Farmer"
			TextFrame.Font = "SourceSansLight"
			TextFrame.Text = text
			TextFrame.TextScaled = true
			TextFrame.TextSize = 60
			TextFrame.TextColor3 = C3(1,1,1)
			TextFrame.TextStrokeColor3 = C3(0, 0, 0)
			TextFrame.BackgroundTransparency = 1
			TextFrame.Size = UDim2.new(0.8,0,0,42)
			TextFrame.Position = UDim2.new(0.11,0,0.867,0)
			spawn(function() RainbowifyText(TextFrame) end)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					TextFrame.TextStrokeTransparency = 0.7
					TextFrame.Rotation = 0 + MRANDOM(-3, 3)
					TextFrame.Position = UDim2.new(0.11, 0 + MRANDOM(-3, 3), 0.867, 0 + MRANDOM(-3, 3))
					TextFrame.Font = Enum.Font.SourceSansLight
					glow.ImageColor3 = C3(0, 0, 0)
					wobble.Rotation = 0 - 2 * COS(SINE / 24)
					wobble2.Rotation = 0 - 2 * COS(SINE / 30)
					wobble2.BackgroundColor3 = C3(0,0,0)
					wobble2.BorderColor3 = C3(0,0,0)
					wobble2.BorderSizePixel = 4
					Visuals.Rotation = Visuals.Rotation + MRANDOM(-5, 5)
					Visuals2.Rotation = Visuals2.Rotation + MRANDOM(-10, 10)
					Visuals.BackgroundColor3 = C3(0,0,0)
					Visuals.BorderColor3 = C3(0,0,0)
					Visuals2.BackgroundColor3 = C3(0,0,0)
					Visuals2.BorderColor3 = C3(0,0,0)
					wobble.BackgroundColor3 = C3(0,0,0)
					wobble.BorderColor3 = C3(0,0,0)
					wobble.BorderSizePixel = 5
				end
			end))
			coroutine.resume(coroutine.create(function()
				for i = 0, 205 do
					Swait()
				end
				scrg:Destroy()
			end))
		end))
	end
end

function warnedpeople5(whom)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
				v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
			end
			local droppingFrame = false
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "ARRIVAL"
			local mainFrame = Instance.new("Frame", scrg)
			mainFrame.Name = "MainFrame"
			mainFrame.BackgroundTransparency = 1
			mainFrame.BorderSizePixel = 0
			mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
			mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
			local TextFrame = Instance.new("TextLabel",mainFrame)
			TextFrame.Name = "TextFrame"
			TextFrame.Font = "Arcade"
			TextFrame.Text = ""
			TextFrame.TextScaled = true
			TextFrame.TextSize = 9
			TextFrame.TextStrokeTransparency = 1
			TextFrame.BackgroundTransparency = 1
			TextFrame.TextColor3 = Color3.fromRGB(255, 0, 0)
			TextFrame.TextStrokeColor3 = BrickColor.Black().Color
			TextFrame.Size = UDim2.new(1, 0, 0, 92)
			TextFrame.Position = UDim2.new(0, 0, 0, 0)
			spawn(function() RainbowifyText(TextFrame) end)

			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					mainFrame.BackgroundColor3 = C3(0,0,0)
					mainFrame.BorderColor3 = C3(0, 0, 0)
					if(not droppingFrame)then
						mainFrame.Rotation = 0 - 2 * COS(SINE / 24)
					end
					TextFrame.TextStrokeTransparency = 0
				end
			end))
			for i = 1,string.len(whom),1 do
				TextFrame.Text = string.sub(whom,1,i)
				wait(0.2)
			end
			wait(2)
			droppingFrame = true
			mainFrame.Rotation = 0
			local vinc2 = 1
			for i = 0, 99 do
				Swait()
				vinc2 = vinc2 + 0.25
				mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
			end
			scrg:Destroy()
		end))
	end
end

function warnedpeople2(text)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("Spinny")~= nil then
				v.PlayerGui:FindFirstChild("Spinny"):destroy()
			end
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "Spinny"
			local wobble = Instance.new("Frame",scrg)
			wobble.Name = "Wobble"
			wobble.BackgroundTransparency = 0.5
			wobble.Size = UDim2.new(1.1,0,1.1,0)
			wobble.Position = UDim2.new(-0.08,0,0.943,0)
			local wobble2 = Instance.new("Frame",scrg)
			wobble2.Name = "wobble2"
			wobble2.BackgroundTransparency = 0.5
			wobble2.Size = UDim2.new(1.1,0,0.09,0)
			wobble2.Position = UDim2.new(-0.08,0,0.878,0)
			local Visuals = Instance.new("Frame",scrg)
			Visuals.Name = "Visuals"
			Visuals.BackgroundTransparency = 0.3
			Visuals.Size = UDim2.new(0,100,0,100)
			Visuals.Position = UDim2.new(0.462,0,0.826,0)
			local glow = Instance.new("ImageLabel",scrg)
			glow.Name = "glow"
			glow.BackgroundTransparency = 1
			glow.ImageTransparency = 0
			glow.Image = "rbxassetid://2344870656"
			glow.Size = UDim2.new(0,0,0,0)
			glow.Position = UDim2.new(0.026,0,-0.235,0)
			local Visuals2 = Instance.new("Frame",scrg)
			Visuals2.Name = "Visuals2"
			Visuals2.BackgroundTransparency = 0.3
			Visuals2.Size = UDim2.new(0,50,0,50)
			Visuals2.Position = UDim2.new(0.48,0,0.867,0)
			local TextFrame = Instance.new("TextLabel",scrg)
			TextFrame.Name = "Farmer"
			TextFrame.Font = "SourceSansLight"
			TextFrame.Text = text
			TextFrame.TextScaled = true
			TextFrame.TextSize = 60
			TextFrame.BackgroundTransparency = 1
			TextFrame.Size = UDim2.new(0.8,0,0,42)
			TextFrame.Position = UDim2.new(0.11,0,0.867,0)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					TextFrame.TextColor3 = C3(1,0,0)
					TextFrame.TextStrokeColor3 = C3(0, 0, 0)
					TextFrame.TextStrokeTransparency = 0.7
					TextFrame.Rotation = 0 + MRANDOM(-3, 3)
					TextFrame.Position = UDim2.new(0.11, 0 + MRANDOM(-3, 3), 0.867, 0 + MRANDOM(-3, 3))
					TextFrame.Font = Enum.Font.Fantasy
					glow.ImageColor3 = C3(0, 0, 0)
					wobble.Rotation = 0 - 2 * COS(SINE / 24)
					wobble2.Rotation = 0 - 2 * COS(SINE / 30)
					wobble2.BackgroundColor3 = C3(0,0,0)
					wobble2.BorderColor3 = C3(1,0,0)
					wobble2.BorderSizePixel = 5
					Visuals.Rotation = Visuals.Rotation + MRANDOM(-5, 5)
					Visuals2.Rotation = Visuals2.Rotation + MRANDOM(-10, 10)
					Visuals.BackgroundColor3 = C3(0,0,0)
					Visuals.BorderColor3 = C3(1,0,0)
					Visuals2.BackgroundColor3 = C3(0,0,0)
					Visuals2.BorderColor3 = C3(1,0,0)
					wobble.BackgroundColor3 = C3(0,0,0)
					wobble.BorderColor3 = C3(1,0,0)
					wobble.BorderSizePixel = 5
				end
			end))
			coroutine.resume(coroutine.create(function()
				for i = 0, 205 do
					Swait()
				end
				scrg:Destroy()
			end))
		end))
	end
end

function warnedpeopleB(text)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		coroutine.resume(coroutine.create(function()
			if v.PlayerGui:FindFirstChild("Spinny")~= nil then
				v.PlayerGui:FindFirstChild("Spinny"):destroy()
			end
			local scrg = Instance.new("ScreenGui",v.PlayerGui)
			scrg.Name = "Spinny"
			local wobble = Instance.new("Frame",scrg)
			wobble.Name = "Wobble"
			wobble.BackgroundTransparency = 1
			wobble.Size = UDim2.new(1.1,0,1.1,0)
			wobble.Position = UDim2.new(-0.08,0,0.943,0)
			local wobble2 = Instance.new("Frame",scrg)
			wobble2.Name = "wobble2"
			wobble2.BackgroundTransparency = 1
			wobble2.Size = UDim2.new(1.1,0,0.09,0)
			wobble2.Position = UDim2.new(-0.08,0,0.878,0)
			local Visuals = Instance.new("Frame",scrg)
			Visuals.Name = "Visuals"
			Visuals.BackgroundTransparency = 1
			Visuals.Size = UDim2.new(0,100,0,100)
			Visuals.Position = UDim2.new(0.462,0,0.826,0)
			local glow = Instance.new("ImageLabel",scrg)
			glow.Name = "glow"
			glow.BackgroundTransparency = 1
			glow.ImageTransparency = 0
			glow.Image = "rbxassetid://2344870656"
			glow.Size = UDim2.new(0,0,0,0)
			glow.Position = UDim2.new(0.026,0,-0.235,0)
			local Visuals2 = Instance.new("Frame",scrg)
			Visuals2.Name = "Visuals2"
			Visuals2.BackgroundTransparency = 1
			Visuals2.Size = UDim2.new(0,50,0,50)
			Visuals2.Position = UDim2.new(0.48,0,0.867,0)
			local TextFrame = Instance.new("TextLabel",scrg)
			TextFrame.Name = "Farmer"
			TextFrame.Font = "SourceSansLight"
			TextFrame.Text = text
			TextFrame.TextScaled = true
			TextFrame.TextSize = 60
			TextFrame.BackgroundTransparency = 1
			TextFrame.Size = UDim2.new(0.8,0,0,42)
			TextFrame.Position = UDim2.new(0.11,0,0.867,0)
			local fvalen = 0.55
			local fval = -0.49
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					TextFrame.TextColor3 = C3(1,1,1)
					TextFrame.TextStrokeColor3 = C3(0, 0, 0)
					TextFrame.TextStrokeTransparency = 0.7
					TextFrame.Rotation = 0 + MRANDOM(-3, 3)
					TextFrame.Position = UDim2.new(0.11, 0 + MRANDOM(-3, 3), 0.867, 0 + MRANDOM(-3, 3))
					TextFrame.Font = Enum.Font.SourceSansLight
					glow.ImageColor3 = C3(0, 0, 0)
					wobble.Rotation = 0 - 2 * COS(SINE / 24)
					wobble2.Rotation = 0 - 2 * COS(SINE / 30)
					wobble2.BackgroundColor3 = C3(0,0,0)
					wobble2.BorderColor3 = C3(0,0,0)
					wobble2.BorderSizePixel = 0
					Visuals.Rotation = Visuals.Rotation + MRANDOM(-5, 5)
					Visuals2.Rotation = Visuals2.Rotation + MRANDOM(-10, 10)
					Visuals.BackgroundColor3 = C3(0,0,0)
					Visuals.BorderColor3 = C3(0,0,0)
					Visuals2.BackgroundColor3 = C3(0,0,0)
					Visuals2.BorderColor3 = C3(0,0,0)
					wobble.BackgroundColor3 = C3(0,0,0)
					wobble.BorderColor3 = C3(0,0,0)
					wobble.BorderSizePixel = 0
				end
			end))
			coroutine.resume(coroutine.create(function()
				for i = 0, 205 do
					Swait()
				end
				scrg:Destroy()
			end))
		end))
	end
end

function Killpp(dude)
	coroutine.resume(coroutine.create(function()
		if dude and dude ~= Character then
			local h = dude:FindFirstChildOfClass("Humanoid")
			local t = dude:FindFirstChild("Torso") or dude:FindFirstChild("UpperTorso") or dude:FindFirstChild("HumanoidRootPart")
			local deathp = Instance.new("Part",Effects) deathp.Anchored = true deathp.Size = Vector3.new() deathp.Transparency = 1 deathp.CanCollide = false deathp.CFrame = t.CFrame
			coroutine.wrap(function()
				deathp:Destroy()
			end)
			if h then
				if dude then
					for i,v in next, dude:children() do if v:IsA"LocalScript" or v:IsA"Script" or v:IsA"ModuleScript" then v.Disabled = true wait() v:destroy() end end
					CreateSound(206082273, deathp, 5, .75)
					if h then h.MaxHealth = 0 h.Health = 0 end
					for _, c in pairs(dude:GetChildren()) do if c:IsA("BasePart") then c:BreakJoints() c:Destroy() end end
					dude:BreakJoints()
					dude:Destroy()
					for i = 0, math.random(3,7) do
						WACKYEFFECTpp({Time = math.random(145,165), EffectType = "Sphere", Size = Vector3.new(10,10,10), Size2 = Vector3.new(5,80,5), Transparency = 0, Transparency2 = 1, CFrame = deathp.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))), MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
					end
					WACKYEFFECTpp({Time = math.random(72,82), EffectType = "Sphere", Size = Vector3.new(10,10,10), Size2 = Vector3.new(40,40,40), Transparency = 0.6, Transparency2 = 1, CFrame = deathp.CFrame, MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
					for i = 0, math.random(5,9) do
						WACKYEFFECTpp({Time = math.random(36,41), EffectType = "Sphere", Size = Vector3.new(18,18,18), Size2 = Vector3.new(6,6,6), Transparency = 0, Transparency2 = 1, CFrame = deathp.CFrame, MoveToPos = deathp.CFrame*CFrame.new(math.random(-95,95),math.random(-95,95),math.random(-95,95)).p, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, Boomerang = 45, SizeBoomerang = 40})
					end
				end
			end
		end
	end))
end

function ApplyAoEpp(POSITION,RANGE)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						Killpp(CHILD)
					end
				end
			end
		end
	end
end

function Transform()
	ATTACK = true
	Rooted = false
	UNANCHOR = false
	RootPart.Anchored = true
	for i=0, 5, 0.1 / 3 do
		Swait()
		RootPart.CFrame = RootPart.CFrame * CF(0,0.2,0)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 * 1, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 2 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 2 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 2 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 2 / Animation_Speed)
	end
	CreateSound("1368598393", Effects, 10, 1)
	for i=0, 2, 0.1 / 3 do
		Swait()
		local CFRAME = CF(Torso.Position)*ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)))
		MagicSphere(VT(0,0,0),15,CFRAME,"Hot pink",VT(0.1,0.1,5))
		MagicSphere(VT(0.1,0.1,0.1),15,CFRAME,"Hot pink",VT(0.1,0.1,5))
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 * 1, 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 2 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.5, -1) * ANGLES(RAD(90), RAD(0), RAD(-75)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.5, -1) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 2 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 2 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 2 / Animation_Speed)
	end
	CreateSound("1368583274", Effects, 10, 1)
	for i=0, 6, 0.1 / 3 do
		Swait()
		WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,100,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,100)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000), UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.25,0.015,0.25)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(1,360)),RAD(MRANDOM(1,360)),RAD(MRANDOM(1,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		local CFRAME = CF(Torso.Position)*ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)))
		MagicSphere(VT(0,0,0),15,CFRAME,"Hot pink",VT(0.1,0.1,55))
		MagicSphere(VT(0,0,0),15,CFRAME,"Hot pink",VT(2,2,2))
		MagicSphere(VT(0.1,0.1,0.1),15,CFRAME,"Hot pink",VT(0.1,0.1,55))
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 * 1, 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 2 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.5, -1) * ANGLES(RAD(90), RAD(0), RAD(-75)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.5, -1) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 2 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 2 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 2 / Animation_Speed)
	end
	CreateSound(136007472,Torso,10,1,false)
	Swait(100)
	CreateSound(847061203,Torso,3,1,false)
	CreateSound(239000203,Torso,3,1,false)
	CreateSound(579687077,Torso,3,0.75,false)
	MagicSphere(VT(0,0,0),45,Torso.CFrame,"Hot pink",VT(5,5,5))
	for i=0, 1, 0.1 / 3 do
		Swait()
		WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,100,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,100)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000), UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(1,0.01,1)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MRANDOM(1,360)),RAD(MRANDOM(1,360)),RAD(MRANDOM(1,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-25), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 * 1, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 2 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-60), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 2 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-50)), 2 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(50)), 2 / Animation_Speed)
	end
	UNANCHOR = true
	RootPart.Anchored = false
	ATTACK = false
	Rooted = false
end
function AzureX()
	SONG1 = 1028690723
	sick.TimePosition = 0
	sick.Volume = 100
	sick.Pitch = 1
	ChangeName("ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™ 卂　乙　ㄩ　尺　乇")
	Transform()
	Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","HAHAHAHAHHAHAHAHAHAH!!!!!!!")
	Speed = 60
	Weapon.Parent = Character
	Jump = 60
	BanishMode = 100000
	ChangeName("ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™ ₳ Ⱬ Ʉ Ɽ Ɇ Ӿ̷̜̪̺̙̤̲̘̱̮̰̪̭̝̯̖͎̘̙̣̩̆̆̈́̂̀̓̿͒̄̐̐̏̕͜͝͝")
	print("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]:TIME TO DISAPEAR!")
end
function DIE()
	SONG1 = 6149704441
	sick.TimePosition = 0
	sick.Volume = 100
	sick.Pitch = 0.8
	Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","WHY ARE YOU STILL HERE?!")
	Speed = 25
	Weapon.Parent = Character
	BanishMode = 446
	Jump = 50
	ChangeName("ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™ JɄ57 Đ!3 41Ɽ34ĐɎ!!!!")
	print("ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™:STOP SNOOPING FUCKTARD!!!!!!")
end
function Supernova_Grenade() 
	local TAUNTS = {907329532,907330011,907331307,907331307,907331443,907331784,907331575,907332040,907332235,907332525,907332670,907332856,907332997,907333294,907333406,907329669,907329293, 907331038}
	local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position + Vector3.new(0, -1, 0)).lookVector, 7 * Player_Size, Character)
	if HITFLOOR ~= nil then
		do
			local HITBODIES = {}
			ATTACK = true
			Rooted = true
			local ABSOLUTE = CreatePart2(3, Effects, "Neon", 0, 1, "Really black", "ABSOLUTEUM", Vector3.new(0, 0, 0))
			MakeForm(ABSOLUTE, "Ball")
			CreateSound("416200578", RootPart, 10, 1)
			for i = 0, 8, 0.1 / Animation_Speed do
				Swait()
				ABSOLUTE.Size = ABSOLUTE.Size + Vector3.new(0.2, 0.2, 0.2)
				ABSOLUTE.CFrame = RootPart.CFrame * CFrame.new(0, 5 + ABSOLUTE.Size.Y / 2, 0)
				ABSOLUTE.Transparency = ABSOLUTE.Transparency - 0.01
				local CHARGE = CreatePart2(3, Effects, "Neon", 0, 0, "Medium stone grey", "ABSOLUTEUM", Vector3.new(0,0,0))
				MakeForm(CHARGE, "Ball")
				CHARGE.CFrame = CF(RootPart.Position) * CF(MRANDOM(-15, 15), -15, MRANDOM(-15, 15))
				FireArc(CHARGE, ABSOLUTE.Position, 45, 45, true)
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			CreateSound(TAUNTS[MRANDOM(1, #TAUNTS)], Head, 10, 0.9)
			for i = 1, 45 do
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.65 - 0.03 * SIN(SINE / 12), 0) * ANGLES(RAD(150), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
			coroutine.resume(coroutine.create(function()
				local IMPACT = false
				local BULLET = ABSOLUTE
				MakeForm(BULLET, "Ball")
				BULLET.CFrame = CFrame.new(BULLET.Position, Mouse.Hit.p)
				for i = 1, 500 do
					Swait()
					BULLET.CFrame = BULLET.CFrame * CFrame.new(0, 0, -2)
					local HIT = Raycast(BULLET.Position, BULLET.CFrame.lookVector, BULLET.Size.X / 2, Character)
					MagicSphere(Vector3.new(10, 10, 10), 55, CFrame.new(BULLET.CFrame * CFrame.new(MRANDOM(-BULLET.Size.X / 2.5, BULLET.Size.X / 2.5), MRANDOM(-BULLET.Size.X / 2.5, BULLET.Size.X / 2.5), MRANDOM(-BULLET.Size.X / 2.5, BULLET.Size.X / 2.5)).p), "Medium stone grey", Vector3.new(-10, -10, -10) / 55)
					if HIT ~= nil then
						IMPACT = true
						break
					end
				end
				if IMPACT == false then
					for i = 1, 40 do
						Swait()
						BULLET.Size = BULLET.Size * 0.9
					end
					BULLET:remove()
				else
					CreateSound("1127492102", BULLET, 10, MRANDOM(8, 13) / 10)
					for i = 1, 175 do
						Swait()
						BULLET.Size = BULLET.Size * 0.99
						Sloice("Round", 0, 35, CFrame.new(BULLET.Position) * ANGLES(math.rad(MRANDOM(-18, 18)), math.rad(MRANDOM(-180, 180)), math.rad(MRANDOM(-18, 18))), "Medium stone grey", Vector3.new(i, 0, i) / 85)
					end
					CreateSound("438666001", BULLET, 10, 3)
					Swait(35)
					BULLET.Transparency = 1
					for i = 1, 20 do
						for e = 1, 5 do
							MagicSphere(Vector3.new(0.2, 0.2, 0.2), 50, CFrame.new(BULLET.CFrame * CFrame.new(MRANDOM(-5, 5), MRANDOM(-5, 5), MRANDOM(-5, 5)).p, BULLET.Position), "Medium stone grey", Vector3.new(1, 1, i * 4), 0)
							Sloice("Round", 0, 35, CFrame.new(BULLET.Position) * ANGLES(math.rad(MRANDOM(-18, 18)), math.rad(MRANDOM(-180, 180)), math.rad(MRANDOM(-18, 18))), "Medium stone grey", Vector3.new(i, 0, i) / 3)
						end
						AddChildrenToTable(BULLET.Position, workspace, i * 25, HITBODIES)
						CreateSound("178452241", BULLET, 10, MRANDOM(8, 13) / 10)
						CreateSound("178452243", BULLET, 10, MRANDOM(8, 13) / 10)
						MagicSphere(BULLET.Size, 35, BULLET.CFrame, Color3.new(0, 0, 0), Vector3.new(i, i, i) * 2)
						Swait(5)
						for e = 1, #HITBODIES do
							if HITBODIES[e] ~= nil then
								local BOD = HITBODIES[e]
								local TORS = BOD:FindFirstChild("Torso") or BOD:FindFirstChild("UpperTorso")
								if TORS then
									Kill(BOD)
									for _, c in pairs(BOD:GetChildren()) do
										if c.ClassName == "Part" or c.ClassName == "MeshPart" then
											local bv = Instance.new("BodyVelocity")
											bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
											bv.velocity = CFrame.new(BULLET.Position, c.Position).lookVector * 250
											bv.Parent = c
											Debris:AddItem(bv, 0.2)
										end
									end
								end
							end
						end
						CreateWave(Vector3.new(0, 2, 0), 75, CFrame.new(BULLET.Position), true, -15, "Really red", Vector3.new(i, 0, i) * 2)
					end
					MagicSphere(BULLET.Size, 100, BULLET.CFrame, Color3.new(0, 0, 0), Vector3.new(12, 12, 12))
					Debris:AddItem(BULLET, 10)
				end
			end))
			ATTACK = false
			Rooted = false
		end
	end
end
function CreatePart2(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
function Sloice(KIND, SIZE, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart2(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", Vector3.new(1, 1, 1), true)
	local mesh
	if KIND == "Base" then
		mesh = CreateMesh2("SpecialMesh", wave, "FileMesh", "448386996", "", Vector3.new(0, SIZE / 10, SIZE / 10), Vector3.new(0, 0, 0))
	elseif KIND == "Thin" then
		mesh = CreateMesh2("SpecialMesh", wave, "FileMesh", "662586858", "", Vector3.new(SIZE / 10, 0, SIZE / 10), Vector3.new(0, 0, 0))
	elseif KIND == "Round" then
		mesh = CreateMesh2("SpecialMesh", wave, "FileMesh", "662585058", "", Vector3.new(SIZE / 10, 0, SIZE / 10), Vector3.new(0, 0, 0))
	end
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW / 10
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function CreateMesh2(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end
function Kill(Char)
	local NewCharacter = IT("Model",Effects)
	NewCharacter.Name = "I've been raped"
	for _, c in pairs(Char:GetDescendants()) do
		if c:IsA("BasePart") and c.Transparency == 0 then
			c:BreakJoints()
			c.Material = "Glass"
			c.Color = Color3.new(1,0,0)
			c.CanCollide = true
			c.Transparency = 0.3
			if c:FindFirstChildOfClass("SpecialMesh") then
				c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
			end
			if c.Name == "Head" then
				c:ClearAllChildren()
				c.Size = Vector3.new(c.Size.Y,c.Size.Y,c.Size.Y)
			end
			if c.ClassName == "MeshPart" then
				c.TextureID = ""
			end
			if c:FindFirstChildOfClass("BodyPosition") then
				c:FindFirstChildOfClass("BodyPosition"):remove()
			end
			if c:FindFirstChildOfClass("ParticleEmitter") then
				c:FindFirstChildOfClass("ParticleEmitter"):remove()
			end
			c.Parent = NewCharacter
			c.Name = "DeadPart"
			c.Velocity = Vector3.new(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45))/15
			c.RotVelocity = Vector3.new(MRANDOM(-45,45),MRANDOM(-15,85),MRANDOM(-45,45))
		end
	end
	Char:remove()
	Debris:AddItem(NewCharacter,5)
end
function Advancedchatfunc(text)
	local chat = coroutine.wrap(function()
		if Character:FindFirstChild("TalkingBillBoard")~= nil then
			Character:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local Bill = Instance.new("BillboardGui",Character)
		Bill.Size = UDim2.new(0,100,0,40)
		Bill.StudsOffset = Vector3.new(0,3,0)
		Bill.Adornee = Character.Head
		Bill.Name = "TalkingBillBoard"
		local Hehe = Instance.new("TextLabel",Bill)
		Hehe.BackgroundTransparency = 1
		Hehe.BorderSizePixel = 0
		Hehe.Text = ""
		Hehe.Font = "Garamond"
		Hehe.TextSize = 40
		Hehe.TextStrokeTransparency = 0
		Hehe.Size = UDim2.new(1,0,0.5,0)
		coroutine.resume(coroutine.create(function()
			while Hehe ~= nil do
				Swait()	
				Hehe.Position = UDim2.new(0,math.random(-1.5,1.5),0,math.random(-1.5,1.5))	
				Hehe.Rotation = 0-2*math.random(-1.5,1.5)
				if MRANDOM(1,2) == 1 then
					Hehe.TextColor3 = C3(107, 0, 0)
					Hehe.TextStrokeColor3 = C3(0,0,0)
				else
					Hehe.TextColor3 = C3(107, 0, 0)
					Hehe.TextStrokeColor3 = C3(0,0,0)
				end
			end
		end))
		for i = 1,string.len(text),1 do
			Swait()
			Hehe.Text = string.sub(text,1,i)
		end
		Swait(30)
		local rrot = math.random(1,2)
		if rrot == 1 then
			Hehe.Text = ""
			CreateSound(749189256,RootPart,2,math.random(5, 15) / 10,false)
			for i = 1, 100 do
				swait()
				Hehe.Text = Hehe.Text.. string.char(math.random(0,126)) -- Encodes The Chat String After You Say Something With It
				Hehe.Position = Hehe.Position - UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
				Hehe.Rotation = Hehe.Rotation - .8
				Hehe.TextStrokeTransparency = Hehe.TextStrokeTransparency +.02
				Hehe.TextTransparency = Hehe.TextTransparency + .02
			end
		elseif rrot == 2 then
			Hehe.Text = ""
			CreateSound(749189256,RootPart,2,math.random(5, 15) / 10,false)
			for i = 1, 100 do
				swait()
				Hehe.Text = Hehe.Text.. string.char(math.random(0,126))
				Hehe.Position = Hehe.Position - UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
				Hehe.Rotation = Hehe.Rotation - .8
				Hehe.TextStrokeTransparency = Hehe.TextStrokeTransparency +.02
				Hehe.TextTransparency = Hehe.TextTransparency + .02
			end
		end
		Bill:Destroy()
	end)
	chat()
end

function onChatted(msg)
	Advancedchatfunc(msg)
end

Player.Chatted:connect(onChatted)



--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

function KeyDown(Key)
	KEYHOLD = true
	if Key == "f" and ATTACK == false then
		TOBANISH = {}
		BannedSkids = {}
		Notify("ULTRA SKIDDED CHILL /  ","FINE! ill let you go!")
	end

	if Key == "z" and ATTACK == false then
		if BanishMode == 782 then
			Karma_Beam()
		else
			BanishBullet()
		end
	end

	if Key == "v" and ATTACK == false then
		Pure_Heaven()
	end

	if Key == "x" and ATTACK == false then
		if BanishMode == 999999 then
			Supernova_Grenade() 
		else
			Overthrower()
		end
	end	

	if Key == "k" and ATTACK == false then
		ToggleSome()
	end

	if Key == "l" and ATTACK == false then
		DoGlitchBug()
	end
	if Key == ";" and ATTACK == false then
		ToggleHead()
	end
	if Key == "9" and ATTACK == false and BanishMode ~= 1245 and BanishMode ~= 1245 then
		SONG1 = 1145101566
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 16
		BanishMode = 1245
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / Destiny")
	end

	if Key == "m" and ATTACK == false and BanishMode == 564 then
		SONG1 = 5636798692
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 20
		BanishMode = 987
		Jump = 150
		ChangeName("ULTRA SKIDDED CHILL /  3no 3HT")
		disably = false
		warnedpeople3("I AM THE ONE!","Arcade",Color3.new(1,1,1),Color3.new(1,1,1))
		disably = true
		print('ULTRA SKIDDED CHILL / :I AM THE ONE!')
	end

	if Key == "b" and ATTACK == false and BanishMode == 564 then
		SONG1 = 228255592
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.6
		Notify("ULTRA SKIDDED CHILL /  ","not all fairys are nice...")
		Speed = 20
		BanishMode = 963
		Jump = 100
		ChangeName("ULTRA SKIDDED CHILL /  fairy")
		disably = false
		warnedpeople3("ⱧɆⱧɆ....","Arcade",Color3.new(1,1,1),Color3.new(1,1,1))
		disably = true
		print("ULTRA SKIDDED CHILL / I'm of fae kind sweetheart~")
	end
	if Key == "n" and ATTACK == false and BanishMode == 564 then
		SONG1 = 5343314816
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 1.2
		Notify("ULTRA SKIDDED CHILL /  ","As Negaliu, Tiesiog Negaliu...")
		Speed = 40
		BanishMode = 158
		Jump = 150
		ChangeName("ULTRA SKIDDED CHILL /  Negaliu!")
		disably = false
		warnedpeople3("As Negaliu, Tiesiog Negaliu...","Arcade",Color3.new(1,1,1),Color3.new(1,1,1))
		disably = true
		print('ULTRA SKIDDED CHILL / As Negaliu!! As TIESIOG NEGALIU!!')
	end

	if Key == "8" and ATTACK == false and BanishMode ~= 1234 and BanishMode ~= 1234 then
		SONG1 = 2378768630
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("[ULTRA SKIDDED CHILL / ]: ","...")
		Speed = 16
		BanishMode = 1234
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / Never Die")
		disably = false
		warnedpeople3("...","Arcade",Color3.new(1,1,1),Color3.new(1,1,1))
		disably = true
	end

	if Key == "t" and ATTACK == false and BanishMode ~= 366 and BanishMode ~= 366 then
		SONG1 = 591596506
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("N0!N4M3.Err0rC0d3:!666!: ","G0d W4nts M3 D34d...")
		print('N0!N4M3.Err0rC0d3:!666:H3LP MEeEE... WH4T IS HAPPENINNNNNNNNNNNNNNN...... IT HURTS IT HURTS IT HURTS SO MUCH AHHHHHHH...... FUCKING WARYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY.... G0D W4ANTS ME D34D HELP HELP HELP HELP HELP HELP PLEASE!!!!!!!!!!!! SOMEONE?! ANYONE!!! PLEASE PLEASE JUST MAKE IT STOP MY HEAD M̶̦̞̹̥̖̙̮̤̰͎̆̔̐̃̕͜Y̸̯͔͗̃̊̀̀̎̅̈́͆̒́̔͒͝͝ ̷̡̲̥̬͇͈̳̩̻̜͈͉̯͎̯̅͊̿̓͜F̷̣̥̱̞̖̭́̊͗͛Ų̷̤̞̱̗̫̹͌̀̅̋̂͂̃̍̀̇͛͠C̷̢͈͚͉̠̟͍̘̳̦̦̹̞̞̥̈́̀ͅK̸̜̜͓͔̪͋̏̍̔͐͠ͅI̶͉͉̜̪̮͔̒̾͌͌̔̈͐͊̃̐̕͘͠Ṅ̶͍̟̳͋͛͛̂̚͠͠͠͠G̸̮͚̖̥̳͈̫͒̎͗́͋͛̅́̂͊̓̐͒̚ ̷̢̧̻̝̬̮͈̜̟̫̲̪̞͔͉̿̊̾̾͂̓̆͜͠H̴̗̘̣̀̌E̵͈̒̊͊̒͘͘̕͝͝͝4̷͚͂̍͘D̸̬͈͇̻̹̮͎̄̇̅͆̈͌̃̔̇̋͘͜D̵͓̝̐́͐̉̇̕͝D̶̬̟͎͖͉̟͉̪͔̆̃̔̏̆̀̈́̈́̆̇̿͛̋͜͝D̴̡̞̊́̃̿̀̽͂̓̆̚̚͘͜͝Ḋ̶̥͈͇̳̘̣̦̲̹̐̉̃̎̎̄̕͝͝D̶͍̞̲̣̤̯̩̲͕͍͎̟͖̝͖̽̓̊̄̑͐̅͊̓̿̕͘̕̕͘͝͠ͅḐ̸̼̞̼̄͊D̸͇͔̔̋̌̑̌͐̄̓̚D̷̡̨̙͚̩̟͙̺̮͍͈̥̯̜͍̜̮̄̔̄͌͠D̷̲̯̪̩͈̱̒Ḑ̸̪̫̤͚͓̬͆̈́̄̉̿̓̑́D̴̛̞̟͍͇̦͙̠̈́͗̂̍̐̇̇͂̓̊̔̕d̵̘̪̼̓͐̿̏̌̇̈̐̏̓͑̔̓̚d̴͈̠̒͐͌̂̉̆̊͑̄̑͆͐͗̉̋̈́̚d̵̛̹̥͖̫̖͇̉͗̆̓͋̈́̈́̈͌͘ď̵̩̱̘͕̟͍̻̏d̷̛͇̟͉̼͌͌̏͋̈́̔͂̔̿͛̍͌̚ḑ̸̮̙̟̊͆͠d̴̨̧͈̣̟̣͙̟̠̠͕͔͉̝̟̥̀ď̷̯̆̒͝d̸̡̢̡̜̝̭̹̗͒̽̊͂͐̀̉̀̊͘d̶̝̒̋͋́̎̆̽̊̈́̐̄͗̃́͜͠ͅd̵̡̛̟̙͍͚̼̬̦̜̖̲́̀̂̄̿͊̈́̇̾͐̐̚͝   G3T OUT OF MY H34D GET OUT! GET OUT!!!!!!!!!!!!!!! I. WILL. END. YOU. <3')
		print('N0!N4M3.Err0rC0d3:!666:H3LP MEeEE... WH4T IS HAPPENINNNNNNNNNNNNNNN...... IT HURTS IT HURTS IT HURTS SO MUCH AHHHHHHH...... FUCKING WARYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY.... G0D W4ANTS ME D34D HELP HELP HELP HELP HELP HELP PLEASE!!!!!!!!!!!! SOMEONE?! ANYONE!!! PLEASE PLEASE JUST MAKE IT STOP MY HEAD M̶̦̞̹̥̖̙̮̤̰͎̆̔̐̃̕͜Y̸̯͔͗̃̊̀̀̎̅̈́͆̒́̔͒͝͝ ̷̡̲̥̬͇͈̳̩̻̜͈͉̯͎̯̅͊̿̓͜F̷̣̥̱̞̖̭́̊͗͛Ų̷̤̞̱̗̫̹͌̀̅̋̂͂̃̍̀̇͛͠C̷̢͈͚͉̠̟͍̘̳̦̦̹̞̞̥̈́̀ͅK̸̜̜͓͔̪͋̏̍̔͐͠ͅI̶͉͉̜̪̮͔̒̾͌͌̔̈͐͊̃̐̕͘͠Ṅ̶͍̟̳͋͛͛̂̚͠͠͠͠G̸̮͚̖̥̳͈̫͒̎͗́͋͛̅́̂͊̓̐͒̚ ̷̢̧̻̝̬̮͈̜̟̫̲̪̞͔͉̿̊̾̾͂̓̆͜͠H̴̗̘̣̀̌E̵͈̒̊͊̒͘͘̕͝͝͝4̷͚͂̍͘D̸̬͈͇̻̹̮͎̄̇̅͆̈͌̃̔̇̋͘͜D̵͓̝̐́͐̉̇̕͝D̶̬̟͎͖͉̟͉̪͔̆̃̔̏̆̀̈́̈́̆̇̿͛̋͜͝D̴̡̞̊́̃̿̀̽͂̓̆̚̚͘͜͝Ḋ̶̥͈͇̳̘̣̦̲̹̐̉̃̎̎̄̕͝͝D̶͍̞̲̣̤̯̩̲͕͍͎̟͖̝͖̽̓̊̄̑͐̅͊̓̿̕͘̕̕͘͝͠ͅḐ̸̼̞̼̄͊D̸͇͔̔̋̌̑̌͐̄̓̚D̷̡̨̙͚̩̟͙̺̮͍͈̥̯̜͍̜̮̄̔̄͌͠D̷̲̯̪̩͈̱̒Ḑ̸̪̫̤͚͓̬͆̈́̄̉̿̓̑́D̴̛̞̟͍͇̦͙̠̈́͗̂̍̐̇̇͂̓̊̔̕d̵̘̪̼̓͐̿̏̌̇̈̐̏̓͑̔̓̚d̴͈̠̒͐͌̂̉̆̊͑̄̑͆͐͗̉̋̈́̚d̵̛̹̥͖̫̖͇̉͗̆̓͋̈́̈́̈͌͘ď̵̩̱̘͕̟͍̻̏d̷̛͇̟͉̼͌͌̏͋̈́̔͂̔̿͛̍͌̚ḑ̸̮̙̟̊͆͠d̴̨̧͈̣̟̣͙̟̠̠͕͔͉̝̟̥̀ď̷̯̆̒͝d̸̡̢̡̜̝̭̹̗͒̽̊͂͐̀̉̀̊͘d̶̝̒̋͋́̎̆̽̊̈́̐̄͗̃́͜͠ͅd̵̡̛̟̙͍͚̼̬̦̜̖̲́̀̂̄̿͊̈́̇̾͐̐̚͝   G3T OUT OF MY H34D GET OUT! GET OUT!!!!!!!!!!!!!!! I. WILL. END. YOU. <3')
		print('N0!N4M3.Err0rC0d3:!666:H3LP MEeEE... WH4T IS HAPPENINNNNNNNNNNNNNNN...... IT HURTS IT HURTS IT HURTS SO MUCH AHHHHHHH...... FUCKING WARYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY.... G0D W4ANTS ME D34D HELP HELP HELP HELP HELP HELP PLEASE!!!!!!!!!!!! SOMEONE?! ANYONE!!! PLEASE PLEASE JUST MAKE IT STOP MY HEAD M̶̦̞̹̥̖̙̮̤̰͎̆̔̐̃̕͜Y̸̯͔͗̃̊̀̀̎̅̈́͆̒́̔͒͝͝ ̷̡̲̥̬͇͈̳̩̻̜͈͉̯͎̯̅͊̿̓͜F̷̣̥̱̞̖̭́̊͗͛Ų̷̤̞̱̗̫̹͌̀̅̋̂͂̃̍̀̇͛͠C̷̢͈͚͉̠̟͍̘̳̦̦̹̞̞̥̈́̀ͅK̸̜̜͓͔̪͋̏̍̔͐͠ͅI̶͉͉̜̪̮͔̒̾͌͌̔̈͐͊̃̐̕͘͠Ṅ̶͍̟̳͋͛͛̂̚͠͠͠͠G̸̮͚̖̥̳͈̫͒̎͗́͋͛̅́̂͊̓̐͒̚ ̷̢̧̻̝̬̮͈̜̟̫̲̪̞͔͉̿̊̾̾͂̓̆͜͠H̴̗̘̣̀̌E̵͈̒̊͊̒͘͘̕͝͝͝4̷͚͂̍͘D̸̬͈͇̻̹̮͎̄̇̅͆̈͌̃̔̇̋͘͜D̵͓̝̐́͐̉̇̕͝D̶̬̟͎͖͉̟͉̪͔̆̃̔̏̆̀̈́̈́̆̇̿͛̋͜͝D̴̡̞̊́̃̿̀̽͂̓̆̚̚͘͜͝Ḋ̶̥͈͇̳̘̣̦̲̹̐̉̃̎̎̄̕͝͝D̶͍̞̲̣̤̯̩̲͕͍͎̟͖̝͖̽̓̊̄̑͐̅͊̓̿̕͘̕̕͘͝͠ͅḐ̸̼̞̼̄͊D̸͇͔̔̋̌̑̌͐̄̓̚D̷̡̨̙͚̩̟͙̺̮͍͈̥̯̜͍̜̮̄̔̄͌͠D̷̲̯̪̩͈̱̒Ḑ̸̪̫̤͚͓̬͆̈́̄̉̿̓̑́D̴̛̞̟͍͇̦͙̠̈́͗̂̍̐̇̇͂̓̊̔̕d̵̘̪̼̓͐̿̏̌̇̈̐̏̓͑̔̓̚d̴͈̠̒͐͌̂̉̆̊͑̄̑͆͐͗̉̋̈́̚d̵̛̹̥͖̫̖͇̉͗̆̓͋̈́̈́̈͌͘ď̵̩̱̘͕̟͍̻̏d̷̛͇̟͉̼͌͌̏͋̈́̔͂̔̿͛̍͌̚ḑ̸̮̙̟̊͆͠d̴̨̧͈̣̟̣͙̟̠̠͕͔͉̝̟̥̀ď̷̯̆̒͝d̸̡̢̡̜̝̭̹̗͒̽̊͂͐̀̉̀̊͘d̶̝̒̋͋́̎̆̽̊̈́̐̄͗̃́͜͠ͅd̵̡̛̟̙͍͚̼̬̦̜̖̲́̀̂̄̿͊̈́̇̾͐̐̚͝   G3T OUT OF MY H34D GET OUT! GET OUT!!!!!!!!!!!!!!! I. WILL. END. YOU. <3')
		print('N0!N4M3.Err0rC0d3:!666:H3LP MEeEE... WH4T IS HAPPENINNNNNNNNNNNNNNN...... IT HURTS IT HURTS IT HURTS SO MUCH AHHHHHHH...... FUCKING WARYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY.... G0D W4ANTS ME D34D HELP HELP HELP HELP HELP HELP PLEASE!!!!!!!!!!!! SOMEONE?! ANYONE!!! PLEASE PLEASE JUST MAKE IT STOP MY HEAD M̶̦̞̹̥̖̙̮̤̰͎̆̔̐̃̕͜Y̸̯͔͗̃̊̀̀̎̅̈́͆̒́̔͒͝͝ ̷̡̲̥̬͇͈̳̩̻̜͈͉̯͎̯̅͊̿̓͜F̷̣̥̱̞̖̭́̊͗͛Ų̷̤̞̱̗̫̹͌̀̅̋̂͂̃̍̀̇͛͠C̷̢͈͚͉̠̟͍̘̳̦̦̹̞̞̥̈́̀ͅK̸̜̜͓͔̪͋̏̍̔͐͠ͅI̶͉͉̜̪̮͔̒̾͌͌̔̈͐͊̃̐̕͘͠Ṅ̶͍̟̳͋͛͛̂̚͠͠͠͠G̸̮͚̖̥̳͈̫͒̎͗́͋͛̅́̂͊̓̐͒̚ ̷̢̧̻̝̬̮͈̜̟̫̲̪̞͔͉̿̊̾̾͂̓̆͜͠H̴̗̘̣̀̌E̵͈̒̊͊̒͘͘̕͝͝͝4̷͚͂̍͘D̸̬͈͇̻̹̮͎̄̇̅͆̈͌̃̔̇̋͘͜D̵͓̝̐́͐̉̇̕͝D̶̬̟͎͖͉̟͉̪͔̆̃̔̏̆̀̈́̈́̆̇̿͛̋͜͝D̴̡̞̊́̃̿̀̽͂̓̆̚̚͘͜͝Ḋ̶̥͈͇̳̘̣̦̲̹̐̉̃̎̎̄̕͝͝D̶͍̞̲̣̤̯̩̲͕͍͎̟͖̝͖̽̓̊̄̑͐̅͊̓̿̕͘̕̕͘͝͠ͅḐ̸̼̞̼̄͊D̸͇͔̔̋̌̑̌͐̄̓̚D̷̡̨̙͚̩̟͙̺̮͍͈̥̯̜͍̜̮̄̔̄͌͠D̷̲̯̪̩͈̱̒Ḑ̸̪̫̤͚͓̬͆̈́̄̉̿̓̑́D̴̛̞̟͍͇̦͙̠̈́͗̂̍̐̇̇͂̓̊̔̕d̵̘̪̼̓͐̿̏̌̇̈̐̏̓͑̔̓̚d̴͈̠̒͐͌̂̉̆̊͑̄̑͆͐͗̉̋̈́̚d̵̛̹̥͖̫̖͇̉͗̆̓͋̈́̈́̈͌͘ď̵̩̱̘͕̟͍̻̏d̷̛͇̟͉̼͌͌̏͋̈́̔͂̔̿͛̍͌̚ḑ̸̮̙̟̊͆͠d̴̨̧͈̣̟̣͙̟̠̠͕͔͉̝̟̥̀ď̷̯̆̒͝d̸̡̢̡̜̝̭̹̗͒̽̊͂͐̀̉̀̊͘d̶̝̒̋͋́̎̆̽̊̈́̐̄͗̃́͜͠ͅd̵̡̛̟̙͍͚̼̬̦̜̖̲́̀̂̄̿͊̈́̇̾͐̐̚͝   G3T OUT OF MY H34D GET OUT! GET OUT!!!!!!!!!!!!!!! I. WILL. END. YOU. <3')
		Speed = 16
		BanishMode = 366
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / glitchy")
		disably = false
		disably = true
	end

	if Key == "7" and ATTACK == false and BanishMode ~= 444 and BanishMode ~= 444 then
		SONG1 = 2683294752
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.6
		Notify("ULTRA SKIDDED CHILL /  ","My Demons....")
		Speed = 16
		BanishMode = 444
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL /  D E M O N S")
	end

	if Key == "m" and ATTACK == false and BanishMode == 444 and BanishMode ~= 445 then
		SONG1 = 5177243035
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","........... I-... I'm Sorry...")
		Speed = 16
		BanishMode = 445
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL /  Ƨ ᄂ Λ Ц G Ή Ƭ Σ Я")
		print("ULTRA SKIDDED CHILL / WHAT HAVE I DONE!!!!!")
	end

	if Key == "n" and ATTACK == false and BanishMode == 445 then
		DIE()
	end

	if Key == "6" and ATTACK == false and BanishMode ~= 1222 and BanishMode ~= 1222 then
		SONG1 = 5985681772
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","I  L O V E  Y O U  <3")
		Speed = 16
		BanishMode = 1222
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL /  L O V E")
	end

	if Key == "5" and ATTACK == false and BanishMode ~= 1111 and BanishMode ~= 1111 then
		SONG1 = 151915559
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 16
		BanishMode = 1111
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL /  GodCat")
	end

	if Key == "b" and ATTACK == false and BanishMode == 1111 and BanishMode ~= 5555 then
		SONG1 = 844654533
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 1
		Notify("ULTRA SKIDDED CHILL /  ","H3LP 1 30ST M4 C0L04!!!")
		Speed = 60
		BanishMode = 5555
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL /  Uncolored")
		print('ULTRA SKIDDED CHILL / WHERE IS MY COLOR???')
	end

	if Key == "m" and ATTACK == false and BanishMode == 1111 and BanishMode ~= "tale" then
		SONG1 = 5005602881
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL / ","я покажу тебе свою сказку :)")
		Speed = 16
		BanishMode = "tale"
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL /  cheaky")
	end

	if Key == "n" and ATTACK == false and BanishMode == 1111 and BanishMode ~= 3333 then
		SONG1 = 1836283178
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","Dieses Lied ist fur Elise...")
		Speed = 10
		BanishMode = 3333
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL /  Elise")
	end

	if Key == "4" and ATTACK == false and BanishMode ~= 564 and BanishMode ~= 1444 then
		SONG1 = 1070233743
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.6
		Notify("ULTRA SKIDDED CHILL /  ","Horns are a Symbol of Strength...")
		Speed = 16
		BanishMode = 564
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL /  H O R N S")
		disably = false
		warnedpeople3("H O R N S","Arcade",Color3.new(1,1,1),Color3.new(1,1,1))
		disably = true
	end

	if Key == "3" and ATTACK == false and BanishMode ~= 1456 and BanishMode ~= 1456 then
		SONG1 = 4689643970
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL / : ","!~Rainbows~!")
		Speed = 16
		BanishMode = 1456
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL /  ~Rainbow~")
	end

	if Key == "m" and ATTACK == false and BanishMode == 1456 and BanishMode ~= 1457 then
		SONG1 = 6906652868
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","With a Taste Of Your Lips....")
		Speed = 30
		BanishMode = 1457
		Jump = 60
		ChangeName("ULTRA SKIDDED CHILL /  t0xiC")
		print("ULTRA SKIDDED CHILL / I'm On a Ride~")
	end

	if Key == "b" and ATTACK == false and BanishMode == 1456 and BanishMode ~= 1459 then
		SONG1 = 6839172099
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","OOFED UP!!!!!!!!")
		Speed = 50
		BanishMode = 1459
		Jump = 60
		ChangeName("ULTRA SKIDDED CHILL / ERROR OOFED UP!!!!!")
		print("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]:OOFED UP! OOFED UP!")
	end

	if Key == "n" and ATTACK == false and BanishMode == 1456 and BanishMode ~= 1458 then
		SONG1 = 2100837404
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","Thiago?")
		Speed = 40
		BanishMode = 1458
		Jump = 60
		ChangeName("ULTRA SKIDDED CHILL / Thiago")
		print("ULTRA SKIDDED CHILL / Who's Thiago?")
	end

	if Key == "e" and ATTACK == false and BanishMode ~= 5 and BanishMode ~= 5 then
		SONG1 = 6134176089
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 14
		BanishMode = 5
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / FEARLESS")
		disably = false
		disably = true
		print("ULTRA SKIDDED CHILL:I FEEL NO FEAR!")
	end

	if Key == "q" and ATTACK == false and BanishMode ~= 876 and BanishMode ~= 876 then
		SONG1 = 199531143
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 16
		BanishMode = 876
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / SCARY")
	end

	if Key == "n" and ATTACK == false and BanishMode == 872 and BanishMode ~= 7834 then
		SONG1 = 1789295287
		sick.PlaybackSpeed = 1
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 16
		BanishMode = 7834
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / ERROR")
	end

	if Key == "g" and ATTACK == false and BanishMode ~= 782 and BanishMode ~= 782 then
		SONG1 = 3043113091
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 16
		BanishMode = 782
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / KARMA")
	end

	if Key == "m" and ATTACK == false and BanishMode == 782 and BanishMode ~= 60 then
		SONG1 = 4565857495
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 16
		BanishMode = 60
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / Bye Bye")
		disably = false
		disably = true
	end

	if Key == "n" and ATTACK == false and BanishMode == 782 and BanishMode ~= 64 then
		SONG1 = 4565796080
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 50
		BanishMode = 64
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / BAD APPLE!!")
		disably = false
		disably = true
	end

	if Key == "b" and ATTACK == false and BanishMode == 782 and BanishMode ~= 61 then
		SONG1 = 4803739565
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 25
		BanishMode = 61
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / D R O W N I N G")
		disably = true
	end

	if Key == "0" and ATTACK == false and BanishMode ~= 872 and BanishMode ~= 872 then
		SONG1 = 693163614
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 16
		BanishMode = 872
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / HELL")
	end

	if Key == "r" and ATTACK == false and BanishMode ~= 865 and BanishMode ~= 865 then
		SONG1 = 2805006430
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 1
		Speed = 16
		BanishMode = 865
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / Mind")
	end

	if Key == "m" and ATTACK == false and BanishMode == 865 and BanishMode ~= 5986 then
		SONG1 = 5122067608
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 10
		BanishMode = 5986
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / そう言う")
	end

	if Key == "n" and ATTACK == false and BanishMode == 865 and BanishMode ~= 159 then
		SONG1 = 786465393
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 40
		BanishMode = 159
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / Milk")
	end

	if Key == "2" and ATTACK == false and BanishMode ~= 1666 and BanishMode ~= 1666 then
		SONG1 = 5368276808
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 16
		BanishMode = 1666
		Jump = 50
		ChangeName("ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™ Addict")
	end

	if Key == "m" and ATTACK == false and BanishMode == 1666 and BanishMode ~= 1667 then
		SONG1 = 6190635423
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("[ɄⱠ₮Ɽ₳₴₭łĐĐɆĐ ᴄʜӾʟʟ™]: ","TIME TO DIE!!!")
		Speed = 60
		BanishMode = 1667
		Jump = 70
		ChangeName("ULTRA SKIDDED CHILL / death")
	end

	if Key == "n" and ATTACK == false and BanishMode == 1666 and BanishMode ~= 1668 then
		SONG1 = 614032233
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","UGH!!! I'M SO FUCKING PISSED!!!")
		Speed = 20
		BanishMode = 1668
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL /  M A Y H E M")
	end

	if Key == "y" and ATTACK == false and BanishMode ~= 666 and BanishMode ~= 1444 then
		SONG1 = 535308988
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 16
		BanishMode = 666
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / SAD :(")
	end

	if Key == "m" and ATTACK == false and BanishMode == 666 and BanishMode ~= 777777 then
		SONG1 = 6550547757
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 30
		BanishMode = 777777
		Jump = 60
		ChangeName("ULTRA SKIDDED CHILL / Holy")
		disably = false
		disably = true
	end

	if Key == "n" and ATTACK == false and BanishMode == 777777 and BanishMode ~= 7777778 then
		SONG1 = 7051343768
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 1
		Speed = 50
		BanishMode = 7777778
		Jump = 60
		ChangeName("ULTRA SKIDDED CHILL / UNHOLY!")
		disably = true

	end

	if Key == "b" and ATTACK == false and BanishMode == 666 and BanishMode ~= 999999 then
		SONG1 = 652769726
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 20
		BanishMode = 999999
		Jump = 60
		ChangeName("ULTRA SKIDDED CHILL /  卂　乙　ㄩ　尺　乇")
	end

	if Key == "n" and ATTACK == false and BanishMode == 666 and BanishMode ~= 888888 then
		SONG1 = 5976091608
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 50
		BanishMode = 888888
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / monster truck")
		disably = false
		disably = true
	end

	if Key == "j" and ATTACK == false and BanishMode ~= "chxll" and BanishMode ~= 1444 then
		SONG1 = 4400049013
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 16
		BanishMode = "chxll"
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL / CHILL")
	end
	if Key == "m" and ATTACK == false and BanishMode == "chxll" and BanishMode ~= 1444 then
		SONG1 = 2510287474
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 10
		BanishMode = 20
		Jump = 10
		ChangeName("ULTRA SKIDDED CHILL / S i n g To M e")
	end

	if Key == "n" and ATTACK == false and BanishMode == "chxll" and BanishMode ~= 1444 then
		SONG1 = 2921405526
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","Jojo? Bruh...")
		Speed = 10
		BanishMode = 30
		Jump = 10
		ChangeName("ULTRA SKIDDED CHILL /   stream")
	end

	if Key == "b" and ATTACK == false and BanishMode == "chxll" and BanishMode ~= 1444 then
		SONG1 = 6604015501
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","Who the hell are Tia and Tamera?")
		Speed = 40
		BanishMode = 33
		Jump = 70
		ChangeName("ULTRA SKIDDED CHILL /  Ƭ I Λ  т α м є я α")
		disably = false
		warnedpeople3("Ƭ I Λ  т α м є я α","Arcade",Color3.new(1,1,1),Color3.new(1,1,1))
		disably = true
	end

	if Key == "p" and ATTACK == false and BanishMode ~= 324 and BanishMode ~= 1444 then
		Notify("ULTRA SKIDDED CHILL /  ","Fuck off and let me listen to my music.")
		SONG1 = 467883470
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 12
		Jump = 40
		BanishMode = 324
		ChangeName("ULTRA SKIDDED CHILL / ʜ x 卩 乇™")
		disably = false
		disably = true
	end

	if Key == "u" and ATTACK == false and BanishMode ~= 3 and BanishMode ~= 1444 then
		SONG1 = 6247294001
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 1
		Notify("ULTRA SKIDDED CHILL /  ","hehe~ owo")
		Speed = 50
		BanishMode = 3
		Jump = 50
		ChangeName("ULTRA SKIDDED CHILL /  D̾尺乇卂爪乇尺")
	end

	if Key == "m" and ATTACK == false and BanishMode == 3 and BanishMode ~= 900 and BanishMode ~= 1444 then
		SONG1 = 4068828414
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 60
		BanishMode = 900
		Jump = 100
		ChangeName("ULTRA SKIDDED CHILL /  ρσѕιтινє")
	end

	if Key == "h" and ATTACK == false and BanishMode ~= "silent" and BanishMode ~= 1444 then
		SONG1 = 836718931
		sick.TimePosition = 4
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","why can't you just chill out?")
		Speed = 27
		BanishMode = "silent"
		Jump = 50
		ChangeName("丂 I ʟ 乇 几 ㄒ ULTRA SKIDDED CHILL")
		coroutine.resume(coroutine.create(function()
		end))
		repeat wait()
			if sick.TimePosition <= 3.9 then
				sick.TimePosition = 4
			end
		until BanishMode ~= "silent"
	end

	if Key == "m" and ATTACK == false and BanishMode == "silent" and BanishMode ~= 1555 and BanishMode ~= 1444 then
		SONG1 = 2162230624
		BanishMode = 1444
		Speed = 0
		Jump = 0
		wait(1)
		chatfunc("K I L L E R")
		Notify("ULTRA SKIDDED CHILL /  ","K I L L E R")
		wait(0.5)
		warnedpeople("...")
		ChangeName("ULTRA SKIDDED CHILL /  乃 卂 ᴅ ʙ 0 ɪ")
		SONG1 = 1696854181
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Speed = 27
		Jump = 150
		BanishMode = 1555
	end
	if Key == "n" and ATTACK == false and BanishMode == "silent" and BanishMode ~= 7895 and BanishMode ~= 1444 then
		ChangeName("ULTRA SKIDDED CHILL /  A N C I E N T")
		SONG1 = 256251217
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		chatfunc("I  A M  E T E R N A L")
		Notify("ULTRA SKIDDED CHILL /  ","I  A M  E T E R N A L")
		Speed = 50
		Jump = 100
		BanishMode = 7895
		disably = false
		warnedpeople3("A N C I E N T","Arcade",Color3.new(1,1,1),Color3.new(1,1,1))
		disably = true
	end

	if Key == "b" and ATTACK == false and BanishMode == "silent" and BanishMode ~= 4321 and BanishMode ~= 1444 then
		ChangeName("ULTRA SKIDDED CHILL /  G 0 0 ᴅ ʙ 0 ɪ")
		SONG1 = 1539245059
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		chatfunc("I Might Be Good, But I'm Not Nice...")
		Notify("ULTRA SKIDDED CHILL /  ","I Might Be Good, But I'm Not Nice...")
		Speed = 30
		Jump = 100
		BanishMode = 4321
		disably = false
		warnedpeople3("G 0 0 ᴅ ʙ 0 ɪ","Arcade",Color3.new(1,1,1),Color3.new(1,1,1))
		disably = true
		print("ULTRA SKIDDED CHILL / :BAD!!!!! UR BAD!!!! BADD!!!!!1 EVILLLL!!!!!!!!!")
	end

	if Key == "m" and ATTACK == false and BanishMode == 5 and BanishMode ~= 555 and BanishMode ~= 1444 then
		SONG1 = 4835535512
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","ł ₩₳₦₮ ฿ⱠØØĐ")
		BanishMode = 555
		Speed = 45
		Jump = 100
		ChangeName("ULTRA SKIDDED CHILL /  ฿ⱠØØĐ")
	end
	if Key == "n" and ATTACK == false and BanishMode == 3 and BanishMode ~= 999 and BanishMode ~= 1444 then
		SONG1 = 2415462372
		sick.TimePosition = 0
		sick.Volume = 100
		sick.Pitch = 0.8
		Notify("ULTRA SKIDDED CHILL /  ","HAHA!")
		chatfunc("HAHA!")
		Speed = 50
		BanishMode = 999
		Jump = 100
		ChangeName("ULTRA SKIDDED CHILL /  Idols")
		disably = false
		warnedpeople3("Let's Get This Party Rollin'!","Arcade",Color3.new(1,1,1),Color3.new(1,1,1))
		disably = true
	end

	if Key == "1" and ATTACK == false and BanishMode ~= 777 and BanishMode ~= 1444 then
		SONG1 = 644312180
		Speed = 0
		Jump = 0
		BanishMode = nil
		game.Lighting.FogColor = Color3.fromRGB(0,0,0)
		game.Lighting.FogEnd = 0
		game.Lighting.TimeOfDay = 0
		warnedpeople("Its not a beautiful day outside...")
		wait(3.5)
		warnedpeople("Fish are dying...")
		wait(1.5)
		warnedpeople("Sadly...")
		wait(1.5)
		warnedpeople("on days like this...")
		wait(1.5)
		warnedpeople("Kids like you...")
		wait(2.7)
		SONG1 = 0
		hasarrivedB("SHOULD BECOME FISH.")
		wait(5)
		game.Lighting.FogEnd = 100000
		game.Lighting.TimeOfDay = 14
		SONG1 = 4751534938
		sick.Volume = 100
		sick.Pitch = 0.8
		BanishMode = 777
		Speed = 25
		Jump = 75
		ChangeName("ULTRA SKIDDED CHILL /  Fishy™")
	end

	if Key == "m" and BanishMode == 999999 and ATTACK == false then
		AzureX()
	end

	if Key == "-" and ATTACK == false then
		Rush()
	end
end

function KeyUp(Key)
	KEYHOLD = false
end
Mouse.KeyDown:connect(function(NEWKEY)
	KeyDown(NEWKEY)
end)
Mouse.KeyUp:connect(function(NEWKEY)
	KeyUp(NEWKEY)
end)

--//=================================\\
--\\=================================//

function unanchor()
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c ~= RootPart then
			c.Anchored = false
		end
	end
	if UNANCHOR == true then
		RootPart.Anchored = false
	else
		RootPart.Anchored = true
	end
end

function FixLighting()
	game.Lighting.Ambient = Color3.fromRGB(255, 255, 255)
	game.Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
	game.Lighting.FogColor = Color3.fromRGB(255, 255, 255)
	game.Lighting.TimeOfDay = "14:00:00"
	game.Lighting.ExposureCompensation = 0
	game.Lighting.FogEnd = 100000
	game.Lighting.Brightness = 2
	workspace.CurrentCamera.FieldOfView = 70 - sick.PlaybackLoudness/25
end

local VISUALS = game.Lighting
local VISUALSSz = game.Lighting
wait(0.1)
coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		if Idk == true then
			VISUALS.FogColor = Torso.Color
			VISUALS.Ambient = Torso.Color
			VISUALS.OutdoorAmbient = Torso.Color
			VISUALS.TimeOfDay = 0
			VISUALSSz.ExposureCompensation = 0 + sick.PlaybackLoudness/125
			VISUALSSz.FogEnd = sick.PlaybackLoudness
			VISUALSSz.Brightness = 0
			VISUALS.EnvironmentDiffuseScale = 0 + sick.PlaybackLoudness/100
			workspace.CurrentCamera.FieldOfView = 70 - sick.PlaybackLoudness/25
		else
			FixLighting()
		end
	end
end))

--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//


--//=================================\\
--||          Compatibility
--\\=================================//

local sine = SINE
local Sine = SINE
local angles = ANGLES
local RH = RightHip
local LH = LeftHip
local LW = LeftShoulder
local RW = RightShoulder
local head = Head
local RootCF = ROOTC0
local necko = NECKC0
local NK = Neck
local RJ = RootJoint
local LS = LeftShoulder
local RS = RightShoulder
local clerp = Clerp
local LSC0 = LS.C0
local RSC0 = RS.C0
local NKC0 = NK.C0
local LHC0 = LH.C0
local RHC0 = RH.C0
local RJC0 = RJ.C0
local CFA = CFrame.Angles
local CFN = CFrame.new

--//=================================\\
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

local blockedguis = {"vbucks","sup","AllahGui","SnakeVenomSS","polishtoilet","nooties","IY_GUI","IY_JumpScare","Dex","BugGui"}
function checkgui(v) 
	if v:IsA("ScreenGui") then
		for i = 1,#blockedguis do
			if v.Name == blockedguis[i] then
				v.Enabled = false
				game:GetService("Debris"):AddItem(v,.01)
				chatfunc("Removed abusive GUI named \""..blockedguis[i].."\"")
			end
		end
	elseif v:IsA("LocalScript") and (string.sub(v.Name,string.len(v.Name)-15) == "'s Sound Stopper" or v.Name == "HiddenScript" or v.Name == "KCCharacter") then
		v.Disabled = true
		if v:FindFirstChild("Char") and v.Char:IsA("ObjectValue") then
			v.Char.Value = eeeblock
			if v.Name == "KCCharacter" then
				v.Char.Value = Character
			end
			v.Disabled = false
		end
	end
end
for i,v in pairs(lplr:FindFirstChildOfClass("PlayerGui"):GetChildren()) do
	checkgui(v)
end
lplr:FindFirstChildOfClass("PlayerGui").ChildAdded:Connect(function(v)
	if stopeverything then wait(math.huge) end
	checkgui(v)
end)

local ActualVelocity = Vector3.new(0,0,0)
if lplr == Player then
	spawn(function()
		while true do
			local Positions = {}
			local Speeds = {}
			for i = 1,10 do
				table.insert(Positions, RootPart.CFrame)
				table.insert(Speeds, RootPart.Velocity)
				script.ArtificialHB2.Event:wait()
			end
		end
	end)
	spawn(function()
		while true do
			game:GetService("RunService").RenderStepped:wait()
		end
	end)


end

if lplr ~= Player then
	local Last = RootPart.Position
	Movement.OnClientEvent:Connect(function(v, Speed)
		for i,v2 in pairs(v) do
			ActualVelocity = Speed[i]
			if v[i].p ~= Last then
				if MoveType.Value == "Remote" then
					RootPart.CFrame = v[i]
				end
				Last = v[i].p
				script.ArtificialHB2.Event:wait()
			end
		end
	end)
	spawn(function()
		while true do
			game:GetService("RunService").RenderStepped:wait()
			RealRoot = workspace.Terrain:WaitForChild(Player.Name.." tracker")
			if MoveType.Value == "Smooth" then
				RootPart.CFrame = RealRoot.CFrame
			end
		end
	end)
end

coroutine.resume(coroutine.create(function()
	wait()
	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "ULTRA SKIDDED CHILL";
		Text = "Made by WaryRGMCA <3;";
		Duration = 9999999999999999;
	})
end))

coroutine.resume(coroutine.create(function()
	wait()
	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "ULTRA SKIDDED CHILL";
		Text = "Converted by Deeri";
		Duration = 9999999999999999;
	})
end))

coroutine.resume(coroutine.create(function()
	wait()
	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "<3";
		Text = "ULTRA SKIDDED CHILL, By WaryRGMCA.";
		Duration = 15;
		Button1 = "E";
	})
end))

coroutine.resume(coroutine.create(function()
	ChangeName("ULTRA SKIDDED CHILL")
end))

local clerp = Clerp

while true do
	Swait()
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
		v:Stop();
	end
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (ActualVelocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = ActualVelocity.y
	RWingWld.C0 = Clerp(RWingWld.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(SINE/25)),0),.25)
	LWingWld.C0 = Clerp(LWingWld.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(SINE/25)),0),.25)
	if lplr == Player then
		TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		TORSOVERTICALVELOCITY = RootPart.Velocity.y
	end
	Player_Size = 1
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		motor1.C0 = clerp(motor1.C0, CFrame.new(2.36, -1.8, -0.87) * angles(math.rad(-60 + 0 * math.cos(sine / 10)), math.rad(-90 + 0 * math.cos(sine / 10)), math.rad(80 + 0 * math.cos(sine / 25))), 0.1)
		motor2.C0 = clerp(motor2.C0, CFrame.new(-2.36, -1.8, -0.87) * angles(math.rad(-60 + 0 * math.cos(sine / 10)), math.rad(90 + 0 * math.cos(sine / 10)), math.rad(-80 + 0 * math.cos(sine / 25))), 0.1)
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 * Player_Size, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		motor1.C0 = clerp(motor1.C0, CFrame.new(2.36, -1.8, -0.87) * angles(math.rad(-45 + 0 * math.cos(sine / 10)), math.rad(0 + 0 * math.cos(sine / 10)), math.rad(70 + 0 * math.cos(sine / 25))), 0.1)
		motor2.C0 = clerp(motor2.C0, CFrame.new(-2.36, -1.8, -0.87) * angles(math.rad(-45 + 0 * math.cos(sine / 10)), math.rad(0 + 0 * math.cos(sine / 10)), math.rad(-70 + 0 * math.cos(sine / 25))), 0.1)    
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		motor1.C0 = clerp(motor1.C0, CFrame.new(2.36, -1.8, -0.87) * angles(math.rad(-5 + 5 * math.cos(sine / 50)), math.rad(0 + 5 * math.cos(sine / 80)), math.rad(0 + 0 * math.cos(sine / 25))), 0.1)
		motor2.C0 = clerp(motor2.C0, CFrame.new(-2.36, -1.8, -0.87) * angles(math.rad(-5 + -5 * math.cos(sine / 70)), math.rad(0 + -5 * math.cos(sine / 50)), math.rad(0 + 0 * math.cos(sine / 25))), 0.1)
		if ATTACK == false and BanishMode == "chxll" then
			WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.01,0.015,0.01)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(math.random(-5,5)),RAD(math.random(-360,360)),RAD(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			bouncyboi = sick.PlaybackLoudness / 1000
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 2 + 0.5 * COS(SINE / 12) + bouncyboi) * ANGLES(RAD(-60 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 1 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.50 + 0.05 * COS(SINE / 99), 0.4) * ANGLES(RAD(-43), RAD(0 - 2.5 * SIN(SINE / 99)), RAD(-45 + 7.5 * SIN(SINE / 99))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.50 + 0.05 * COS(SINE / 99), 0.4) * ANGLES(RAD(-43), RAD(0 + 2.5 * SIN(SINE / 99)), RAD(45 - 7.5 * SIN(SINE / 99))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.15 * COS(SINE / 12) - bouncyboi, -0.05) * ANGLES(RAD(35 - 7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / 12) - bouncyboi, -0.05) * ANGLES(RAD(35 - 7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 5 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.15 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 - 0.1 * COS(SINE / 12) + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(10 * COS(SINE / 12)), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.5 - 0.15 * COS(SINE / 12), -0.4) * ANGLES(RAD(50 - 10.5 * SIN(SINE / 12)), RAD(0 - 3.5 * SIN(SINE / 12)), RAD(-36)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 - 0.15 * COS(SINE / 12), 0) * ANGLES(RAD(180 - 3.5 * SIN(SINE / 12)), RAD(0 - 8.5 * SIN(SINE / 12)), RAD(20 + 8.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.15 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.15 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 4321 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.03 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 1 / 5)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(35)), 1 / 5)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75, 0.5 + 0.05 * SIN(SINE / 12), -0.7) * ANGLES(RAD(0), RAD(0), RAD(-95)) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / 5)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.75, 0.35 + 0.05 * SIN(SINE / 12), -0.6) * ANGLES(RAD(0), RAD(0), RAD(92)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / 5)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(95), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / 5)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / 5)
		elseif ATTACK == false and BanishMode == 60 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(5), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20), RAD(-10 - 2.5 * SIN(SINE / 10)), RAD(20 * COS(SINE / 10))), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 64 then
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(7 + 6.5 * SIN(SINE / 24)), RAD(10*SIN(SINE/24)), RAD(6*SIN(SINE/24))), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.5,0) * ANGLES(RAD(120 + 6.5 * SIN(SINE / 34)), RAD(5*SIN(SINE/34)), RAD(10 * SIN(SINE / 34))) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1.5 + 0.5 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.4 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(1), RAD(0), RAD(22)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0,CF(1,-0.4,-0.5)*ANGLES(RAD(0 + 6.5 * SIN(SINE/12)),RAD(90),RAD(40*SIN(SINE/34)))*ANGLES(RAD(-3),RAD(0 - 1 * COS(SINE / 36)),RAD(-10 - 2 * COS(SINE / 39))),0.2)
			LeftHip.C0 = Clerp(LeftHip.C0,CF(-1,-1,0)*ANGLES(RAD(10 + 4.6 * SIN(SINE/12)),RAD(-90),RAD(20*SIN(SINE/34)))*ANGLES(RAD(-3),RAD(0 - 1 * COS(SINE / 36)),RAD(10 + 6 * COS(SINE / 31))),0.2)
		elseif ATTACK == false and BanishMode == 963 then
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(7 + 6.5 * SIN(SINE / 24)), RAD(10*SIN(SINE/24)), RAD(6*SIN(SINE/24))), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.5,0) * ANGLES(RAD(120 + 6.5 * SIN(SINE / 34)), RAD(5*SIN(SINE/34)), RAD(10 * SIN(SINE / 34))) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1.5 + 0.5 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.4 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(1), RAD(0), RAD(22)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0,CF(1,-0.4,-0.5)*ANGLES(RAD(0 + 6.5 * SIN(SINE/12)),RAD(90),RAD(40*SIN(SINE/34)))*ANGLES(RAD(-3),RAD(0 - 1 * COS(SINE / 36)),RAD(-10 - 2 * COS(SINE / 39))),0.2)
			LeftHip.C0 = Clerp(LeftHip.C0,CF(-1,-1,0)*ANGLES(RAD(10 + 4.6 * SIN(SINE/12)),RAD(-90),RAD(20*SIN(SINE/34)))*ANGLES(RAD(-3),RAD(0 - 1 * COS(SINE / 36)),RAD(10 + 6 * COS(SINE / 31))),0.2)
		elseif ATTACK == false and BanishMode == 61 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,0+.1*COS(SINE / 18))*ANGLES(RAD(0+1*COS(SINE / 18)),RAD(0),RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(SINE / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(40+sick.PlaybackLoudness/7.5), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.1*COS(SINE / 18), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.-sick.PlaybackLoudness/1000, -0.6) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 20 then
			bouncyboi = sick.PlaybackLoudness / 1000
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 6 + 2 * COS(SINE / 36) + bouncyboi) * ANGLES(RAD(-70), RAD(0), RAD(0)), 0.05 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.45, 0.4) * ANGLES(RAD(-70), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.05 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.45, 0.45, 0.4) * ANGLES(RAD(-70), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.05 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.05 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.05 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 876 then
			if(math.random(1,4)==1)then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			end	
			if math.random(1,25) == 1 then
				Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1.5/Animation_Speed)
			end	
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0+MRANDOM(-5,5)), RAD(0+MRANDOM(-5,5)), RAD(0+MRANDOM(-5,5))), 0.35 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MRANDOM(-25,25)), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-20)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
			if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
			end
			if(math.random(1,2)==1)then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			end
		elseif ATTACK == false and BanishMode == 1245 then
			RightHip.C0=Clerp(RightHip.C0,CF(1,-1 + 0.05 * math.cos(SINE / 20)  - 0.02 * math.cos(SINE / 40),0)*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(-3 + 2 * math.cos(SINE / 40)),math.rad(-15),math.rad(0 + 2 * math.cos(SINE / 20))),.1)
			LeftHip.C0=Clerp(LeftHip.C0,CF(-1,-1 + 0.05 * math.cos(SINE / 20) - 0.02 * math.cos(SINE / 40),0)*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(-3 - 2 * math.cos(SINE / 40)),math.rad(1),math.rad(0 - 2 * math.cos(SINE / 20))),.1)
			RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*CF(0 + 0.02 * math.cos(SINE / 40),0 - 0.02 * math.cos(SINE / 40),-0.05 - 0.05 * math.cos(SINE / 20))*ANGLES(math.rad(0 + 2 * math.cos(SINE / 20)),math.rad(0 + 2 * math.cos(SINE / 40)),math.rad(30 + 3 * math.cos(SINE / 40))),.1)
			Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*ANGLES(math.rad(2),math.rad(0 - 7 * math.cos(SINE / 40)),math.rad(-30 - 3 * math.cos(SINE / 40))),.1)
			RightShoulder.C0=Clerp(RightShoulder.C0,CF(1,0.5 + 0.05 * math.cos(SINE / 28),0.1)*ANGLES(math.rad(-6 + 5 * math.cos(SINE / 26)),math.rad(-10 - 6 * math.cos(SINE / 24)),math.rad(13 - 5 * math.cos(SINE / 34)))*ANGLES(RAD(0),RAD(90),RAD(0)),.1)
			LeftShoulder.C0=Clerp(LeftShoulder.C0,CF(-1,0.5 + 0.05 * math.cos(SINE / 28),0.1)*ANGLES(math.rad(-13 - 1 * math.cos(SINE / 25)),math.rad(10 + 2 * math.cos(SINE / 24)),math.rad(10 + 2 * math.cos(SINE / 34)))*ANGLES(RAD(0),RAD(-90),RAD(0)),.1)
		elseif ATTACK == false and BanishMode == 30 then
			local loudness = sick.PlaybackLoudness
			WACKYEFFECT({Time = 25, EffectType = "Crystal", Size = VT(0,0,0), Size2 = VT(7+sick.PlaybackLoudness/5,0.55,7+sick.PlaybackLoudness/5), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MRANDOM(-25,25)), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MRANDOM(-25,25)), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 33 then
			WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.01,0.015,0.01)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(math.random(-5,5)),RAD(math.random(-360,360)),RAD(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(-2.5 * COS(SINE / 12)), RAD(-25)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75, 0.5 + 0.05 * SIN(SINE / 12), -1) * ANGLES(RAD(1.5 - 1.5 * SIN(SINE / 12)), RAD(0), RAD(-95)) * ANGLES(RAD(-5), RAD(-90 + 2.5 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.75, 0.35 + 0.05 * SIN(SINE / 12),-0.9) * ANGLES(RAD(1.5 - 1.5 * SIN(SINE / 12)), RAD(0), RAD(92)) * ANGLES(RAD(0), RAD(90 - 2.5 * COS(SINE / 12)), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(65), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-100), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1234 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(25 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-25 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.15 + 0.25 * COS(SINE / 12), -0.3) * ANGLES(RAD(140), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0.4) * ANGLES(RAD(-5), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-15 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 444 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * COS(SINE / 12)) * ANGLES(RAD(5 * COS(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(7 * COS(SINE / 12)), RAD(0)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 - 0.1 * COS(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(0), RAD(-100)) * ANGLES(RAD(20), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.3 - 0.1 * COS(SINE / 12), -0.35) *  ANGLES(RAD(0), RAD(0), RAD(70)) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * COS(SINE / 12), -0.01) * ANGLES(RAD(7 * COS(SINE / 12)), RAD(85), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * COS(SINE / 12), -0.01) * ANGLES(RAD(7 * COS(SINE / 12)), RAD(-85), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 445 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, 0.5) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			--LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 15 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 446 then
			if MRANDOM(1,20) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-90,90) - 4 * COS(SINE / 12)), RAD(MRANDOM(-90,90)), RAD(0)), 1.5 / Animation_Speed)
			end			
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.1, -0.1 + 0.05 * SIN(SINE / 12)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20 - 2.5 * SIN(SINE / 12)), RAD(7 * COS(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(20), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.3 + 0.05 * SIN(SINE / 12), -0.35) * ANGLES(RAD(20), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(20), RAD(-90), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1222 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.1, 1 + 0.5 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(2.5), RAD(0), RAD(21 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed) 
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(100 + 2 * COS(SINE / 12)), RAD(0), RAD(15 + 3 * COS(SINE / 12) - 3 * SIN(SINE / 12))) *               ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(-3.5), RAD(-25 + 5 * COS(SINE / 12))) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(-20 + 1 * COS(SINE / 18)), RAD(0), RAD(-80)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.7) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(-35 + 1 * COS(SINE / 18)), RAD(0), RAD(80)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 3 then
			snap = math.random(1,32)
			if snap == 1 then
				Neck.C0 = Clerp(Neck.C0,NECKC0*cf(0,0,0+((1)-1))*angles(math.rad(math.random(-12093487,10000)),math.rad(math.random(-200,10000)),math.rad(math.random(-999999999,10000))),1/Animation_Speed)
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.3 * COS(SINE / 2)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, 0.5) * ANGLES(RAD(-20), RAD(-.6), RAD(-43)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, 0.5) * ANGLES(RAD(-20), RAD(-.6), RAD(43)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.3 * COS(SINE / 2),-0.01) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.3 * COS(SINE / 2),-0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1111 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,2+0.5*COS(SINE / 7))*ANGLES(RAD(0+2*COS(SINE / 12)),RAD(0),RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(SINE / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(.75, 0.5, -0.8) * ANGLES(RAD(0), RAD(0), RAD(-85)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, -0.7) * ANGLES(RAD(0), RAD(0), RAD(95)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.001*COS(SINE / 7), -0.01) * ANGLES(RAD(-10-2.5*math.cos(sine/12)), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.001*math.cos(sine/7), -0.5) * ANGLES(RAD(-25-2.5*math.cos(sine/12)), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 5555 then
			snap = math.random(1,6)
			if snap == 1 then
				Neck.C0 = Clerp(Neck.C0,NECKC0*cf(0,0,0+((1)-1))*angles(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1/Animation_Speed)
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,2+.5*COS(SINE / 32))*ANGLES(RAD(-25 + 2*Cos(sine/42)),RAD(0),RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-2.5+1*COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(0)), 1 / Animation_Speed) 
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(15 - 5.5 * COS(SINE / 20))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-30), RAD(0), RAD(-15 + 5.5 * COS(SINE / 20))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.2) * ANGLES(RAD(-30+2*Cos(sine/32)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.2) * ANGLES(RAD(-30+2*Cos(sine/46)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == "tale" then
			RightHip.C0=Clerp(RightHip.C0,cf(1,-1 - 0.1 * math.cos(SINE / 32),0)*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(-10 - 2.5 * math.cos(SINE / 32)),math.rad(-20),math.rad(0)),.1)
			LeftHip.C0=Clerp(LeftHip.C0,cf(-1,-1 - 0.1 * math.cos(SINE / 32),0)*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(0),math.rad(0),math.rad(-10 + 2.5 * math.cos(SINE / 32))),.1)
			RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*cf(0,0,0 + 0.1 * math.cos(SINE / 32))*ANGLES(math.rad(10 - 2 * math.cos(SINE / 32)),math.rad(0),math.rad(20)),.1)
			Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*ANGLES(math.rad(55),math.rad(0),math.rad(0)),.1)
			RightShoulder.C0=Clerp(RightShoulder.C0,cf(0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(SINE / 28))),.1)
			LeftShoulder.C0=Clerp(LeftShoulder.C0,cf(-0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(SINE / 28))),.1)
		elseif ATTACK == false and BanishMode == 3333 then
			bouncyboi = sick.PlaybackLoudness / 1200
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 2 + 0.5 * COS(SINE / 12) + bouncyboi) * ANGLES(RAD(-60 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 1 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.50 + 0.05 * COS(SINE / 99), 0.4) * ANGLES(RAD(-43), RAD(0 - 2.5 * SIN(SINE / 99)), RAD(-45 + 7.5 * SIN(SINE / 99))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.50 + 0.05 * COS(SINE / 99), 0.4) * ANGLES(RAD(-43), RAD(0 + 2.5 * SIN(SINE / 99)), RAD(45 - 7.5 * SIN(SINE / 99))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.15 * COS(SINE / 12) - bouncyboi, -0.05) * ANGLES(RAD(35 - 7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / 12) - bouncyboi, -0.05) * ANGLES(RAD(35 - 7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 564 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , -0.7) * ANGLES(RAD(MRANDOM(-15,15)), RAD(MRANDOM(-15,15)), RAD(MRANDOM(-15,15))), 0.35 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15))), 0.35 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(160+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15)), RAD(-30+MRANDOM(-15,15)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(160+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15)), RAD(30+MRANDOM(-15,15))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(-60), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 987 then
			local bouncyboi = sick.PlaybackLoudness / 1200
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.1 + 0.05 * COS(SINE / 12) + bouncyboi) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5 + sick.PlaybackLoudness / 1200, -0.3) * ANGLES(RAD(-200), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(5), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / Animation_Speed)
			if MRANDOM(1, 10) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
			end
		elseif ATTACK == false and BanishMode == "silent" then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.5 * COS(SINE / 12)) * ANGLES(RAD(-25 - 3 * SIN(SINE / 12)), RAD(0), RAD(-25)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(23 - 3 * SIN(SINE / 12)), RAD(0), RAD(30)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(70), RAD(0), RAD(-70)) * ANGLES(RAD(20), RAD(25), RAD(-15)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1*SIZE, 0.2*SIZE, -0.5*SIZE) * ANGLES(RAD(25), RAD(0), RAD(85)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.5*SIZE - 0.05*SIZE * COS(SINE / 12), -0.5*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -0.8*SIZE - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 666 then
			if VALUE1 == false and math.random(1,55) == 1 then
				coroutine.resume(coroutine.create(function()
					VALUE1 = true
					wait(2)
					CreateSound(749189256,RootPart,2,math.random(5, 15) / 10,false)
					for i=1,25 do
						Swait()
						FT.Parent = Torso
						FRA.Parent = RightArm
						FLA.Parent = LeftArm
						FRL.Parent = RightLeg
						FLL.Parent = LeftLeg
						for _,v in next, Character:GetDescendants() do
							if(v:IsA'DataModelMesh')then
								v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
							end
						end		
					end
					VALUE1 = false
					FT.Parent = nil
					FRA.Parent = nil
					FLA.Parent = nil
					FRL.Parent = nil
					FLL.Parent = nil
					for _,v in next, Character:GetDescendants() do
						if(v:IsA'DataModelMesh')then
							v.Offset = VT(0,0,0)
						end
					end	
				end))
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0+.15*SIN(sine/32)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(40), RAD(-10), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(10+5*SIN(sine/24))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-10-5*SIN(sine/24))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.15*SIN(sine/32), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1-.15*SIN(sine/32), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8+2.5*SIN(sine/32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			snap = math.random(1,72)
			if snap == 1 then	
				CreateSound(363808674,Head,3,1.3,false)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-sick.PlaybackLoudness/7,100000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-99999-sick.PlaybackLoudness/7,99999+sick.PlaybackLoudness/7)), RAD(MRANDOM(-200-sick.PlaybackLoudness/7,48375935+sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
			end
		elseif ATTACK == false and BanishMode == 7834 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(30), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(30), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(30), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(160, 200)), RAD(0), RAD(-MRANDOM(5, 45))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(160, 200)), RAD(0), RAD(MRANDOM(5, 45))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 777777 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 1 * SIN(SINE / 26)) * ANGLES(RAD(-5 - 2.5*SIN(SINE/48/2)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(140 + 5 * COS(SINE /32)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.8 / 5)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MRANDOM(-25,25)), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 7777778 then
			if MRANDOM(1,10) == 1 then
				Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
			end
			if math.random(1,8) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
			end
			if(math.random(1,4)==1)then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			end	
			if MRANDOM(1,10) == 1 then
				Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
			end
			RightHip.C0=Clerp(RightHip.C0,cf(1,-1 - 0.1 * COS(sine / 32),0)*angles(RAD(0),RAD(90),RAD(0))*angles(RAD(-3),RAD(-5.5 - 2 * COS(sine / 56)),RAD(-12 - 2 * COS(sine / 32))),.1)
			LeftHip.C0=Clerp(LeftHip.C0,cf(-1,-1 - 0.1 * COS(sine / 32),0)*angles(RAD(0),RAD(-90),RAD(0))*angles(RAD(-6),RAD(22 - 2 * COS(sine / 56)),RAD(-1 + 2 * COS(sine / 32))),.1)
			RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*cf(0,0.01 + 0.03 * COS(sine / 32),0 + 0.1 * COS(sine / 32))*angles(RAD(1 - 2 * COS(sine / 32)),RAD(0),RAD(-22 + 2 * COS(sine / 56))),.1)
			Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 - 2 * COS(sine / 37)),RAD(0 + 5 * COS(sine / 43) - 5 * COS(sine / 0.25)),RAD(22 - 2 * COS(sine / 56))),.1)
			RightShoulder.C0=Clerp(RightShoulder.C0,cf(1.5,0.5 + 0.025 * COS(sine / 45),0)*angles(RAD(5 + 3 * COS(sine / 43)),RAD(-16 - 5 * COS(sine / 52)),RAD(13 + 9 * COS(sine / 45))),.1)
			LeftShoulder.C0=Clerp(LeftShoulder.C0,cf(-1.35,1 + 0.025 * COS(sine / 45),-0.2)*angles(RAD(148 - 2 * COS(sine / 51)),RAD(0 - 4 * COS(sine / 64)),RAD(22 - 2 * COS(sine / 45))),.1)
			snap = math.random(1,72)
			if snap == 1 then
				CreateSound(406913243,Head,3,1.3,false)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-sick.PlaybackLoudness/7,100000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-99999-sick.PlaybackLoudness/7,99999+sick.PlaybackLoudness/7)), RAD(MRANDOM(-200-sick.PlaybackLoudness/7,48375935+sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
			end
			if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
			end
		elseif ATTACK == false and BanishMode == 999999 then
			snap = math.random(1,6)
			if snap == 1 then
				Neck.C0 = Clerp(Neck.C0,NECKC0*cf(0,0,0+((1)-1))*angles(math.rad(math.random(-1000,1000)),math.rad(math.random(-1000,100)),math.rad(math.random(-1000,1000))),1/Animation_Speed)
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(0), RAD(-25), RAD(25 + 8 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.5 + 0.1 * COS(SINE / 12), 0.2) * ANGLES(RAD(0), RAD(25), RAD(-25 - 8 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.65 - 0.2 * COS(SINE / 12), -0.35) * ANGLES(RAD(-25 + 6 * COS(SINE / 12)), RAD(80), RAD(0)) * ANGLES(RAD(2 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(-5 + 2 * COS(SINE / 12)), RAD(-80), RAD(0)) * ANGLES(RAD(2 * COS(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 100000 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,5+0.6*COS(SINE / 60))*ANGLES(RAD(0+5*COS(SINE / 26)),RAD(0),RAD(0)), 1 / 10)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(SINE / 32)), RAD(0), RAD(10)), 1 / 10) 
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(.75, 0.5, -0.8) * ANGLES(RAD(0), RAD(0), RAD(-85)) * RIGHTSHOULDERC0, 1 / 10)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, -0.7) * ANGLES(RAD(0), RAD(0), RAD(95)) * LEFTSHOULDERC0, 1 / 10)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.001*COS(SINE / 7), -0.01) * ANGLES(RAD(-10-2.5*COS(sine/12)), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 10)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.001*COS(sine/7), -0.5) * ANGLES(RAD(-25-2.5*COS(sine/12)), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 10)
		elseif ATTACK == false and BanishMode == 888888 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 + .5 * COS(SINE/50),0,3 - .5 * COS(SINE/100)) * ANGLES(math.rad(0),math.rad(0),math.rad(0)),0.7/Animation_Speed)
			Neck.C0 = Clerp(Neck.C0,NECKC0 * CF(0,0 ,0 + ((1) - 1)) * ANGLES(math.rad(20),math.rad(0),math.rad(0)),0.7/Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5,0.5,0) * ANGLES(math.rad(135 + 8.5 * COS(SINE/49)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CF(-1.5,0.5,0) * ANGLES(math.rad(25 + 8.5 * COS(SINE/49)),math.rad(0),math.rad(-25 - 5 * COS(SINE/19))) * LEFTSHOULDERC0,0.7/Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0,CF(1,-0.5,-0.5) * ANGLES(math.rad(-15 + 9 * COS(SINE/74)),math.rad(80),math.rad(0)) * ANGLES(math.rad(0 + 5 * COS(SINE/37)),math.rad(0),math.rad(0)),0.7/Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0,CF(-1,-1,0) * ANGLES(math.rad(-15 - 9 * COS(SINE/54)),math.rad(-80),math.rad(0)) * ANGLES(math.rad(0 - 5 * COS(SINE/41)),math.rad(0),math.rad(0)),0.7/Animation_Speed)
		elseif ATTACK == false and BanishMode == 1666 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(-0.5*COS(SINE / 40),0,3-2*COS(SINE / 40))*ANGLES(RAD(-70 + 20 *COS(SINE / 40)),RAD(0),RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 25*COS(SINE / 40)), RAD(0), RAD(21 + 2.5 * SIN(SINE / 40))), 1 / Animation_Speed) 
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(0), RAD(-100)) * ANGLES(RAD(20), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.3 + 0.05 * SIN(SINE / 12), -0.35) * ANGLES(RAD(0), RAD(0), RAD(70)) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-20+40*COS(SINE / 40)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(-10+40*COS(SINE / 40)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1667 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 1 * SIN(sine / 26)) * ANGLES(RAD(-10 - 2.5*SIN(sine/24)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12*5)), RAD(0), RAD(0+2.5*SIN(SINE/12))), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(120 - 13*SIN(sine/12)), RAD(0), RAD(12 - 4.10 * SIN(sine / 12*3))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40 - 13*SIN(sine/52)), RAD(0), RAD(-12 + 4.10 * SIN(sine / 31))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-20 - 2.5 * SIN(sine / 12*2)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-40 - 2.5 * SIN(sine / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1668 then
			local snap = math.random(1,10)
			if snap == 1 then
				Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 + math.random(-5,5)),math.rad(math.random(-5,5)),math.rad(22 + math.random(-5,5))),1)
			end
			RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5 - 2 * math.cos(sine / 56)),math.rad(-12 - 2 * math.cos(sine / 32))),.1)
			LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(22 - 2 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
			RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.01 + 0.03 * math.cos(sine / 32),0 + 0.1 * math.cos(sine / 32))*angles(math.rad(1 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-22 + 2 * math.cos(sine / 56))),.1)
			Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(23 - 2 * math.cos(sine / 37)),math.rad(0 + 5 * math.cos(sine / 43) - 5 * math.cos(sine / 0.25)),math.rad(22 - 2 * math.cos(sine / 56))),.1)
			RW.C0=clerp(RW.C0,cf(1,0.35 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
			LW.C0=clerp(LW.C0,cf(-1.35,1 + 0.025 * math.cos(sine / 45),-0.2)*angles(math.rad(148 - 2 * math.cos(sine / 51)),math.rad(0 - 4 * math.cos(sine / 64)),math.rad(22 - 2 * math.cos(sine / 45))),.1)
		elseif ATTACK == false and BanishMode == 872 then
			if VALUE1 == false and math.random(1,55) == 1 then
				coroutine.resume(coroutine.create(function()
					VALUE1 = true
					wait(2)
					CreateSound(333430981,RootPart,2,math.random(5, 15) / 10,false)
					for i=1,25 do
						Swait()
						FT.Parent = Torso
						FRA.Parent = RightArm
						FLA.Parent = LeftArm
						FRL.Parent = RightLeg
						FLL.Parent = LeftLeg
						for _,v in next, Character:GetDescendants() do
							if(v:IsA'DataModelMesh')then
								v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
							end
						end		
					end
					VALUE1 = false
					FT.Parent = nil
					FRA.Parent = nil
					FLA.Parent = nil
					FRL.Parent = nil
					FLL.Parent = nil
					for _,v in next, Character:GetDescendants() do
						if(v:IsA'DataModelMesh')then
							v.Offset = VT(0,0,0)
						end
					end	
				end))
			end
			if MRANDOM(1,10) == 1 then
				Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
			end
			if math.random(1,8) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
			end
			if(math.random(1,4)==1)then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			end		
			if MRANDOM(1,10) == 1 then
				Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
			end	
			bouncyboi = sick.PlaybackLoudness / 1200
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.1, 1 + 0.5 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)	
			RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5,0.5+.1*COS(SINE/36),-.3)*ANGLES(RAD(44.1),RAD(0),RAD(-25))*RIGHTSHOULDERC0,1/Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -0.9 - 0.1 * COS(SINE / 1), -0.6) * ANGLES(RAD(0), RAD(-10), RAD(0)) * ANGLES(RAD(75), RAD(0), RAD(5)), 0.1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, 0.1 - 0.1 * COS(SINE / 1), -0.6) * ANGLES(RAD(0), RAD(-10), RAD(0)) * ANGLES(RAD(25), RAD(0), RAD(-10)), 0.1 / Animation_Speed)
			if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
			end
		elseif ATTACK == false and BanishMode == 1456 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,0+.1*COS(SINE / 18))*ANGLES(RAD(0+1*COS(SINE / 18)),RAD(0),RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(SINE / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(40+sick.PlaybackLoudness/7.5), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.1*COS(SINE / 18), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.-sick.PlaybackLoudness/1000, -0.6) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1457 then
			local headsnap = math.random(1,60);
			local headsnapping=false;
			if headsnap == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(500,500)), math.rad(math.random(500,500)), math.rad(math.random(500,500))), 1)headsnapping=true headsnapping=false
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 , 0 , 0 - .5 * math.sin(sine/25)) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.8 / 3)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3))), .7 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(20), math.rad(5+2* math.sin(sine/25+math.random(0.25,3))), math.rad(2+5*math.sin(sine / 25))) * RIGHTSHOULDERC0, .7 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(20), math.rad(5+2* math.sin(sine/25+math.random(-0.25,3))), math.rad(-2+5*math.sin(sine / 25))) * LEFTSHOULDERC0, .7 / 3)
			RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-20-4*math.sin(sine/25-math.random(0.25,3))), math.rad(80), math.rad(0)), .7 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(-10-4*math.sin(sine/25-math.random(-0.25,3))), math.rad(-80), math.rad(0)), .7 / 3)
		elseif ATTACK == false and BanishMode == 777 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 1*SIZE, -0.3*SIZE) * ANGLES(RAD(0.98), RAD(-119.59 + 2.5 * SIN(SINE / 25)), RAD(-175.39 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.3*SIZE) * ANGLES(RAD(9.71), RAD(3.14 - -2.5 * SIN(SINE / 12)), RAD(0.2 - -2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1458 then
			RH.C0=Clerp(RH.C0,CF(1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-10 - 2.5 * math.cos(sine / 32)),math.rad(-20),math.rad(0)),.1)
			LH.C0=Clerp(LH.C0,CF(-1,-1 - 0.1 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(-10 + 2.5 * math.cos(sine / 32))),.1)
			RootJoint.C0=Clerp(RootJoint.C0,RootCF*CF(0,0,0 + 0.1 * math.cos(sine / 32))*angles(math.rad(10 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(20)),.1)
			Neck.C0=Clerp(Neck.C0,necko*angles(math.rad(25 - 2.5 * math.cos(sine / 32)),math.rad(0 - 5 * math.cos(sine / 0.25)),math.rad(-20 - 5 * math.cos(sine / 0.465))),.1)
			RW.C0=Clerp(RW.C0,CF(1.5,0.5,0)*angles(math.rad(10),math.rad(-20),math.rad(30 + 2.5 * math.cos(sine / 25))),.1)
			LW.C0=Clerp(LW.C0,CF(-1.5,0.5,0)*angles(math.rad(160),math.rad(0),math.rad(25)),.1)
		elseif ATTACK == false and BanishMode == 1459 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(20 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(30 *COS(SINE/12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(40+sick.PlaybackLoudness/20), math.rad(0), math.rad(10)) * RIGHTSHOULDERC0, 0.5 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 366 then
			if VALUE1 == false and math.random(1,55) == 1 then
				coroutine.resume(coroutine.create(function()
					VALUE1 = true
					wait(2)
					CreateSound(333430981,RootPart,2,math.random(5, 15) / 10,false)
					for i=1,25 do
						Swait()
						FT.Parent = Torso
						FRA.Parent = RightArm
						FLA.Parent = LeftArm
						FRL.Parent = RightLeg
						FLL.Parent = LeftLeg
						for _,v in next, Character:GetDescendants() do
							if(v:IsA'DataModelMesh')then
								v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
							end
						end		
					end
					VALUE1 = false
					FT.Parent = nil
					FRA.Parent = nil
					FLA.Parent = nil
					FRL.Parent = nil
					FLL.Parent = nil
					for _,v in next, Character:GetDescendants() do
						if(v:IsA'DataModelMesh')then
							v.Offset = VT(0,0,0)
						end
					end	
				end))
			end
			if MRANDOM(1,10) == 1 then
				Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
			end
			if math.random(1,8) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
			end		
			if MRANDOM(1,10) == 1 then
				Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MRANDOM(-25,25)), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MRANDOM(-25,25)), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			snap = math.random(1,72)
			if snap == 1 then
				CreateSound(363808674,Head,3,1.3,false)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-sick.PlaybackLoudness/7,100000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-99999-sick.PlaybackLoudness/7,99999+sick.PlaybackLoudness/7)), RAD(MRANDOM(-200-sick.PlaybackLoudness/7,48375935+sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
			end
			if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
			end
		elseif ATTACK == false and BanishMode == 555 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+ 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 15 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
			if MRANDOM(1,32+sick.PlaybackLoudness/7) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-sick.PlaybackLoudness/7,100000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-99999-sick.PlaybackLoudness/7,99999+sick.PlaybackLoudness/7)), RAD(MRANDOM(-200-sick.PlaybackLoudness/7,48375935+sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
			end
			if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
			end
		elseif ATTACK == false and BanishMode == 1444 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.25*SIZE) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0 - 360.45 * COS(SINE / 2))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0.02*SIZE) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0.02*SIZE) * ANGLES(RAD(0), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)					
		elseif ATTACK == false and BanishMode == 1555 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , -0.7) * ANGLES(RAD(MRANDOM(-15,15)), RAD(MRANDOM(-15,15)), RAD(MRANDOM(-15,15))), 0.35 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15))), 0.35 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(160+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15)), RAD(-30+MRANDOM(-15,15)))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(160+MRANDOM(-15,15)), RAD(0+MRANDOM(-15,15)), RAD(30+MRANDOM(-15,15))) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(90), RAD(0)), 0.35 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 , 0) * ANGLES(RAD(-60), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(-90), RAD(0)), 0.35 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 7895 then
			WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			local loudness = sick.PlaybackLoudness
			WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,25,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,15)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Torso.Color, UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})					
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(-0.5*COS(SINE / 40),0,3-2*COS(SINE / 40))*ANGLES(RAD(-70 + 20 *COS(SINE / 40)),RAD(0),RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 25*COS(SINE / 40)), RAD(0), RAD(21 + 2.5 * SIN(SINE / 40))), 1 / Animation_Speed) 
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(0), RAD(-100)) * ANGLES(RAD(20), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.3 + 0.05 * SIN(SINE / 12), -0.35) * ANGLES(RAD(0), RAD(0), RAD(70)) * ANGLES(RAD(20), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-20+40*COS(SINE / 40)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(-10+40*COS(SINE / 40)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 900 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 , 00 + 0.2 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30), RAD(0), RAD(0 + 25 * COS(SINE / 20))), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5+ 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 15 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1- 0.2 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1- 0.2 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 999 then
			WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.01,0.015,0.01)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(math.random(-5,5)),RAD(math.random(-360,360)),RAD(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			sphere2(8, "Add", LeftArm.CFrame * CF(0,-1,0) * ANGLES(RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360,360))),VT(1,1,1), -0.01, 0.05, -0.01,BRICKC("Dark blue"),BRICKC("Dark blue").Color)	
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0* Player_Size, 0* Player_Size, 2 + 0.25* Player_Size * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.1)
			Neck.C0 = Clerp(Neck.C0, NECKC0* CF(0, 0, 0 + ((1* Player_Size) - 1)) * ANGLES(RAD(15 - 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.05)
			RightHip.C0 = Clerp(RightHip.C0, CF(1* Player_Size, -1 - 0.15 * COS(SINE / 20)* Player_Size, -0.1* Player_Size) * ANGLES(RAD(0), RAD(76), RAD(0)) * ANGLES(RAD(-8.5 - 6.5 * SIN(SINE / 12)), RAD(0), RAD(15)), 0.1)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1* Player_Size, -0.6 - 0.15 * COS(SINE / 20)* Player_Size, -0.3* Player_Size) * ANGLES(RAD(0), RAD(-76), RAD(0)) * ANGLES(RAD(-8.5 - 6.5 * SIN(SINE / 12)), RAD(15), RAD(25)), 0.1)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4* Player_Size, 0.4 + 0.08 * SIN(SINE / 12)* Player_Size, 0* Player_Size) * ANGLES(RAD(25 - 6.5 * COS(SINE / 12)), RAD(-.6), RAD(13 + 6.5 * SIN(SINE / 12))), 0.1)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, 0.5) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 865 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(30), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(30), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(30), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(160, 200)), RAD(0), RAD(-MRANDOM(5, 45))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(160, 200)), RAD(0), RAD(MRANDOM(5, 45))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 5986 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,2+0.5*COS(SINE / 7))*ANGLES(RAD(0+2*COS(SINE / 12)),RAD(0),RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(SINE / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(.75, 0.5, -0.8) * ANGLES(RAD(0), RAD(0), RAD(-85)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, -0.7) * ANGLES(RAD(0), RAD(0), RAD(95)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.001*COS(SINE / 7), -0.01) * ANGLES(RAD(-10-2.5*math.cos(sine/12)), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.001*math.cos(sine/7), -0.5) * ANGLES(RAD(-25-2.5*math.cos(sine/12)), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 158 then
			local bouncyboi = sick.PlaybackLoudness / 2200
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 3 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0 * COS(SINE / 12) + bouncyboi) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(40+sick.PlaybackLoudness/9), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(40+sick.PlaybackLoudness/9), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 159 then
			snap = math.random(1,32)
			if snap == 1 then
				Neck.C0 = Clerp(Neck.C0,NECKC0*cf(0,0,0+((1)-1))*angles(math.rad(math.random(-12093487,10000)),math.rad(math.random(-200,10000)),math.rad(math.random(-999999999,10000))),1/Animation_Speed)
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.3 * COS(SINE / 2)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, 0.5) * ANGLES(RAD(-20), RAD(-.6), RAD(-43)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, 0.5) * ANGLES(RAD(-20), RAD(-.6), RAD(43)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.3 * COS(SINE / 2),-0.01) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.3 * COS(SINE / 2),-0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-6), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 782 then
			if VALUE1 == false and math.random(1,55) == 1 then
				coroutine.resume(coroutine.create(function()
					VALUE1 = true
					wait(2)
					CreateSound(333430981,RootPart,2,math.random(5, 15) / 10,false)
					for i=1,25 do
						Swait()
						FT.Parent = Torso
						FRA.Parent = RightArm
						FLA.Parent = LeftArm
						FRL.Parent = RightLeg
						FLL.Parent = LeftLeg
						for _,v in next, Character:GetDescendants() do
							if(v:IsA'DataModelMesh')then
								v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
							end
						end		
					end
					VALUE1 = false
					FT.Parent = nil
					FRA.Parent = nil
					FLA.Parent = nil
					FRL.Parent = nil
					FLL.Parent = nil
					for _,v in next, Character:GetDescendants() do
						if(v:IsA'DataModelMesh')then
							v.Offset = VT(0,0,0)
						end
					end	
				end))
			end
			if MRANDOM(1,10) == 1 then
				Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
			end
			if math.random(1,8) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-87498,12093847)), RAD(MRANDOM(-123456,3746525)), RAD(MRANDOM(-2134567876,98764356))), 0.15 / Animation_Speed)
			end
			if(math.random(1,4)==1)then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999)), RAD(MRANDOM(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			end	
			if MRANDOM(1,10) == 1 then
				Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(23 + MRANDOM(-5,5)),RAD(MRANDOM(-5,5)),RAD(22 + MRANDOM(-5,5))),1)
			end
			local bouncyboi = sick.PlaybackLoudness / 1200
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.1 + 0.05 * COS(SINE / 12) + bouncyboi) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.7, 0.5 + sick.PlaybackLoudness / 1200, -0.3) * ANGLES(RAD(-200), RAD(0), RAD(30)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(20), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12) - bouncyboi, -0.01) * ANGLES(RAD(5), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MRANDOM(-5,5) - 4 * COS(SINE / 12)), RAD(MRANDOM(-5,5)), RAD(15)), 1 / Animation_Speed)--]
			snap = math.random(1,72)
			if snap == 1 then
				CreateSound(363808674,Head,3,1.3,false)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-100000-sick.PlaybackLoudness/7,100000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-99999-sick.PlaybackLoudness/7,99999+sick.PlaybackLoudness/7)), RAD(MRANDOM(-200-sick.PlaybackLoudness/7,48375935+sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
			end 
			if MRANDOM(1,20+sick.PlaybackLoudness/7) == 1 then
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-90-sick.PlaybackLoudness/7,90+sick.PlaybackLoudness/7)), RAD(MRANDOM(-30-sick.PlaybackLoudness/7,30+sick.PlaybackLoudness/7)), RAD(MRANDOM(-50-sick.PlaybackLoudness/7,50+sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MRANDOM(-10000-sick.PlaybackLoudness/7,10000+sick.PlaybackLoudness/7)), RAD(MRANDOM(-900-sick.PlaybackLoudness/7,900+sick.PlaybackLoudness/7)), RAD(MRANDOM(-20-sick.PlaybackLoudness/7,20+sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
			end		   
			if MRANDOM(1, 10) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
			end
		elseif ATTACK == false and BanishMode == 324 then
			local loudness = sick.PlaybackLoudness
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})					
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15+(sick.PlaybackLoudness)/-19 - 2.5 * SIN(SINE / 15)), RAD(0), RAD(-25)), 3 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(40+(sick.PlaybackLoudness)/7.5), RAD(0), RAD(37)) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.8 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-26+5*COS(SINE/15))) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil and Rooted == false then
		ANIM = "Walk"
		motor1.C0 = clerp(motor1.C0, CFrame.new(2.36, -1.8, -0.87) * angles(math.rad(-60 + -10 * math.cos(sine / 10)), math.rad(-45 + 10 * math.cos(sine / 10)), math.rad(45 + 0 * math.cos(sine / 10))), 0.1)
		motor2.C0 = clerp(motor2.C0, CFrame.new(-2.36, -1.8, -0.87) * angles(math.rad(-60 + 10 * math.cos(sine / 10)), math.rad(45 + 10 * math.cos(sine / 10)), math.rad(-45 + 0 * math.cos(sine / 10))), 0.1)
		if ATTACK == false and BanishMode == "chxll" then
			WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.01,0.015,0.01)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(math.random(-5,5)),RAD(math.random(-360,360)),RAD(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,2+0.5*COS(SINE / 12))*ANGLES(RAD(25+2.5*COS(SINE / 12)),RAD(0-RootPart.RotVelocity.y),RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(SINE / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-90-10*math.cos(sine/7)), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-90-10*math.cos(sine/7)), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.001*COS(SINE / 7), -0.01) * ANGLES(RAD(-10-2.5*math.cos(sine/7)), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.001*math.cos(sine/7), -0.5) * ANGLES(RAD(-25-2.5*math.cos(sine/7)), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 20 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 4321 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 30 then
			local loudness = sick.PlaybackLoudness
			WACKYEFFECT({Time = 25, EffectType = "Crystal", Size = VT(0,0,0), Size2 = VT(7+sick.PlaybackLoudness/5,0.55,7+sick.PlaybackLoudness/5), Transparency = 0.3, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 0})
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 33 then
			WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.01,0.015,0.01)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(math.random(-5,5)),RAD(math.random(-360,360)),RAD(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1245 then
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.15 / 1)
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(10 * COS(SINE / 7))), 0.15)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(0), RAD(0), RAD(0)), 0.3)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.925 - 0.5 * COS(SINE / 7) / 2, 0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.925 + 0.5 * COS(SINE / 7) / 2, -0.5 * COS(SINE / 7) / 2) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(-90 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30), 0.025 * COS(SINE / 20)) * ANGLES(RAD(-70) * COS(SINE / 7) , RAD(-90),	RAD(-5)), 0.1)
		elseif ATTACK == false and BanishMode == 1234 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.15 * COS(SINE / 47), -0.5, 0.5 + 0.1 * COS(SINE / 28)) * ANGLES(RAD(70), RAD(0 - RootPart.RotVelocity.Y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), .2 / 3)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-17 - 5 * COS(SINE / 52)), RAD(0 - 3 * COS(SINE / 37)), RAD(0 + 2 * COS(SINE / 78))), .2 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 4 * COS(SINE / 59)), RAD(-20 + 7 * COS(SINE / 62)), RAD(20 + 5 * COS(SINE / 50)))* RIGHTSHOULDERC0, .2 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.1 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 3 * COS(SINE / 55)), RAD(20 + 8 * COS(SINE / 67)), RAD(-20 - 4 * COS(SINE / 29))) * LEFTSHOULDERC0, .2 / 3)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -0.5, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(1.5), RAD(0), RAD(-20 - 5 * COS(SINE / 34))), .2 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(1), RAD(0), RAD(20 + 2 * COS(SINE / 38))), .2 / 3)
		elseif ATTACK == false and BanishMode == 444 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.15 * COS(SINE / 47), -0.5, 0.5 + 0.1 * COS(SINE / 28)) * ANGLES(RAD(70), RAD(0 - RootPart.RotVelocity.Y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), .2 / 3)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-17 - 5 * COS(SINE / 52)), RAD(0 - 3 * COS(SINE / 37)), RAD(0 + 2 * COS(SINE / 78))), .2 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 4 * COS(SINE / 59)), RAD(-20 + 7 * COS(SINE / 62)), RAD(20 + 5 * COS(SINE / 50)))* RIGHTSHOULDERC0, .2 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.1 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 3 * COS(SINE / 55)), RAD(20 + 8 * COS(SINE / 67)), RAD(-20 - 4 * COS(SINE / 29))) * LEFTSHOULDERC0, .2 / 3)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -0.5, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(1.5), RAD(0), RAD(-20 - 5 * COS(SINE / 34))), .2 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(1), RAD(0), RAD(20 + 2 * COS(SINE / 38))), .2 / 3)
		elseif ATTACK == false and BanishMode == 445 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 446 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1111 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 5555 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(sine/63)+.92*Sin(sine/95), 0, 1 + 1 * SIN(SINE / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
		elseif ATTACK == false and BanishMode == "tale" then
			RightHip.C0=Clerp(RightHip.C0,cf(1,-0.85,-0.15 - 0.15 * math.cos(SINE / 8))*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(0),math.rad(0 + 5 * math.cos(SINE / 12)),math.rad(5 + 25 * math.cos(SINE / 12))),.1)
			LeftHip.C0=Clerp(LeftHip.C0,cf(-1,-0.85,-0.15 + 0.15 * math.cos(SINE / 8))*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(0),math.rad(0 + 5 * math.cos(SINE / 12)),math.rad(-5 + 25 * math.cos(SINE / 12))),.1)
			RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*cf(0,0,-0.15 - 0.1 * math.cos(SINE / 8))*ANGLES(math.rad(12.5),math.rad(0),math.rad(0 - 5 * math.cos(SINE / 12))),.1)
			Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*ANGLES(math.rad(30 - 5 * math.cos(SINE / 0.5265)),math.rad(0 - 5 * math.cos(SINE / 0.25)),math.rad(0 - 5 * math.cos(SINE / 0.465))),.1)
			RightShoulder.C0=Clerp(RightShoulder.C0,cf(0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(-20 + 2.5 * math.cos(SINE / 28))),.1)
			LeftShoulder.C0=Clerp(LeftShoulder.C0,cf(-0.75,0.5,-0.25)*ANGLES(math.rad(140),math.rad(0),math.rad(20 - 2.5 * math.cos(SINE / 28))),.1)
		elseif ATTACK == false and BanishMode == 3333 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
			Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
		elseif ATTACK == false and BanishMode == 1222 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.15 * COS(SINE / 47), -0.5, 0.5 + 0.1 * COS(SINE / 28)) * ANGLES(RAD(70), RAD(0 - RootPart.RotVelocity.Y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), .2 / 3)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-17 - 5 * COS(SINE / 52)), RAD(0 - 3 * COS(SINE / 37)), RAD(0 + 2 * COS(SINE / 78))), .2 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 4 * COS(SINE / 59)), RAD(-20 + 7 * COS(SINE / 62)), RAD(20 + 5 * COS(SINE / 50)))* RIGHTSHOULDERC0, .2 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.1 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 3 * COS(SINE / 55)), RAD(20 + 8 * COS(SINE / 67)), RAD(-20 - 4 * COS(SINE / 29))) * LEFTSHOULDERC0, .2 / 3)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -0.5, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(1.5), RAD(0), RAD(-20 - 5 * COS(SINE / 34))), .2 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(1), RAD(0), RAD(20 + 2 * COS(SINE / 38))), .2 / 3)
		elseif ATTACK == false and BanishMode == 3 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 987 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 564 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(50), RAD(0+MRANDOM(-45,45)), RAD(5))* RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1456 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.25 * COS(SINE / 28)) * ANGLES(RAD(25+2.5*COS(SINE/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(RAD(-5+3.4*COS(SINE/28)),RAD(3*COS(SINE/28)),RAD(0)),1/Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5, 0.5, 0)*ANGLES(RAD(-90-5*COS(SINE/28)),RAD(0),RAD(0))* RIGHTSHOULDERC0,1/Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, -.7) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.05*COS(SINE / 28), -0.01) * ANGLES(RAD(-4), RAD(80), RAD(0)) * ANGLES(RAD(-8-2.5*COS(SINE/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1457 then
			local headsnap = math.random(1,60);
			local headsnapping=false;
			if headsnap == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(math.random(500,500)), math.rad(math.random(500,500)), math.rad(math.random(500,500))), 1)headsnapping=true headsnapping=false
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 , 0 , 0 - .5 * math.sin(sine/25)) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.8 / 3)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CFrame.new(0, 0, 0) * CFrame.Angles(25-math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3)), math.rad(math.random(0.25,3))), .7 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(20), math.rad(5+2* math.sin(sine/25+math.random(0.25,3))), math.rad(2+5*math.sin(sine / 25))) * RIGHTSHOULDERC0, .7 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(90-4*math.sin(sine/25)), math.rad(5+2* math.sin(sine/25+math.random(-0.25,3))), math.rad(-2+5*math.sin(sine / 25))) * LEFTSHOULDERC0, .7 / 3)
			RightHip.C0 = Clerp(RightHip.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-30-4*math.sin(sine/25-math.random(0.25,3))), math.rad(80), math.rad(0)), .7 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0, CFrame.new(-1, -1 , 0) * CFrame.Angles(math.rad(-20-4*math.sin(sine/25-math.random(-0.25,3))), math.rad(-80), math.rad(0)), .7 / 3)
		elseif ATTACK == false and BanishMode == 5 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1458 then
			RH.C0=Clerp(RH.C0,CF(1,-0.85,-0.15 - 0.15 * math.cos(sine / 4))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 25 * math.cos(sine / 8))),.1)
			LH.C0=Clerp(LH.C0,CF(-1,-0.85,-0.15 + 0.15 * math.cos(sine / 4))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 25 * math.cos(sine / 8))),.1)
			RootJoint.C0=Clerp(RootJoint.C0,RootCF*CF(0,0,-0.15 - 0.1 * math.cos(sine / 4))*angles(math.rad(5),math.rad(0),math.rad(0 - 5 * math.cos(sine / 8))),.1)
			Neck.C0=Clerp(Neck.C0,necko*angles(math.rad(25 - 5 * math.cos(sine / 0.325)),math.rad(0 - 5 * math.cos(sine / 0.25)),math.rad(0 + 5 * math.cos(sine / 8))),.1)
			RW.C0=Clerp(RW.C0,CF(1.5,0.5,0)*angles(math.rad(0 - 45 * math.cos(sine / 8)),math.rad(0),math.rad(10 - 10 * math.cos(sine / 4))),.1)
			LW.C0=Clerp(LW.C0,CF(-1.5,0.5,0)*angles(math.rad(160),math.rad(0),math.rad(25)),.1)
		elseif ATTACK == false and BanishMode == 1459 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 60 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 64 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / 18)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / 18), -0.2+ 0.2 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / 18), -0.2+ -0.2 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)	
		elseif ATTACK == false and BanishMode == 963 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,2+0.5*COS(SINE / 12))*ANGLES(RAD(25+2.5*COS(SINE / 12)),RAD(0-RootPart.RotVelocity.y),RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-1+-2*COS(SINE / 32)), RAD(0), RAD(10)), 1 / Animation_Speed) 
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-90-10*math.cos(sine/7)), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-90-10*math.cos(sine/7)), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.001*COS(SINE / 7), -0.01) * ANGLES(RAD(-10-2.5*math.cos(sine/7)), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.001*math.cos(sine/7), -0.5) * ANGLES(RAD(-25-2.5*math.cos(sine/7)), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 61 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.25 * COS(SINE / 28)) * ANGLES(RAD(25+2.5*COS(SINE/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(RAD(-5+3.4*COS(SINE/28)),RAD(3*COS(SINE/28)),RAD(0)),1/Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5, 0.5, 0)*ANGLES(RAD(-90-5*COS(SINE/28)),RAD(0),RAD(0))* RIGHTSHOULDERC0,1/Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, -.7) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.05*COS(SINE / 28), -0.01) * ANGLES(RAD(-4), RAD(80), RAD(0)) * ANGLES(RAD(-8-2.5*COS(SINE/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
		elseif ATTACK == false and BanishMode == "silent" then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)),RAD(0)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 872 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)),RAD(0)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 666 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)),RAD(0)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 777777 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 1 * SIN(SINE / 26)) * ANGLES(RAD(25 - 2.5*SIN(SINE/48/2)), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0 + 2.5 *COS(SINE / 12)), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(SINE/12)), RAD(0), RAD(12 - 4.10 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20 - 13*SIN(SINE/12)), RAD(0), RAD(-12 + 4.10 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 7777778 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 999999 then
			RightHip.C0=Clerp(RightHip.C0,cf(1,-0.5,-0.6)*angles(RAD(0),RAD(90),RAD(0))*angles(RAD(1.5),RAD(0),RAD(-20 - 5 * COS(sine / 34))),.2)
			LeftHip.C0=Clerp(LeftHip.C0,cf(-1,-1,0)*angles(RAD(0),RAD(-90),RAD(0))*angles(RAD(1),RAD(0),RAD(20 + 2 * COS(sine / 38))),.2)
			RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*cf(0 - 0.15 * COS(sine / 47),-0.5,2.5 + 0.25 * COS(sine / 28))*angles(RAD(70),RAD(0 - RootPart.RotVelocity.Y),RAD(0 - RootPart.RotVelocity.Y *4.5 + 3 * COS(sine / 47))),.05)
			Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(-17 - 5 * COS(sine / 52)),RAD(0 - 3 * COS(sine / 37)),RAD(0 + 2 * COS(sine / 78))),.2)
			RightShoulder.C0=Clerp(RightShoulder.C0,cf(1.5,0.5 + 0.05 * COS(sine / 28),0)*angles(RAD(-8 - 4 * COS(sine / 59)),RAD(-20 + 7 * COS(sine / 62)),RAD(20 + 5 * COS(sine / 50))),.2)
			LeftShoulder.C0=Clerp(LeftShoulder.C0,cf(-1.5,0.5 + 0.1 * COS(sine / 28),0)*angles(RAD(-8 - 3 * COS(sine / 55)),RAD(20 + 8 * COS(sine / 67)),RAD(-20 - 4 * COS(sine / 29))),.2)
		elseif ATTACK == false and BanishMode == 100000 then
			RightHip.C0=Clerp(RightHip.C0,cf(1,-0.5,-0.6)*angles(RAD(0),RAD(90),RAD(0))*angles(RAD(1.5),RAD(0),RAD(-20 - 5 * COS(sine / 34))),.2)
			LeftHip.C0=Clerp(LeftHip.C0,cf(-1,-1,0)*angles(RAD(0),RAD(-90),RAD(0))*angles(RAD(1),RAD(0),RAD(20 + 2 * COS(sine / 38))),.2)
			RootJoint.C0=Clerp(RootJoint.C0,ROOTC0*cf(0 - 0.15 * COS(sine / 47),-0.5,2.5 + 0.25 * COS(sine / 28))*angles(RAD(70),RAD(0 - RootPart.RotVelocity.Y),RAD(0 - RootPart.RotVelocity.Y *4.5 + 3 * COS(sine / 47))),.05)
			Torso.Neck.C0=Clerp(Torso.Neck.C0,NECKC0*angles(RAD(-17 - 5 * COS(sine / 52)),RAD(0 - 3 * COS(sine / 37)),RAD(0 + 2 * COS(sine / 78))),.2)
			RightShoulder.C0=Clerp(RightShoulder.C0,cf(1.5,0.5 + 0.05 * COS(sine / 28),0)*angles(RAD(-8 - 4 * COS(sine / 59)),RAD(-20 + 7 * COS(sine / 62)),RAD(20 + 5 * COS(sine / 50))),.2)
			LeftShoulder.C0=Clerp(LeftShoulder.C0,cf(-1.5,0.5 + 0.1 * COS(sine / 28),0)*angles(RAD(-8 - 3 * COS(sine / 55)),RAD(20 + 8 * COS(sine / 67)),RAD(-20 - 4 * COS(sine / 29))),.2)
		elseif ATTACK == false and BanishMode == 888888 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 + .25*Cos(sine/63)+.92*Sin(sine/95), 0, 1 + 1 * SIN(SINE / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12 + 4.10 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
		elseif ATTACK == false and BanishMode == 1666 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1667 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 + .5 * math.cos(sine/15)) * CFrame.Angles(math.rad(40),math.rad(-5*math.cos(sine/30)),math.rad(0)),0.7/3)
			Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),0.7/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,0.7/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-5 - 2 * math.cos(sine/19))) * LEFTSHOULDERC0,0.7/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
		elseif ATTACK == false and BanishMode == 1668 then
			RH.C0=Clerp(RH.C0,CF(1,-0.85,-0.15 - 0.15 * math.cos(sine / 4))*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 25 * math.cos(sine / 8))),.1)
			LH.C0=Clerp(LH.C0,CF(-1,-0.85,-0.15 + 0.15 * math.cos(sine / 4))*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 25 * math.cos(sine / 8))),.1)
			RootJoint.C0=Clerp(RootJoint.C0,RootCF*CF(0,0,-0.15 - 0.1 * math.cos(sine / 4))*angles(math.rad(5),math.rad(0),math.rad(0 - 5 * math.cos(sine / 8))),.1)
			Neck.C0=Clerp(Neck.C0,necko*angles(math.rad(25 - 5 * math.cos(sine / 0.325)),math.rad(0 - 5 * math.cos(sine / 0.25)),math.rad(0 + 5 * math.cos(sine / 8))),.1)
			RW.C0=Clerp(RW.C0,CF(1.5,0.5,0)*angles(math.rad(0 - 45 * math.cos(sine / 8)),math.rad(0),math.rad(10 - 10 * math.cos(sine / 4))),.1)
			LW.C0=Clerp(LW.C0,CF(-1.5,0.5,0)*angles(math.rad(160),math.rad(0),math.rad(25)),.1)
		elseif ATTACK == false and BanishMode == 777 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)),RAD(0)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 555 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)),RAD(0)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 1555 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)),RAD(0)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 7895 then
			WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			local loudness = sick.PlaybackLoudness
			WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,25,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,15)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Torso.Color, UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})					
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
			Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
		elseif ATTACK == false and BanishMode == 876 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
			Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
		elseif ATTACK == false and BanishMode == 865 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
			Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
		elseif ATTACK == false and BanishMode == 900 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)),RAD(0)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 999 then
			WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.01,0.015,0.01)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(math.random(-5,5)),RAD(math.random(-360,360)),RAD(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			sphere2(8, "Add", LeftArm.CFrame * CF(0,-1,0) * ANGLES(RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360, 360)), RAD(MRANDOM(-360,360))),VT(1,1,1), -0.01, 0.05, -0.01,BRICKC("Dark blue"),BRICKC("Dark blue").Color)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)),RAD(0)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 5986 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 159 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 158 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.15 * COS(SINE / 47), -0.5, 0.5 + 0.1 * COS(SINE / 28)) * ANGLES(RAD(70), RAD(0 - RootPart.RotVelocity.Y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), .2 / 3)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-17 - 5 * COS(SINE / 52)), RAD(0 - 3 * COS(SINE / 37)), RAD(0 + 2 * COS(SINE / 78))), .2 / 3)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 4 * COS(SINE / 59)), RAD(-20 + 7 * COS(SINE / 62)), RAD(20 + 5 * COS(SINE / 50)))* RIGHTSHOULDERC0, .2 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.1 * COS(SINE / 28), 0) * ANGLES(RAD(-8 - 3 * COS(SINE / 55)), RAD(20 + 8 * COS(SINE / 67)), RAD(-20 - 4 * COS(SINE / 29))) * LEFTSHOULDERC0, .2 / 3)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -0.5, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(1.5), RAD(0), RAD(-20 - 5 * COS(SINE / 34))), .2 / 3)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(1), RAD(0), RAD(20 + 2 * COS(SINE / 38))), .2 / 3)
		elseif ATTACK == false and BanishMode == 7834 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MRANDOM(-15, 25)), RAD(MRANDOM(-15, 25))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		elseif ATTACK == false and BanishMode == 782 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
			Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
		elseif ATTACK == false and BanishMode == 366 then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
			Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
			RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(sine/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(sine/50))) * LEFTSHOULDERC0,0.7/3)
			RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(sine/50))),1/3)
			LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(sine/50))),1/3)
		elseif ATTACK == false and BanishMode == 324 then
			local loudness = sick.PlaybackLoudness
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})					
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-50), RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)),RAD(0)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
	end
	if ATTACK == false and BanishMode == 1221 then
		local loudness = sick.PlaybackLoudness
		local val = MRANDOM(1,255)
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(val,val,val), SoundID = nil, SoundPitch = nil, SoundVolume = nil})			
	end
	if ATTACK == false and BanishMode == 366 then
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local loudness = sick.PlaybackLoudness
		local FRAME = CF(VT(Torso.Position.X+MRANDOM(-15,15),Torso.Position.Y,Torso.Position.Z+MRANDOM(-15,15)))
		CamShakeAll(sick.PlaybackLoudness/15,sick.PlaybackLoudness/15)
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
	end

	if ATTACK == false and BanishMode == 555 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
	end

	if ATTACK == false and BanishMode == 872 then
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),0,0).p
		SPHEREFLOOR,SPHEREPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
		WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Sphere", Size = Vector3.new(1.5,1.5,1.5)*1, Size2 = Vector3.new(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(SPHEREPOS-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = SPHEREPOS+Vector3.new(0,MRANDOM(15,25)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
		WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Skull", Size = Vector3.new(1.5,1.5,1.5)*3.95, Size2 = Vector3.new(0.425,0.425,0.425), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(SPHEREPOS-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = SPHEREPOS+Vector3.new(0,MRANDOM(25,35)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})		
	end
	if ATTACK == false and BanishMode == 666 then
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(math.random(0,255),255,255), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(math.random(0,255),255,255), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(math.random(0,255),255,255), SoundID = nil, SoundPitch = nil, SoundVolume = nil})					
	end
	if ATTACK == false and BanishMode == 61 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})					
	end

	if ATTACK == false and BanishMode == 564 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 1457 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 1459 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 999999 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})			
	end
	if ATTACK == false and BanishMode == 100000 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})			
		WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
	end
	if ATTACK == false and BanishMode == 963 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/700,0,100), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/700,0,100), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end

	if ATTACK == false and BanishMode == 1667 then
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(math.clamp(sick.PlaybackLoudness-255,0,255),math.clamp(sick.PlaybackLoudness-255,0,255)/2,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(3,3,3)/3, Size2 = VT(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(math.clamp(sick.PlaybackLoudness-255,0,255),math.clamp(sick.PlaybackLoudness-255,0,255)/2,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end

	if ATTACK == false and BanishMode == 1234 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Torso.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
	end

	if ATTACK == false and BanishMode == 158 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})			
	end
	if ATTACK == false and BanishMode == 64 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})			
	end
	if ATTACK == false and BanishMode == 987 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 444 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 445 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})			
	end
	if ATTACK == false and BanishMode == 446 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})			
	end
	if ATTACK == false and BanishMode == 865 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 4321 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 33 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 1668 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 1222 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 1458 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 5555 then
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		local loudness = sick.PlaybackLoudness
		if math.random(1,3) == 1 then
			WACKYEFFECT({TIME = MRANDOM(15,25)*2, EffectType = "Block", Size = VT(3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-40,40),2,MRANDOM(-40,40))), MoveToPos = Torso.Position+VT(0,MRANDOM(85,185)/2.5,0), RotationX = 360*Cos(sine/2), RotationY = 360*Cos(sine/2), RotationZ = 360*Cos(sine/2), Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
			WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500)), SoundID = nil, SoundPitch = nil, SoundVolume = nil})			
		end
	end
	if ATTACK == false and BanishMode == 876 then
		local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
		local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),0,0).p
		SPHEREFLOOR,SPHEREPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -1, 0))).lookVector, 5, Character)
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,25,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(3,15)) * ANGLES(RAD(MRANDOM(-15,15)), RAD(0), RAD(MRANDOM(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100), UseBoomerangMath = true, SizeBoomerang = 50, SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
		WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Sphere", Size = Vector3.new(1.5,1.5,1.5)*1, Size2 = Vector3.new(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(SPHEREPOS-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = SPHEREPOS+Vector3.new(0,MRANDOM(15,25)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = Vector3.new(3,3,3)/3, Size2 = Vector3.new(0,0,0), Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = MRANDOM(10,30)*2, EffectType = "Skull", Size = Vector3.new(1.5,1.5,1.5)*3.95, Size2 = Vector3.new(0.425,0.425,0.425), Transparency = 0, Transparency2 = 1, CFrame = CFrame.new(SPHEREPOS-Vector3.new(0,2,0))*CFrame.Angles(math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360)),math.rad(MRANDOM(0,360))), MoveToPos = SPHEREPOS+Vector3.new(0,MRANDOM(25,35)/5,0), MRANDOM(-25,25)/35, RotationY = MRANDOM(-25,25)/35, RotationZ = MRANDOM(-25,25)/35, Material = "Neon", Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100), SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2,RED = true})	
	end
	if ATTACK == false and BanishMode == 782 then
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.01,0.015,0.01)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*CFrame.Angles(RAD(math.random(-5,5)),RAD(math.random(-360,360)),RAD(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BrickColor.Random().Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end
	if ATTACK == false and BanishMode == 5 then
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = MRANDOM(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MRANDOM(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == "tale" then
		local loudness = sick.PlaybackLoudness
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end
	if ATTACK == false and BanishMode == 777777 then
		local loudness = sick.PlaybackLoudness
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end

	if ATTACK == false and BanishMode == 7777778 then
		local loudness = sick.PlaybackLoudness
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*sick.PlaybackLoudness/75,0,1*sick.PlaybackLoudness/75), Size2 = VT(1*sick.PlaybackLoudness/75,0.5,7*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(math.random(0,255),0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*sick.PlaybackLoudness/75,0,10*sick.PlaybackLoudness/75), Size2 = VT(7*sick.PlaybackLoudness/75,0.69,1*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(math.random(0,255),0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*sick.PlaybackLoudness/75,0,4*sick.PlaybackLoudness/75), Size2 = VT(4*sick.PlaybackLoudness/75,0.5,4*sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(math.random(0,255),0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
	end

	if ATTACK == false and BanishMode == 888888 then
		local loudness = sick.PlaybackLoudness
		CamShakeAll(sick.PlaybackLoudness/25,sick.PlaybackLoudness/25)
		WACKYEFFECT({TIME = MRANDOM(15,25)*2, EffectType = "Block", Size = VT(3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MRANDOM(-40,40),2,MRANDOM(-40,40))), MoveToPos = Torso.Position+VT(0,MRANDOM(85,185)/2.5,0), RotationX = 360*Cos(sine/2), RotationY = 360*Cos(sine/2), RotationZ = 360*Cos(sine/2), Material = "Neon", Color = Color3.new(sick.PlaybackLoudness/500,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	end

	if ATTACK == false and BanishMode == "chxll" or BanishMode == "silent" or BanishMode == 987 or BanishMode == 1234 or BanishMode == 1222 or BanishMode == 1456 or BanishMode == 61 or BanishMode == 865 or BanishMode == 1245 or BanishMode == 5986 or BanishMode == 159 or BanishMode == 1666 or BanishMode == 20 or BanishMode == 30 or BanishMode == 33 or BanishMode == 324 or BanishMode == 3 or BanishMode == 1555 or BanishMode == 900 or BanishMode == 7895 or BanishMode == 999 or BanishMode == 777 then
		RightArm.Color = outer.Color
		LeftArm.Color = outer.Color
		Torso.Color = outer.Color
		Head.Color = outer.Color
		LeftLeg.Color = outer.Color
		RightLeg.Color = outer.Color
	end

	if ATTACK == false and BanishMode == 5 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Torso.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Head.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
	end
	if ATTACK == false and BanishMode == 158 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Torso.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Head.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
	end
	if ATTACK == false and BanishMode == 1458 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Torso.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Head.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
	end
	if ATTACK == false and BanishMode == 100000 then
		RightArm.Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000)
		LeftArm.Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000)
		Torso.Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000)
		Head.Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000)
		LeftLeg.Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000)
		RightLeg.Color = C3(100*sick.PlaybackLoudness/10000,0,100*sick.PlaybackLoudness/10000)
	end
	if ATTACK == false and BanishMode == 1667 then
		RightArm.Color = Color3.fromRGB(math.clamp(sick.PlaybackLoudness-255,0,255),math.clamp(sick.PlaybackLoudness-255,0,255)/2,0)
		LeftArm.Color = Color3.fromRGB(math.clamp(sick.PlaybackLoudness-255,0,255),math.clamp(sick.PlaybackLoudness-255,0,255)/2,0)
		Torso.Color = Color3.fromRGB(math.clamp(sick.PlaybackLoudness-255,0,255),math.clamp(sick.PlaybackLoudness-255,0,255)/2,0)
		Head.Color = Color3.fromRGB(math.clamp(sick.PlaybackLoudness-255,0,255),math.clamp(sick.PlaybackLoudness-255,0,255)/2,0)
		LeftLeg.Color = Color3.fromRGB(math.clamp(sick.PlaybackLoudness-255,0,255),math.clamp(sick.PlaybackLoudness-255,0,255)/2,0)
		RightLeg.Color = Color3.fromRGB(math.clamp(sick.PlaybackLoudness-255,0,255),math.clamp(sick.PlaybackLoudness-255,0,255)/2,0)
	end
	if ATTACK == false and BanishMode == 1668 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Torso.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Head.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
	end
	if ATTACK == false and BanishMode == 999999 then
		RightArm.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		LeftArm.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		Torso.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		Head.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		LeftLeg.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		RightLeg.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
	end
	if ATTACK == false and BanishMode == 4321 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/250*sick.PlaybackLoudness/1000,20,10)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/250*sick.PlaybackLoudness/1000,20,10)
		Torso.Color = Color3.new(sick.PlaybackLoudness/250*sick.PlaybackLoudness/1000,20,10)
		Head.Color = Color3.new(sick.PlaybackLoudness/250*sick.PlaybackLoudness/1000,20,10)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/250*sick.PlaybackLoudness/1000,20,10)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/250*sick.PlaybackLoudness/1000,20,10)
	end
	if ATTACK == false and BanishMode == 1457 then
		local falhsing = math.random(0,1)
		RightArm.Color = Color3.fromHSV(0, 0, falhsing)
		LeftArm.Color = Color3.fromHSV(0, 0, falhsing)
		Torso.Color = Color3.fromHSV(0, 0, falhsing)
		Head.Color = Color3.fromHSV(0, 0, falhsing)
		LeftLeg.Color = Color3.fromHSV(0, 0, falhsing)
		RightLeg.Color = Color3.fromHSV(0, 0, falhsing)
	end
	if ATTACK == false and BanishMode == 1459 then
		RightArm.Color = Color3.fromRGB(sick.PlaybackLoudness/255,math.random(106,255),0)
		LeftArm.Color = Color3.fromRGB(sick.PlaybackLoudness/255,math.random(106,255),0)
		Torso.Color = Color3.fromRGB(sick.PlaybackLoudness/255,math.random(106,255),0)
		Head.Color = Color3.fromRGB(sick.PlaybackLoudness/255,math.random(106,255),0)
		LeftLeg.Color = Color3.fromRGB(sick.PlaybackLoudness/255,math.random(106,255),0)
		RightLeg.Color = Color3.fromRGB(sick.PlaybackLoudness/255,math.random(106,255),0)
	end
	if ATTACK == false and BanishMode == 564 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Torso.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Head.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
	end
	if ATTACK == false and BanishMode == 366 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Torso.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Head.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
	end
	if ATTACK == false and BanishMode == 555 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Torso.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Head.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
	end
	if ATTACK == false and BanishMode == 445 then
		RightArm.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		LeftArm.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		Torso.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		Head.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		LeftLeg.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		RightLeg.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
	end
	if ATTACK == false and BanishMode == 446 then
		RightArm.Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000)
		LeftArm.Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000)
		Torso.Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000)
		Head.Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000)
		LeftLeg.Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000)
		RightLeg.Color = C3(98/255 + sick.PlaybackLoudness/1000, 37/255 + sick.PlaybackLoudness/1000, 209/255 + sick.PlaybackLoudness/1000)
	end
	if ATTACK == false and BanishMode == 888888 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Torso.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Head.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
	end
	if ATTACK == false and BanishMode == 5555 then
		RightArm.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		LeftArm.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		Head.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		Torso.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		LeftLeg.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
		RightLeg.Color = C3(math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500),math.min(1,sick.PlaybackLoudness/500))
	end
	if ATTACK == false and BanishMode == 7834 then
		RightArm.Color = Color3.fromRGB(math.random(0,255),0,0)
		LeftArm.Color = Color3.fromRGB(math.random(0,255),0,0)
		Head.Color = Color3.fromRGB(math.random(0,255),0,0)
		Torso.Color = Color3.fromRGB(math.random(0,255),0,0)
		LeftLeg.Color = Color3.fromRGB(math.random(0,255),0,0)
		RightLeg.Color = Color3.fromRGB(math.random(0,255),0,0)
	end
	if ATTACK == false and BanishMode == 666 then
		RightArm.Color = Color3.fromRGB(math.random(0,255),255,255)
		LeftArm.Color = Color3.fromRGB(math.random(0,255),255,255)
		Head.Color = Color3.fromRGB(math.random(0,255),255,255)
		Torso.Color = Color3.fromRGB(math.random(0,255),255,255)
		LeftLeg.Color = Color3.fromRGB(math.random(0,255),255,255)
		RightLeg.Color = Color3.fromRGB(math.random(0,255),255,255)
	end
	if ATTACK == false and BanishMode == 777777 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/20,0,10)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/20,0,10)
		Head.Color = Color3.new(sick.PlaybackLoudness/20,0,10)
		Torso.Color = Color3.new(sick.PlaybackLoudness/20,0,10)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/20,0,10)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/20,0,10)
	end
	if ATTACK == false and BanishMode == 782 then
		COLORSHIFT = C3(MRANDOM(1,255),MRANDOM(1,255),MRANDOM(1,255))
		RightArm.Color = BrickColor.Random().Color
		LeftArm.Color = BrickColor.Random().Color
		Head.Color = BrickColor.Random().Color
		Torso.Color = BrickColor.Random().Color
		LeftLeg.Color = BrickColor.Random().Color
		RightLeg.Color = BrickColor.Random().Color
	end
	if ATTACK == false and BanishMode == 60 then
		RightArm.Color = Color3.fromRGB(0,0,178*sick.PlaybackLoudness/100)
		LeftArm.Color = Color3.fromRGB(0,0,178*sick.PlaybackLoudness/100)
		Head.Color = Color3.fromRGB(0,0,178*sick.PlaybackLoudness/100)
		Torso.Color = Color3.fromRGB(0,0,178*sick.PlaybackLoudness/100)
		LeftLeg.Color = Color3.fromRGB(0,0,178*sick.PlaybackLoudness/100)
		RightLeg.Color = Color3.fromRGB(0,0,178*sick.PlaybackLoudness/100)
	end
	if ATTACK == false and BanishMode == 64 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Head.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		Torso.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/500,0,0)
	end
	if ATTACK == false and BanishMode == 963 then
		RightArm.Color = Color3.new(sick.PlaybackLoudness/700,0,100)
		LeftArm.Color = Color3.new(sick.PlaybackLoudness/700,0,100)
		Head.Color = Color3.new(sick.PlaybackLoudness/700,0,100)
		Torso.Color = Color3.new(sick.PlaybackLoudness/700,0,100)
		LeftLeg.Color = Color3.new(sick.PlaybackLoudness/700,0,100)
		RightLeg.Color = Color3.new(sick.PlaybackLoudness/700,0,100)
	end
	if ATTACK == false and BanishMode == 876 then
		RightArm.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
		LeftArm.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
		Head.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
		Torso.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
		LeftLeg.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
		RightLeg.Color = Color3.fromRGB(0,0,0+178*sick.PlaybackLoudness/100)
	end
	if ATTACK == false and BanishMode == 1111 then
		local val = MRANDOM(1,255)
		RightArm.Color = Color3.fromRGB(val,val,val)
		LeftArm.Color = Color3.fromRGB(val,val,val)
		Head.Color = Color3.fromRGB(val,val,val)
		Torso.Color = Color3.fromRGB(val,val,val)
		LeftLeg.Color = Color3.fromRGB(val,val,val)
		RightLeg.Color = Color3.fromRGB(val,val,val)
	end
	if ATTACK == false and BanishMode == "tale" then
		local val = MRANDOM(1,255)
		RightArm.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		LeftArm.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		Head.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		Torso.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		LeftLeg.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		RightLeg.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
	end
	if ATTACK == false and BanishMode == 444 then
		local val = MRANDOM(1,255)
		RightArm.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		LeftArm.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		Head.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		Torso.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		LeftLeg.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
		RightLeg.Color = Color3.fromRGB(0+170*sick.PlaybackLoudness/1000,0,0+170*sick.PlaybackLoudness/1000)
	end
	if ATTACK == false and BanishMode == 3333 then
		local val = MRANDOM(1,255)
		RightArm.Color = Color3.fromRGB(0,0+200*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
		LeftArm.Color = Color3.fromRGB(0,0+200*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
		Head.Color = Color3.fromRGB(0,0+200*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
		Torso.Color = Color3.fromRGB(0,0+200*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
		LeftLeg.Color = Color3.fromRGB(0,0+200*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
		RightLeg.Color = Color3.fromRGB(0,0+200*sick.PlaybackLoudness/100,0+18*sick.PlaybackLoudness/100)
	end
	if ATTACK == false and BanishMode == 872 then
		RightArm.Color = Color3.fromRGB(math.random(0,255),0,0)
		LeftArm.Color = Color3.fromRGB(math.random(0,255),0,0)
		Head.Color = Color3.fromRGB(math.random(0,255),0,0)
		Torso.Color = Color3.fromRGB(math.random(0,255),0,0)
		LeftLeg.Color = Color3.fromRGB(math.random(0,255),0,0)
		RightLeg.Color = Color3.fromRGB(math.random(0,255),0,0)
	end
	if ATTACK == false and BanishMode == 7777778 then
		RightArm.Color = Color3.fromRGB(math.random(0,255),0,0)
		LeftArm.Color = Color3.fromRGB(math.random(0,255),0,0)
		Head.Color = Color3.fromRGB(math.random(0,255),0,0)
		Torso.Color = Color3.fromRGB(math.random(0,255),0,0)
		LeftLeg.Color = Color3.fromRGB(math.random(0,255),0,0)
		RightLeg.Color = Color3.fromRGB(math.random(0,255),0,0)
	end
	if DoGlitch == true then
		if MRANDOM(1,100) == 1 then
			coroutine.resume(coroutine.create(function()
				VALUE1 = true
				for i=1,25 do
					Swait()
					FT.Parent = Torso
					FRA.Parent = RightArm
					FLA.Parent = LeftArm
					FRL.Parent = RightLeg
					FLL.Parent = LeftLeg
					Humanoid.CameraOffset = VT(MRANDOM(-25,25)/2.5,MRANDOM(-25,25)/2.5,MRANDOM(-25,25)/2.5)/30
					local oof = Instance.new("FlangeSoundEffect",sick)
					for _,v in next, Character:GetDescendants() do
						if(v:IsA'DataModelMesh')then
							v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
						end
					end	
				end
				VALUE1 = false
				FT.Parent = nil
				FRA.Parent = nil
				FLA.Parent = nil
				FRL.Parent = nil
				FLL.Parent = nil
				for _,v in next, Character:GetDescendants() do
					if(v:IsA'DataModelMesh')then
						v.Offset = VT(0,0,0)
					end
				end
				sick:ClearAllChildren()
				Humanoid.CameraOffset = VT(0,0,0)
			end))
		end
	end
	unanchor()
	Humanoid.MaxHealth = math.huge
	Humanoid.Health = math.huge
	NAMEMODE.Rotation = 0+5*M.C(SINE/32)
	NAMEMODE.TextColor3 = Torso.Color
	hrt.Color = LeftArm.Color
	p.Color = Torso.Color
	pn.Color = Torso.Color
	Eye.Color = Torso.Color
	Eye2.Color = Torso.Color
	outer.Color = Torso.Color
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	sick.SoundId = "rbxassetid://"..SONG1
	sick.Looped = true
	Humanoid.Name = "gJFGHJHFJHGRSFGT7$&%6%#$TgeHGVBFG$#%$TGFEFEAFSD"
	Humanoid.JumpPower = Jump
	Humanoid.UseJumpPower = true
	Head.Parent = Character
	Torso.Parent = Character
	RightArm.Parent = Character
	LeftArm.Parent = Character
	LeftLeg.Parent = Character
	RightLeg.Parent = Character
	Head.Transparency = 0
	Torso.Transparency = 0
	RightArm.Transparency = 0
	LeftArm.Transparency = 0
	LeftLeg.Transparency = 0
	RightLeg.Transparency = 0
	Head.Locked = true
	Torso.Locked = true
	RightArm.Locked = true
	LeftArm.Locked = true
	LeftLeg.Locked = true
	RightLeg.Locked = true
	Shield.Locked = true
end
function KillLC()
	for i,v in pairs(game:GetService("PermissionsService"):GetDescendants()) do
		if v:IsA("LuaSourceContainer") then
			v.Disabled = true
		end
	end
	game:GetService("JointsService"):ClearAllChildren()
	game:GetService("PermissionsService"):ClearAllChildren()
end
KillLC()
local function CheckForBan(player)
	for i = 1, #BannedSkids do
		if player.Name == BannedSkids[i] then

		end
	end
end

game.Players.PlayerAdded:connect(function()
	for i,v in pairs(game.Players:GetPlayers())do
		CheckForBan(v)
	end  
end)


--//=================================\\
--\\=================================//

--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--
